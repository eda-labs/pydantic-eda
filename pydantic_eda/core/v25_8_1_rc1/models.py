# generated by datamodel-codegen:
#   filename:  core.json

from __future__ import annotations

from typing import Annotated, Any, Dict, List, Literal, Optional

from pydantic import AwareDatetime, BaseModel, Field, RootModel


class AlarmData(BaseModel):
    """
    The information about a single alarm or alarm history
    """

    acknowledged: Annotated[
        Optional[bool],
        Field(description="An indication if the alarm has been acknowledged."),
    ] = None
    acknowledgedUntil: Annotated[
        Optional[str],
        Field(description="Indicates the end time of the acknowledgement."),
    ] = None
    cleared: Annotated[
        Optional[bool],
        Field(description="An indication if the alarm has been cleared."),
    ] = None
    clusterMember: Annotated[
        Optional[str],
        Field(description="The cluster member that generated this alarm."),
    ] = None
    description: Annotated[
        Optional[str], Field(description="A description for the alarm.")
    ] = None
    group: Annotated[
        Optional[str],
        Field(
            description="Indicates the group of the resource the alarm is present on."
        ),
    ] = None
    jsPath: Annotated[
        Optional[str],
        Field(
            description='a unnormalized jspath relating to the object in the alarm state. For\nexample\n.node{.name=="spine-1-1"}.srl{.version=="24.10.1"}.interface{.name=="ethernet-1-1"}.'
        ),
    ] = None
    kind: Annotated[
        Optional[str],
        Field(description="Indicates the kind of resource the alarm is present on."),
    ] = None
    lastAcknowledged: Annotated[
        Optional[str], Field(description="the time this alarm was last acknowledged.")
    ] = None
    lastChanged: Annotated[
        Optional[str],
        Field(
            description="The last time that the alarm was changed; as provided by the raiser of the alarm."
        ),
    ] = None
    lastSuppressed: Annotated[
        Optional[str], Field(description="the time this alarm was last suppressed.")
    ] = None
    name: Annotated[
        Optional[str],
        Field(
            description="The unique name for the alarm, e.g. InterfaceDown-spine-1-1-ethernet-1-1."
        ),
    ] = None
    namespace: Annotated[
        Optional[str], Field(description="The namespace of the alarm")
    ] = None
    occurrences: Annotated[
        Optional[int],
        Field(
            description="The number of occurrences of this alarm (the number of times it has been raised)."
        ),
    ] = None
    parentAlarms: Annotated[
        Optional[List[str]],
        Field(
            description="The names of other alarms that are parents of this alarm. This may be used to\nfilter out alarms that are not a root cause."
        ),
    ] = None
    probableCause: Annotated[
        Optional[str],
        Field(
            description="the probable cause for raising the alarm. This field is optional, and\nshould also be a description indicating the primary probable cause of the\nalarm, which may be enriched with relevant information from this specific\nalarm instance. The complete alarm below contains an example."
        ),
    ] = None
    remedialAction: Annotated[
        Optional[str],
        Field(
            description="any remedial actions the user could try to resolve/clear the alarm. This\nfield is optional, and may also be enriched with relevant information\nfrom this specific alarm instance. The complete alarm below contains an\nexample."
        ),
    ] = None
    resource: Annotated[
        Optional[str],
        Field(description="The name of the resource that this alarm is present on."),
    ] = None
    severity: Annotated[
        Optional[Literal["warning", "minor", "major", "critical"]],
        Field(description="Severity of the alarm"),
    ] = None
    sourceGroup: Annotated[
        Optional[str],
        Field(
            description="Indicates indicates the group of the resource that raised this alarm, e.g. interfaces.eda.nokia.com."
        ),
    ] = None
    sourceKind: Annotated[
        Optional[str],
        Field(
            description="Indicates the Kind of the resource that raised this alarm, e.g. InterfaceState."
        ),
    ] = None
    sourceResource: Annotated[
        Optional[str],
        Field(
            description="Indicates the the name of the resource that raised this alarm, e.g. spine-1-1-ethernet-1-1."
        ),
    ] = None
    suppressed: Annotated[
        Optional[bool],
        Field(description="An indication if the alarm has been suppressed."),
    ] = None
    suppressedUntil: Annotated[
        Optional[str], Field(description="Indicates the end time of the suppression.")
    ] = None
    type: Annotated[
        Optional[str], Field(description="A kind for the alarm, e.g. InterfaceDown")
    ] = None


class AlarmHistoryData(BaseModel):
    alarm: Optional[AlarmData] = None
    index: Annotated[
        Optional[str],
        Field(
            description="The index of the history entry within the entries for a single alarm.."
        ),
    ] = None


class AlarmNamespaceAndName(BaseModel):
    name: Annotated[Optional[str], Field(description="The name of an alarm")] = None
    namespace: Annotated[
        Optional[str], Field(description="The namespace of an alarm")
    ] = None


class AuthPasswordPolicy(BaseModel):
    allowUserName: Annotated[
        Optional[bool],
        Field(
            description="If true, prevents passwords from being or containing the user name."
        ),
    ] = None
    digits: Annotated[
        Optional[int],
        Field(
            description="Minimum number of digits required in a password. Can be zero.",
            ge=0,
        ),
    ] = None
    forceExpiredPasswordChange: Annotated[
        Optional[int],
        Field(
            description="The maximum number of days until a password change is enforced.\nA value of zero means no change is required.",
            ge=0,
        ),
    ] = None
    hashingAlgorithm: Annotated[
        Optional[Literal["argon2", "pbkdf2-sha512", "pbkdf2-sha256", "pbkdf2"]],
        Field(
            description="The hashing algorithm to use when hashing stored passwords."
        ),
    ] = None
    length: Annotated[
        Optional[int],
        Field(description="Minimum password length.  This must be at least 1.", ge=1),
    ] = None
    lowerCase: Annotated[
        Optional[int],
        Field(
            description="Minimum number of lower case characters required in a password. Can be zero.",
            ge=0,
        ),
    ] = None
    maxFailureWaitSeconds: Annotated[
        Optional[int],
        Field(
            description="The number of seconds before the users access will be restored, after too many authentication failures.",
            ge=0,
        ),
    ] = None
    maxLoginFailure: Annotated[
        Optional[int],
        Field(
            description="The number of login/authentication failures before a lockout policy takes effect. Zero means no enforcement.",
            ge=0,
        ),
    ] = None
    passwordHistory: Annotated[
        Optional[int],
        Field(
            description="The number of passwords remembered to enforce no re-use of passwords. Zero means no re-use enforcement.",
            ge=0,
        ),
    ] = None
    permanentLockout: Annotated[
        Optional[bool],
        Field(
            description='If true, lockout is permanent and the users access must be re-enabled by an administrator.\nIf false, the users access will be re-enabled after "maxFailureWaitSeconds" seconds.'
        ),
    ] = None
    resetTimeSeconds: Annotated[
        Optional[int],
        Field(
            description="When lockout is not permanent, the count of authentication failures for a user will be reset\nthis many seconds after the last authentication failure.",
            ge=0,
        ),
    ] = None
    specialChars: Annotated[
        Optional[int],
        Field(
            description="Minimum number of special characters required in a password. Can be zero.",
            ge=0,
        ),
    ] = None
    upperCase: Annotated[
        Optional[int],
        Field(
            description="Minimum number of upper case characters required in a password. Can be zero.",
            ge=0,
        ),
    ] = None


class Credentials(BaseModel):
    temporary: Annotated[
        Optional[bool],
        Field(
            description="This is true if the password being set is a temporary password.  In this case the user\nis required to change the password after they login using the temporary password."
        ),
    ] = None
    value: Annotated[
        Optional[str], Field(description="The new password for the user.")
    ] = None


class ErrorIndex(BaseModel):
    index: Optional[int] = None


class ErrorItem(BaseModel):
    error: Optional[Dict[str, Any]] = None
    type: Optional[str] = None


class ErrorResponse(BaseModel):
    """
    Generic error response for REST APIs
    """

    code: Annotated[
        int, Field(description="the numeric HTTP error code for the response.")
    ]
    details: Annotated[
        Optional[str], Field(description="The optional details of the error response.")
    ] = None
    dictionary: Annotated[
        Optional[Dict[str, Any]],
        Field(
            description='Dictionary/map of associated data/information relevant to the error.\nThe error "message" may contain {{name}} escapes that should be substituted\nwith information from this dictionary.'
        ),
    ] = None
    domain: Annotated[
        Optional[str],
        Field(
            description='The "domain" for the error.  If empty, it is an EDA\ncore error.  Alternatively it can be an EDA application\n"apiVersion" value (e.g. interfaces.eda.nokia.com/v1alpha1)\nindicating that the error is specific to that application.\nThe domain gives the receiver information that they can use\nto help them interpret the "internal" error code value, or\nto find an internationalization translation for the message.'
        ),
    ] = None
    errors: Annotated[
        Optional[List[ErrorItem]],
        Field(
            description="Collection of errors in cases where more than one exists. This needs to be\nflexible so we can support multiple formats"
        ),
    ] = None
    index: Optional[ErrorIndex] = None
    internal: Annotated[
        Optional[int],
        Field(
            description="Internal error code in cases where we don't have an array of errors"
        ),
    ] = None
    message: Annotated[
        str, Field(description="The basic text error message for the error response.")
    ]
    ref: Annotated[
        Optional[str],
        Field(
            description="Reference to the error source. Should typically be the URI of the request"
        ),
    ] = None
    type: Annotated[
        Optional[str],
        Field(
            description="URI pointing at a document that describes the error and mitigation steps\nIf there is no document, point to the RFC for the HTTP error code"
        ),
    ] = None


class FlowListEntry(BaseModel):
    id: Annotated[Optional[int], Field(description="The id of the workflow")] = None
    name: Annotated[Optional[str], Field(description="Name of the workflow")] = None
    namespace: Annotated[
        Optional[str], Field(description="The namespace in which the workflow ran")
    ] = None
    parentId: Annotated[
        Optional[int], Field(description="The id of the parent workflow, if any")
    ] = None
    state: Optional[
        Literal[
            "waitingToStart",
            "running",
            "waitingForInput",
            "terminated",
            "failed",
            "completed",
            "subflowWaitingForInput",
        ]
    ] = None
    type: Annotated[Optional[str], Field(description="The type of workflow")] = None


class FlowListResult(BaseModel):
    """
    A list of flows
    """

    flows: Optional[List[FlowListEntry]] = None


class FlowStage(BaseModel):
    """
    Describes the stage of a workflow
    """

    completed: Annotated[
        Optional[bool], Field(description="True if the stage has completed")
    ] = None
    hadError: Annotated[
        Optional[bool],
        Field(description="True if the stage is complete and there was an error"),
    ] = None
    name: Annotated[Optional[str], Field(description="Name of the flow stage")] = None
    skipped: Annotated[
        Optional[bool], Field(description="True if the stage was skipped")
    ] = None
    started: Annotated[
        Optional[bool], Field(description="True if the stage has started")
    ] = None
    subFlowIds: Annotated[
        Optional[List[int]],
        Field(description="The ids of flows triggered by the stage"),
    ] = None


class GroupIDs(RootModel[List[str]]):
    root: Annotated[
        List[str], Field(title="A list of user group identifiers (uuid values).")
    ]


class GroupVersionKind(BaseModel):
    group: Annotated[Optional[str], Field(description="Name of the API group")] = None
    kind: Annotated[Optional[str], Field(description="The Kind of the resource")] = None
    version: Annotated[Optional[str], Field(description="Version of the API group")] = (
        None
    )


class GroupVersionResource(BaseModel):
    group: Annotated[Optional[str], Field(description="Name of the API group")] = None
    resource: Annotated[
        Optional[str], Field(description="The plural name of the resource")
    ] = None
    version: Annotated[Optional[str], Field(description="Version of the API group")] = (
        None
    )


class HealthServiceStatus(BaseModel):
    error: Annotated[
        Optional[str], Field(description="Detailed status if the service is not up.")
    ] = None
    status: Annotated[
        Literal["UP", "DOWN"],
        Field(description="Health status of the given service.  UP or DOWN."),
    ]


class Identifier(BaseModel):
    group: Optional[str] = None
    id: Optional[int] = None
    kind: Optional[str] = None
    name: Optional[str] = None
    namespace: Optional[str] = None
    version: Optional[str] = None


class K8SPatchOp(BaseModel):
    from_: Annotated[Optional[str], Field(alias="from")] = None
    op: str
    path: str
    value: Optional[Dict[str, Any]] = None
    x_permissive: Annotated[Optional[bool], Field(alias="x-permissive")] = None


class LabelCompletionResponse(BaseModel):
    results: Optional[List[str]] = None


class LineSegment(BaseModel):
    endLine: Optional[int] = None
    startLine: Optional[int] = None


class Metadata(BaseModel):
    annotations: Optional[Dict[str, str]] = None
    labels: Optional[Dict[str, str]] = None
    name: Annotated[
        str,
        Field(
            max_length=253,
            pattern="^[a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*$",
        ),
    ]
    namespace: Optional[str] = None


class NamespaceData(BaseModel):
    """
    Information about an individual namespace
    """

    description: Annotated[
        Optional[str], Field(description="The description of the namespace")
    ] = None
    name: Annotated[Optional[str], Field(description="The namespace name")] = None


class NamespaceGetResponse(BaseModel):
    """
    Body of the non streaming namespace get request
    """

    allNamesapces: Annotated[
        Optional[bool],
        Field(
            description="If true, the requestor is considered to have permission to access all namespaces"
        ),
    ] = None
    namespaces: Annotated[
        Optional[List[NamespaceData]], Field(description="The list of namespaces")
    ] = None


class NsCrGvkName(BaseModel):
    gvk: Optional[GroupVersionKind] = None
    name: Optional[str] = None
    namespace: Optional[str] = None


class ProviderAuth(BaseModel):
    bindCredential: Annotated[
        str, Field(description="Credentials to use when binding to an LDAP provider")
    ]
    bindDN: Annotated[
        str, Field(description="DN to use when binding to an LDAP provider")
    ]


class QueryCompletion(BaseModel):
    completion: Optional[str] = None
    token: Optional[str] = None


class QueryCompletionResponse(BaseModel):
    """
    The result of a successful query auto-completion request
    """

    completions: Annotated[
        Optional[List[QueryCompletion]],
        Field(description="Array of possible auto-completion results."),
    ] = None


class QueryFieldAnnotation(BaseModel):
    end_char: Optional[int] = None
    start_char: Optional[int] = None


class ResourceRule(BaseModel):
    apiGroups: Annotated[
        List[str],
        Field(
            description='The API groups for the resources controlled by the rule.\nAn API group consists of an apiGroup and a version, e.g. "apigroup/version".\nThe API group can be a wildcard ("*"), in which case it will match any API group.\nIn addition, the version can be a wildcard.'
        ),
    ]
    permissions: Annotated[
        Optional[Literal["none", "read", "readWrite"]],
        Field(description="Permissions for resources specified by the rule."),
    ] = None
    resources: Annotated[
        List[str],
        Field(
            description='Names for the resources controlled by the rule.\nIt can be a wildcard ("*"), in which case it will match any resource\nin the matching API groups.'
        ),
    ]


class StoreAppInstalledSettings(BaseModel):
    appId: Annotated[
        Optional[str], Field(description="The application identifier.")
    ] = None
    settings: Annotated[
        Optional[Dict[str, Dict[str, Any]]],
        Field(description="The settings for the application as a JSON object."),
    ] = None


class StoreAppVersion(BaseModel):
    """
    The information about an application version available from a catalog.
    At least one of "semVer" or "commitHash" must/will be defined.
    """

    appId: Annotated[
        Optional[str], Field(description="The identifier for the application")
    ] = None
    catalog: Annotated[
        Optional[str],
        Field(description="The catalog in which this application version was found"),
    ] = None
    commitHash: Annotated[
        Optional[str], Field(description="The commit hash for the application version.")
    ] = None
    semVer: Annotated[
        Optional[str],
        Field(description="The semantic version for the application version."),
    ] = None


class StoreAppVersionMetadata(BaseModel):
    publishedTime: Annotated[
        Optional[AwareDatetime],
        Field(
            description="The date and time when the application version was published."
        ),
    ] = None


class StoreAppVersionWithMetadata(BaseModel):
    metadata: Optional[StoreAppVersionMetadata] = None
    version: Optional[StoreAppVersion] = None


class StoreCategoryList(RootModel[List[str]]):
    root: List[str]


class TableRule(BaseModel):
    """
    A role rule controlling access to a EDB table.  Note that
    there is never write access to EDB.
    """

    path: Annotated[
        str,
        Field(
            description='EDB path to which this rule applies. It can end in ".*"\nin which case the final portion of the table path can be anything, if the\nprefix matches. It can end in ".**" in which case the table path can be\nanything if the prefix matches.',
            min_length=1,
            pattern="^\\\\..*",
        ),
    ]
    permissions: Annotated[
        Literal["none", "read"],
        Field(description="Permissions for the given EDB path."),
    ]


class TopoAttrMetadata(BaseModel):
    type: Optional[str] = None
    ui_description: Optional[str] = None
    ui_description_key: Optional[str] = None
    ui_name: Optional[str] = None
    ui_name_key: Optional[str] = None


class TopoLinkEndpoint(BaseModel):
    endpoint: Optional[str] = None
    node: Optional[str] = None
    node_key: Optional[str] = None


class TopoNodeGrouping(BaseModel):
    group: Optional[str] = None
    tier: Optional[int] = None


class TopoOverlayAttrMetadata(BaseModel):
    ui_description: Optional[str] = None
    ui_description_key: Optional[str] = None
    ui_name: Optional[str] = None
    ui_name_key: Optional[str] = None


class TopoOverlayAttrQuery(BaseModel):
    attributes: Optional[Dict[str, TopoOverlayAttrMetadata]] = None
    query: Optional[str] = None


class TopoOverlayBadgeMetadata(BaseModel):
    badge_name: Optional[str] = None
    badge_path: Optional[str] = None
    color: Optional[str] = None
    ui_description: Optional[str] = None
    ui_description_key: Optional[str] = None
    ui_name: Optional[str] = None
    ui_name_key: Optional[str] = None
    value: Optional[int] = None


class TopoOverlayEndpointState(BaseModel):
    state: Optional[int] = None


TopoOverlayLinkState = TopoOverlayEndpointState


class TopoOverlayNodeState(BaseModel):
    badges: Optional[List[int]] = None
    state: Optional[int] = None


class TopoOverlayStateMetadata(BaseModel):
    color: Optional[str] = None
    ui_description: Optional[str] = None
    ui_description_key: Optional[str] = None
    ui_name: Optional[str] = None
    ui_name_key: Optional[str] = None
    value: Optional[int] = None


class TopoSchema(BaseModel):
    group: Optional[str] = None
    kind: Optional[str] = None
    version: Optional[str] = None


class TopologyStateGroupSelector(BaseModel):
    group: Annotated[
        Optional[str],
        Field(
            description='The group to assign to nodes that match the selector.\n+eda:ui:title="Group"'
        ),
    ] = None
    nodeSelector: Annotated[
        Optional[List[str]],
        Field(
            description='+kubebuilder:validation:Optional\n+eda:ui:title="Node Selector"\n+eda:ui:format="labelselector"\nLabel selector to use to match nodes that should be assigned to this group.'
        ),
    ] = None


class TopologyStateTierSelector(BaseModel):
    nodeSelector: Annotated[
        Optional[List[str]],
        Field(
            description='+kubebuilder:validation:Optional\n+eda:ui:title="Node Selector"\n+eda:ui:format="labelselector"\nLabel selector to use to match nodes that should be assigned to this tier.'
        ),
    ] = None
    tier: Annotated[
        Optional[int],
        Field(
            description='The tier to assign to nodes that match the selector.\n+eda:ui:title="Tier"'
        ),
    ] = None


class TransactionContent(BaseModel):
    apiVersion: Optional[str] = None
    kind: Optional[str] = None
    metadata: Optional[Metadata] = None
    spec: Optional[Dict[str, Any]] = None


class TransactionId(BaseModel):
    id: Annotated[
        Optional[int],
        Field(
            description="A transaction identifier; these are assigned by the system to a posted transaction."
        ),
    ] = None


class TransactionInputResource(BaseModel):
    isDelete: Optional[bool] = None
    name: Optional[NsCrGvkName] = None


class TransactionNodeResult(BaseModel):
    """
    The name of a node with changes from a transaction, and a list
    of errors that occurred for the node
    """

    errors: Annotated[
        Optional[List[str]], Field(description="Resulting errors for the node")
    ] = None
    name: Annotated[Optional[str], Field(description="The name of the node")] = None
    namespace: Annotated[
        Optional[str], Field(description="The namespace of the node")
    ] = None


class TransactionNsCrGvkNames(BaseModel):
    gvk: Optional[GroupVersionKind] = None
    names: Optional[List[str]] = None
    namespace: Optional[str] = None


class TransactionPatch(BaseModel):
    patchOps: List[K8SPatchOp]
    target: NsCrGvkName


class TransactionResultInputResources(BaseModel):
    inputCrs: Annotated[
        Optional[List[TransactionInputResource]],
        Field(description="List of input resources from the transaction"),
    ] = None
    limitedAccess: Annotated[
        Optional[bool],
        Field(
            description="This field is true if the list returned here is not the complete list of input resources in the transaction because the user does not have read-access to some of them"
        ),
    ] = None


class TransactionResultObjectString(BaseModel):
    data: Optional[str] = None


class TransactionScriptResults(BaseModel):
    executionTime: Optional[int] = None


class TransactionState(BaseModel):
    state: Annotated[
        Optional[str], Field(description="The state of the transaction")
    ] = None


class TransactionStructuredAppError(BaseModel):
    message: Optional[str] = None
    messageKey: Optional[str] = None
    values: Optional[Dict[str, Dict[str, Any]]] = None


class TransactionSummaryResult(BaseModel):
    """
    Summary of the result of a transaction
    """

    commitHash: Annotated[
        Optional[str], Field(description="The git commit hash for the transaction")
    ] = None
    description: Annotated[
        Optional[str],
        Field(
            description="The description of the transaction, as posted in the transaction request."
        ),
    ] = None
    details: Annotated[
        Optional[str],
        Field(
            description="The type of details available for the transaction, as posted in the transaction request."
        ),
    ] = None
    dryRun: Annotated[
        Optional[bool],
        Field(
            description="If true the transaction was not committed and ran in dry run mode."
        ),
    ] = None
    id: Annotated[Optional[int], Field(description="The transaction identifier")] = None
    lastChangeTimestamp: Annotated[
        Optional[str], Field(description="The time that the transaction completed.")
    ] = None
    state: Annotated[
        Optional[str], Field(description="The state of the transaction.")
    ] = None
    success: Annotated[
        Optional[bool], Field(description="True if the transaction was successful.")
    ] = None
    username: Annotated[
        Optional[str], Field(description="The user who posted the transaction.")
    ] = None


class TransactionSummaryResults(BaseModel):
    results: Annotated[
        Optional[List[TransactionSummaryResult]],
        Field(description="array of summary-results for transactions"),
    ] = None


class TransactionValue(BaseModel):
    value: Optional[TransactionContent] = None


class UrlRule(BaseModel):
    path: Annotated[
        str,
        Field(
            description='The API server URL path to which this rule applies. It can end in "/*"\nin which case the final portion of the URL path can be anything, if the\nprefix matches. It can end in "/**" in which case the URL path can be\nanything if the prefix matches.",',
            min_length=1,
            pattern="^/.*",
        ),
    ]
    permissions: Annotated[
        Optional[Literal["none", "read", "readWrite"]],
        Field(description="The permissions for the API server URL for the rule."),
    ] = None


class UserStatus(BaseModel):
    failedLoginSinceSuccessfulLogin: Optional[int] = None
    isFederatedUser: Annotated[
        Optional[bool],
        Field(description="True if the user comes from a federated LDAP server"),
    ] = None
    lastFailedLogin: Optional[str] = None
    lastSuccessfulLogin: Optional[str] = None
    temporarilyDisabled: Optional[bool] = None


class UserStorageInFileContent(BaseModel):
    file_content: Annotated[
        str,
        Field(
            alias="file-content",
            description="The desired content of the user-storage file. This will be base64 decoded before storing if the request indicates that the content is base64 encoded.",
        ),
    ]


class UserStorageOutDirEntry(BaseModel):
    """
    user-storage directory entry
    """

    modification_time: Annotated[
        Optional[AwareDatetime],
        Field(
            alias="modification-time",
            description="modification type of the item, if a file",
        ),
    ] = None
    name: Annotated[str, Field(description="name of the item within the directory")]
    type: Annotated[str, Field(description='type of the item; "file" or "directory"')]


class UserStorageOutFileContent(BaseModel):
    file_content: Annotated[
        Optional[str],
        Field(
            alias="file-content",
            description="content of the file, will be base64 encoded if the request asked for this",
        ),
    ] = None
    file_deleted: Annotated[
        Optional[bool],
        Field(
            alias="file-deleted",
            description="if present and true, indicates the file has been deleted; used for\nstreamed responses",
        ),
    ] = None
    file_name: Annotated[str, Field(alias="file-name", description="name of the file")]
    modification_time: Annotated[
        Optional[AwareDatetime],
        Field(
            alias="modification-time",
            description="UTC modification time of the file, as an RFC 3339 date/time.\nNot valid if file-deleted is true (in a streamed response)",
        ),
    ] = None


class Workflow(BaseModel):
    cr: Annotated[
        Dict[str, Dict[str, Any]],
        Field(description="Custom resource that defines the workflow to execute"),
    ]
    description: Annotated[
        str, Field(description="Description message for the workflow")
    ]


class WorkflowId(BaseModel):
    id: Annotated[
        Optional[int],
        Field(
            description="A workflow identifier; these are assigned by the system to a posted workflow."
        ),
    ] = None


class WorkflowState(BaseModel):
    runningState: Optional[str] = None
    state: Optional[str] = None


class SingleVersionInfo(BaseModel):
    builtDate: Annotated[
        Optional[str], Field(description="The build-time for the component.")
    ] = None
    version: Annotated[
        Optional[str], Field(description="The version string for the component.")
    ] = None


class VersionInfo(RootModel[Optional[Dict[str, SingleVersionInfo]]]):
    root: Optional[Dict[str, SingleVersionInfo]] = None


class AuthProviderAuth(BaseModel):
    """
    If present, bind to LDAP server with the given credentials.  Otherwise do not bind.
    """

    bindCredential: Annotated[
        str, Field(description="Credentials to use when binding to an LDAP provider")
    ]
    bindDN: Annotated[
        str, Field(description="DN to use when binding to an LDAP provider")
    ]


class AuthProviderGroupSupport(BaseModel):
    """
    Configuration for group import/sync with LDAP.  If not present, groups will not synchronized with EDA.
    """

    NameLDAPAttribute: Annotated[
        str, Field(description="The LDAP group name attribute")
    ]
    filter: Annotated[
        Optional[str],
        Field(
            description="Further for filtering when retrieving LDAP groups. Ensure starts and ends with parentheses if using."
        ),
    ] = None
    groupLDAPDN: Annotated[
        str, Field(description="The LDAP DN where groups are found.")
    ]
    memberAttribute: Annotated[
        Optional[str],
        Field(
            description='The group attribute for a members.  Usually "member" or "memberUid".'
        ),
    ] = None
    memberOfAttribute: Annotated[
        Optional[str],
        Field(
            description='If retrievalStrategy is "memberOf", this is the LDAP user attribute for group memberships.'
        ),
    ] = None
    membershipAttributeType: Annotated[
        Optional[Literal["DN", "UID"]],
        Field(
            description="How users are identified in a group member entry: either DN or UID."
        ),
    ] = None
    membershipUserAttribute: Annotated[
        Optional[str],
        Field(
            description="Only required if membershipAttributeType is UID; then it is the user attribute that should match the group member value."
        ),
    ] = None
    objectClasses: Annotated[
        str,
        Field(
            description="The LDAP object class or classes used for groups. If more than one, they must be comma-separated."
        ),
    ]
    retrievalStrategy: Annotated[
        Optional[Literal["member", "memberOf"]],
        Field(
            description='The strategy for retrieving groups.  Should be "member" to get group membership from the group, or "memberOf" to get group membership from the user.'
        ),
    ] = None


class StoreAppRequirementsGraphItemInstalledAppVersion(BaseModel):
    """
    The application version installed in the cluster, if installed.
    """

    appId: Annotated[
        Optional[str], Field(description="The identifier for the application")
    ] = None
    catalog: Annotated[
        Optional[str],
        Field(description="The catalog in which this application version was found"),
    ] = None
    commitHash: Annotated[
        Optional[str], Field(description="The commit hash for the application version.")
    ] = None
    semVer: Annotated[
        Optional[str],
        Field(description="The semantic version for the application version."),
    ] = None


class StoreAppRequirementsGraphItemTargetAppVersion(BaseModel):
    """
    This graph item instance contains the dependencies for this particular application version.
    """

    appId: Annotated[
        Optional[str], Field(description="The identifier for the application")
    ] = None
    catalog: Annotated[
        Optional[str],
        Field(description="The catalog in which this application version was found"),
    ] = None
    commitHash: Annotated[
        Optional[str], Field(description="The commit hash for the application version.")
    ] = None
    semVer: Annotated[
        Optional[str],
        Field(description="The semantic version for the application version."),
    ] = None


class AccessQuery(BaseModel):
    gvk: Optional[GroupVersionKind] = None
    gvr: Optional[GroupVersionResource] = None
    namespace: Annotated[
        Optional[str],
        Field(
            description="The namespace to check. Empty string (or omit) to check for cluster-wide access"
        ),
    ] = None
    path: Annotated[
        Optional[str],
        Field(
            description="Target url or table of the access check. Provided when type is table or url"
        ),
    ] = None
    permissions: Annotated[
        Optional[Literal["read", "readWrite"]],
        Field(description="The permissions for the requested resource/url/table."),
    ] = None
    type: Annotated[
        Literal["gvk", "gvr", "url", "table"],
        Field(description="The type of rule to check for"),
    ]


class AccessResult(BaseModel):
    access: Annotated[
        Optional[bool],
        Field(description="Indicates if the user can access the requested resource"),
    ] = None
    error: Optional[ErrorResponse] = None


class AuthProvider(BaseModel):
    auth: Optional[AuthProviderAuth] = None
    enabled: Annotated[
        Optional[bool],
        Field(description="If true, checking/syncing this LDAP provider is enabled."),
    ] = None
    groupSupport: Optional[AuthProviderGroupSupport] = None
    idAttribute: Annotated[
        str,
        Field(
            description="Name of the LDAP attribute, which is used as a unique object identifier (UUID) for objects in LDAP."
        ),
    ]
    import_: Annotated[
        Optional[bool],
        Field(
            alias="import",
            description="If true, the LDAP information will be imported into the EDA (Keycloak) database.",
        ),
    ] = None
    name: Annotated[
        str, Field(description="The name to give to the LDAP provider; must be unique.")
    ]
    pagination: Annotated[
        Optional[bool],
        Field(description="Set to true if the LDAP server supports pagination."),
    ] = None
    periodicSync: Annotated[
        Optional[bool],
        Field(
            description="If true, periodic synchronization of new changed or newly created LDAP users to Keycloak will occur."
        ),
    ] = None
    periodicSyncSecs: Annotated[
        Optional[int],
        Field(
            description="If periodic sync is enabled, this is the period in seconds that synchronization will occur."
        ),
    ] = None
    rdnLDAPAttribute: Annotated[
        str,
        Field(
            description="Name of the LDAP attribute, which is used as RDN (top attribute) of typical user DN. Usually it's the same as the Username LDAP attribute, however it is not required."
        ),
    ]
    readOnly: Annotated[
        bool,
        Field(
            description="If false, changes made to LDAP-mapped attribute via EDA will be synced back to the LDAP server.  Otherwise, changes are not made in LDAP."
        ),
    ]
    scope: Annotated[
        Optional[Literal["One Level", "Subtree"]],
        Field(
            description='Must be "One Level" or "Subtree".  If "One Level", the search applies only for users in the DNs specified by User DNs. If "Subtree", the search applies to the whole subtree.'
        ),
    ] = None
    timeout: Annotated[
        Optional[int], Field(description="LDAP connection timeout in milliseconds")
    ] = None
    tls: Annotated[
        Optional[bool],
        Field(description="If true, encrypts the connection to LDAP using STARTTLS"),
    ] = None
    type: Annotated[
        Literal["ldap"],
        Field(description='The type of provider.  Currently only "ldap" is supported.'),
    ]
    url: Annotated[str, Field(description="Connection URL to your LDAP server")]
    userDN: Annotated[
        str,
        Field(
            description="Full DN of LDAP tree where your users are. This DN is the parent of LDAP users."
        ),
    ]
    userObjectClasses: Annotated[
        str,
        Field(
            description="All values of LDAP objectClass attribute for users in LDAP, divided by commas. (e.g. inetOrgPerson, organizationalPerson)."
        ),
    ]
    userSearchFilter: Annotated[
        Optional[str],
        Field(
            description="Additional LDAP filter for filtering searched users. Leave this empty if you don't need an additional filter. Make sure that it starts with '(' and ends with ')'."
        ),
    ] = None
    usernameAttribute: Annotated[
        str,
        Field(
            description="Name of the LDAP attribute, which is mapped as EDA username. For many LDAP server vendors it can be 'uid'."
        ),
    ]
    uuid: Annotated[
        Optional[str],
        Field(
            description="The unique identifier given to the entry when it is created."
        ),
    ] = None
    vendor: Annotated[str, Field(description="LDAP vendor (provider).")]


class AuthProviderTestParams(BaseModel):
    action: Annotated[
        Literal["connection", "authentication"],
        Field(description="The test action to take."),
    ]
    auth: Optional[ProviderAuth] = None
    name: Annotated[
        Optional[str], Field(description="The name of the provider to test")
    ] = None
    timeout: Annotated[
        Optional[int], Field(description="LDAP connection timeout in milliseconds")
    ] = None
    tls: Annotated[
        Optional[bool],
        Field(description="If true, encrypts the connection to LDAP using STARTTLS"),
    ] = None
    url: Annotated[str, Field(description="Connection URL to your LDAP server")]


class AuthProviders(RootModel[List[AuthProvider]]):
    root: List[AuthProvider]


class AuthRole(BaseModel):
    description: str
    name: Annotated[
        str,
        Field(
            pattern="^[a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*$"
        ),
    ]
    namespace: Annotated[
        Optional[str], Field(pattern="^([a-z0-9]([-a-z0-9]*[a-z0-9])?)?$")
    ] = None
    resourceRules: Annotated[
        Optional[List[ResourceRule]],
        Field(description="Rules for access to resources."),
    ] = None
    tableRules: Annotated[
        Optional[List[TableRule]],
        Field(description="Rules for access to EDB tables, including via EQL."),
    ] = None
    urlRules: Annotated[
        Optional[List[UrlRule]],
        Field(description="Rules for access to APIServer routes."),
    ] = None


class AuthRoles(RootModel[List[AuthRole]]):
    root: List[AuthRole]


class AuthUser(BaseModel):
    email: Optional[str] = None
    enabled: Optional[bool] = None
    firstName: Optional[str] = None
    groups: Annotated[
        Optional[List[str]],
        Field(
            description="contains the UUIDs of the groups of which the user is a member."
        ),
    ] = None
    lastName: Optional[str] = None
    maxSessions: Optional[int] = None
    password: Optional[str] = None
    status: Optional[UserStatus] = None
    username: Optional[str] = None
    uuid: Optional[str] = None


class AuthUserGroup(BaseModel):
    description: Optional[str] = None
    full_users: Annotated[
        Optional[List[AuthUser]],
        Field(
            alias="full-users",
            description="contains the full user definitions of the users who are members of the group, if requested",
        ),
    ] = None
    fullRoles: Annotated[
        Optional[List[AuthRole]],
        Field(
            description="contains the full role definitions of the Roles and ClusterRoles associated with the group, if requested"
        ),
    ] = None
    isFederated: Annotated[
        Optional[bool],
        Field(
            description="if true, indicates that the group was imported from a federated LDAP server"
        ),
    ] = None
    name: Optional[str] = None
    roles: Annotated[
        Optional[List[str]],
        Field(
            description='Contains the names of the ClusterRoles and Roles roles associated with the group.\nA Role name has the form "namesspace:rolename", whereas a ClusteRole name is a\nsimple "rolename", without a colon or a namespace.'
        ),
    ] = None
    users: Annotated[
        Optional[List[str]],
        Field(
            description="contains the usernames of the users who are members of the group"
        ),
    ] = None
    uuid: Optional[str] = None


class AuthUserGroups(RootModel[List[AuthUserGroup]]):
    root: List[AuthUserGroup]


class AuthUsers(RootModel[List[AuthUser]]):
    root: List[AuthUser]


class CheckAccessRequest(RootModel[Optional[Dict[str, AccessQuery]]]):
    """
    Body of a checkAccess request. Contains a key and AccessQuery for each resource/url/table to be checked for user access
    """

    root: Optional[Dict[str, AccessQuery]] = None


class CheckAccessResponse(RootModel[Optional[Dict[str, AccessResult]]]):
    """
    Body of a access check response. Contains an AccessResult for each of the keys provided in the request
    """

    root: Optional[Dict[str, AccessResult]] = None


class CrAnnotation(BaseModel):
    cr: Optional[NsCrGvkName] = None
    lines: Optional[List[LineSegment]] = None


class FlowGetResponse(BaseModel):
    error: Annotated[
        Optional[str],
        Field(description="If no error is present, the flow completed successfully"),
    ] = None
    id: Annotated[Optional[int], Field(description="The id of the workflow")] = None
    jsonResult: Annotated[
        Optional[str], Field(description="A JSON representation of the result")
    ] = None
    log: Annotated[Optional[str], Field(description="Log output from the flow")] = None
    name: Annotated[Optional[str], Field(description="Name of the workflow")] = None
    namespace: Annotated[
        Optional[str], Field(description="The namespace in which the flow ran")
    ] = None
    parentId: Annotated[
        Optional[int], Field(description="The id of the parent workflow, if any")
    ] = None
    stages: Annotated[
        Optional[List[FlowStage]],
        Field(description="The list of stages of the workflow"),
    ] = None
    state: Optional[
        Literal[
            "waitingToStart",
            "running",
            "waitingForInput",
            "terminated",
            "failed",
            "completed",
            "subflowWaitingForInput",
        ]
    ] = None
    subflowsWaitingForInput: Annotated[
        Optional[List[int]],
        Field(description="The ids of any subflows that are waiting for user input"),
    ] = None
    type: Annotated[Optional[str], Field(description="The type of workflow")] = None
    waitForInputPrompt: Annotated[
        Optional[str], Field(description="Set if the state is waiting for input")
    ] = None


class GetLabelCompletionRequest(BaseModel):
    gvk: Optional[GroupVersionKind] = None
    limit: Annotated[
        Optional[int], Field(description="The maximum number of results to return")
    ] = None
    namespace: Annotated[
        Optional[str],
        Field(
            description="The namespace of the GVK if the CRD is namespaced\nrequired: true if the GVK is namespaced"
        ),
    ] = None
    value: Annotated[
        str,
        Field(
            description="A key value string delimited by =.  If the Value does not include an =\nit is assumed to be a Key lookup.  If there is an =, everything before\nthe = is assumed to be the key and the lookup will be a value lookup"
        ),
    ]


class Health(BaseModel):
    mode: Annotated[
        Literal["ACTIVE", "STANDBY"],
        Field(description="Indication of the activity of this cluster."),
    ]
    services: Annotated[
        Optional[Dict[str, HealthServiceStatus]],
        Field(
            description="Detailed health of the services comprising the EDA cluster.  Keyed by the name of the service."
        ),
    ] = None
    status: Annotated[
        Literal["UP", "DEGRADED", "DOWN"],
        Field(description="Overall health status of the EDA cluster."),
    ]
    timestamp: Annotated[
        AwareDatetime, Field(description="Time that the health report was generated.")
    ]


class NodeConfigResponse(BaseModel):
    annotations: Annotated[
        Optional[List[CrAnnotation]],
        Field(description="The the list of annotations for the node configuration"),
    ] = None
    running: Annotated[
        Optional[str], Field(description="The current node configuration for the node")
    ] = None


class Overlay(BaseModel):
    endpoint_attr_queries: Optional[List[TopoOverlayAttrQuery]] = None
    endpoint_state: Optional[List[TopoOverlayStateMetadata]] = None
    endpoint_state_heading: Optional[str] = None
    endpoint_state_heading_key: Optional[str] = None
    group: Optional[str] = None
    link_attr_queries: Optional[List[TopoOverlayAttrQuery]] = None
    link_state: Optional[List[TopoOverlayStateMetadata]] = None
    link_state_heading: Optional[str] = None
    link_state_heading_key: Optional[str] = None
    name: Optional[str] = None
    node_attr_queries: Optional[List[TopoOverlayAttrQuery]] = None
    node_badge: Optional[List[TopoOverlayBadgeMetadata]] = None
    node_state: Optional[List[TopoOverlayStateMetadata]] = None
    node_state_heading: Optional[str] = None
    node_state_heading_key: Optional[str] = None
    ui_description: Optional[str] = None
    ui_description_key: Optional[str] = None
    ui_name: Optional[str] = None
    ui_name_key: Optional[str] = None
    version: Optional[str] = None


class Overlays(RootModel[List[Overlay]]):
    root: List[Overlay]


class QueryField(BaseModel):
    alias: Optional[bool] = None
    annotations: Optional[List[QueryFieldAnnotation]] = None
    display_name: Optional[str] = None
    name: Optional[str] = None
    type: Optional[str] = None


class QuerySchema(BaseModel):
    fields: Optional[List[QueryField]] = None


class StoreAppManifest(BaseModel):
    manifest: Annotated[
        Optional[Dict[str, Dict[str, Any]]],
        Field(description="The application manifest as JSON"),
    ] = None
    metadata: Optional[StoreAppVersionMetadata] = None
    version: Optional[StoreAppVersion] = None


class StoreAppRequirementsGraphItem(BaseModel):
    appId: Annotated[
        str,
        Field(
            description="The application identifier to which the 'requires' elements of graph items will refer."
        ),
    ]
    installedAppVersion: Optional[StoreAppRequirementsGraphItemInstalledAppVersion] = (
        None
    )
    requires: Annotated[
        Optional[List[str]],
        Field(
            description="The identifiers for the applications on which this application version depends."
        ),
    ] = None
    targetAppVersion: StoreAppRequirementsGraphItemTargetAppVersion


class StoreAppSummary(BaseModel):
    appId: Annotated[
        Optional[str], Field(description="Unique ID identifying this application")
    ] = None
    catalogs: Annotated[
        Optional[List[str]], Field(description="Catalogs where this app was found")
    ] = None
    categories: Annotated[
        Optional[List[str]], Field(description="Application categories.")
    ] = None
    description: Annotated[
        Optional[str],
        Field(
            description="Application description that can be used for user display purposes"
        ),
    ] = None
    infoVersion: Optional[StoreAppVersion] = None
    infoVersionMetadata: Optional[StoreAppVersionMetadata] = None
    installed: Annotated[
        Optional[bool], Field(description='"true" if the app is installed')
    ] = None
    installedVersion: Optional[StoreAppVersion] = None
    installedVersionMetadata: Optional[StoreAppVersionMetadata] = None
    latestVersion: Optional[StoreAppVersion] = None
    latestVersionMetadata: Optional[StoreAppVersionMetadata] = None
    supportedEndpoints: Annotated[
        Optional[List[str]], Field(description="Application supported endpoints.")
    ] = None
    title: Annotated[
        Optional[str],
        Field(
            description="Application title that can be used for user display purposes"
        ),
    ] = None
    upgradable: Annotated[
        Optional[bool],
        Field(description='"true" if there is a new version that can be installed'),
    ] = None


class StoreAppSummaryList(RootModel[List[StoreAppSummary]]):
    root: List[StoreAppSummary]


class StoreAppVersionList(RootModel[List[StoreAppVersionWithMetadata]]):
    root: List[StoreAppVersionWithMetadata]


class TopoElemMetadata(BaseModel):
    attributes: Optional[Dict[str, TopoAttrMetadata]] = None
    schema_: Annotated[Optional[TopoSchema], Field(alias="schema")] = None
    subtitle: Optional[str] = None
    subtitle_key: Optional[str] = None


class TopoOverlayEndpoint(BaseModel):
    attributes: Optional[Dict[str, Dict[str, Any]]] = None
    cr_name: Optional[str] = None
    labels: Optional[Dict[str, str]] = None
    name: Optional[str] = None
    namespace: Optional[str] = None
    overlays: Optional[Dict[str, TopoOverlayEndpointState]] = None
    schema_: Annotated[Optional[TopoSchema], Field(alias="schema")] = None
    state: Optional[int] = None
    ui_name: Optional[str] = None


class TopoOverlayLink(BaseModel):
    attributes: Optional[Dict[str, Dict[str, Any]]] = None
    cr_name: Optional[str] = None
    endpoint_a: Optional[TopoLinkEndpoint] = None
    endpoint_a_details: Optional[TopoOverlayEndpoint] = None
    endpoint_b: Optional[TopoLinkEndpoint] = None
    endpoint_b_details: Optional[TopoOverlayEndpoint] = None
    key: Optional[str] = None
    labels: Optional[Dict[str, str]] = None
    name: Optional[str] = None
    namespace: Optional[str] = None
    overlays: Optional[Dict[str, TopoOverlayLinkState]] = None
    schema_: Annotated[Optional[TopoSchema], Field(alias="schema")] = None
    state: Optional[int] = None
    ui_name: Optional[str] = None


class TopoOverlayNode(BaseModel):
    attributes: Optional[Dict[str, Dict[str, Any]]] = None
    badges: Optional[List[int]] = None
    cr_name: Optional[str] = None
    grouping: Optional[TopoNodeGrouping] = None
    key: Optional[str] = None
    labels: Optional[Dict[str, str]] = None
    name: Optional[str] = None
    namespace: Optional[str] = None
    overlays: Optional[Dict[str, TopoOverlayNodeState]] = None
    schema_: Annotated[Optional[TopoSchema], Field(alias="schema")] = None
    state: Optional[int] = None
    ui_name: Optional[str] = None


class Topology(BaseModel):
    endpoints: Optional[TopoElemMetadata] = None
    group: Optional[str] = None
    grouping: Optional[TopoSchema] = None
    links: Optional[TopoElemMetadata] = None
    name: Optional[str] = None
    nodes: Optional[TopoElemMetadata] = None
    ui_description: Optional[str] = None
    ui_description_key: Optional[str] = None
    ui_name: Optional[str] = None
    ui_name_key: Optional[str] = None
    version: Optional[str] = None


class TopologyStateGroupingBase(BaseModel):
    """
    Embed this type inside your topology tier CRD spec to determine the tiers and the
    groups of the nodes in the topology.
    """

    groupSelectors: Annotated[
        Optional[List[TopologyStateGroupSelector]],
        Field(
            description='The set of selectors for assigning nodes to groups\n+eda:ui:title="Group Selectors"'
        ),
    ] = None
    tierSelectors: Annotated[
        Optional[List[TopologyStateTierSelector]],
        Field(
            description='The set of selectors for assigning nodes to tiers\n+eda:ui:title="Tier Selectors"'
        ),
    ] = None
    uiDescription: Annotated[
        Optional[str],
        Field(
            description='A description of the topology grouping to expose in the UI\n+eda:ui:title="UI Description"'
        ),
    ] = None
    uiDescriptionKey: Annotated[
        Optional[str],
        Field(
            description='The translation key for the description of the topology grouping to expose in the UI\n+eda:ui:title="UI Description Key"'
        ),
    ] = None
    uiName: Annotated[
        Optional[str],
        Field(
            description='The name of the topology grouping to expose in the UI\n+eda:ui:title="UI Name"'
        ),
    ] = None
    uiNameKey: Annotated[
        Optional[str],
        Field(
            description='The translation key for the name of the topology grouping to expose in the UI\n+eda:ui:title="UI Name Key"'
        ),
    ] = None


class TransactionAppError(BaseModel):
    rawError: Optional[str] = None
    structuredError: Optional[TransactionStructuredAppError] = None


class TransactionIntentResult(BaseModel):
    errors: Optional[List[TransactionAppError]] = None
    intentName: Optional[NsCrGvkName] = None
    outputCrs: Optional[List[NsCrGvkName]] = None
    script: Optional[TransactionScriptResults] = None


class TransactionResultObject(BaseModel):
    after: Optional[TransactionResultObjectString] = None
    before: Optional[TransactionResultObjectString] = None
    dataUnavailable: Annotated[
        Optional[bool],
        Field(description="True if there is no data available for the result"),
    ] = None
    format: Annotated[
        Optional[str], Field(description="The format of the response - Text or YAML")
    ] = None


class TransactionType(BaseModel):
    create: Optional[TransactionValue] = None
    delete: Optional[NsCrGvkName] = None
    modify: Optional[TransactionValue] = None
    patch: Optional[TransactionPatch] = None
    replace: Optional[TransactionValue] = None


class UserStorageOutDirContent(BaseModel):
    directory_path: Annotated[
        str,
        Field(
            alias="directory-path",
            description="path for the directory within the users storage",
        ),
    ]
    entries: Annotated[
        List[UserStorageOutDirEntry],
        Field(description="array of entries for the items in the directory"),
    ]


class WorkflowResult(BaseModel):
    errorMessage: Optional[str] = None
    resultMessage: Optional[str] = None
    state: Optional[WorkflowState] = None
    success: Optional[bool] = None


class WorkflowStatusSummary(BaseModel):
    creationTime: Optional[str] = None
    group: Optional[str] = None
    id: Optional[int] = None
    kind: Optional[str] = None
    lastUpdate: Optional[str] = None
    name: Optional[str] = None
    namespace: Optional[str] = None
    parent: Optional[Identifier] = None
    rootWorkflow: Optional[Identifier] = None
    state: Optional[WorkflowResult] = None
    username: Optional[str] = None
    version: Optional[str] = None


class OverlayState(BaseModel):
    links: Optional[Dict[str, TopoOverlayLink]] = None
    nodes: Optional[Dict[str, TopoOverlayNode]] = None


class QueryResponse(BaseModel):
    """
    The response for a non-streaming query request
    """

    data: Optional[List[Dict[str, Any]]] = None
    jsonSchema: Annotated[
        Optional[Dict[str, Dict[str, Any]]],
        Field(
            description="The JSON schema definition for the query data being returned."
        ),
    ] = None
    schema_: Annotated[Optional[QuerySchema], Field(alias="schema")] = None


class StoreAppRequirementsGraph(BaseModel):
    graphItems: Annotated[
        Optional[List[StoreAppRequirementsGraphItem]],
        Field(
            description="The items in the requirements graph resulting from the request.  Only present if the state is FINISHED."
        ),
    ] = None
    state: Annotated[
        Optional[Literal["UNKNOWN", "RUNNING", "FINISHED", "FAILED"]],
        Field(description="The state of the requirements graph generation request."),
    ] = None


class TopoGroupingStateRequest(BaseModel):
    name: Optional[str] = None
    spec: Optional[TopologyStateGroupingBase] = None


class TopoStateRequest(BaseModel):
    grouping: Optional[TopoGroupingStateRequest] = None
    namespace: Optional[str] = None
    overlays: Optional[List[str]] = None


class Topologies(RootModel[List[Topology]]):
    root: List[Topology]


class TransactionCr(BaseModel):
    type: Optional[TransactionType] = None


class TransactionExecutionResult(BaseModel):
    changedCrs: Annotated[
        Optional[List[TransactionNsCrGvkNames]],
        Field(description="List of changed CRs as part of the transaction"),
    ] = None
    executionSummary: Annotated[
        Optional[str],
        Field(description="Information about time taken during processing"),
    ] = None
    generalErrors: Annotated[
        Optional[List[str]],
        Field(description="List of general errors while running the transaction"),
    ] = None
    intentsRun: Annotated[
        Optional[List[TransactionIntentResult]],
        Field(description="List of intents which ran as part of the transaction"),
    ] = None
    nodesWithConfigChanges: Annotated[
        Optional[List[TransactionNodeResult]],
        Field(
            description="List of nodes with configuration changes from the transaction"
        ),
    ] = None
    topologySupported: Annotated[
        Optional[bool],
        Field(
            description="Whether a topology representation of this transaction is supported"
        ),
    ] = None


class TransactionTopologyResult(BaseModel):
    overlayMetadata: Optional[Overlay] = None
    topology: Optional[OverlayState] = None
    topologyMetadata: Optional[Topology] = None


class Transaction(BaseModel):
    crs: Annotated[
        List[TransactionCr],
        Field(description="List of CRs to include in the transaction"),
    ]
    description: Annotated[
        str, Field(description="Description/commit message for the transaction")
    ]
    dryRun: Annotated[
        bool,
        Field(
            description="If true the transaction will not be committed and will run in dry run mode.  If false the\ntransaction will be committed"
        ),
    ]
    resultType: Annotated[
        Optional[str],
        Field(description="The type of result - errors only, normal, or debug"),
    ] = None
    retain: Annotated[
        Optional[bool],
        Field(
            description="retain after results fetched - e.g. after call to get transaction result"
        ),
    ] = None
