# generated by datamodel-codegen:
#   filename:  https://raw.githubusercontent.com/eda-labs/openapi/v24.12.1/apps/core.eda.nokia.com/v1/core.json
#   timestamp: 2025-01-29T15:18:38+00:00

from __future__ import annotations

from datetime import date
from typing import Any, Dict, List, Literal, Optional

from pydantic import BaseModel, Field, RootModel, SecretStr
from typing_extensions import Annotated

from ..... import Metadata


class ApiGroup(RootModel[str]):
    root: Annotated[str, Field(min_length=1)]


class Resource(RootModel[str]):
    root: Annotated[str, Field(min_length=1)]


class ResourceRule(BaseModel):
    apiGroups: Annotated[
        List[ApiGroup],
        Field(
            description='The API groups for the resources controlled by the rule.\nAn API group consists of an apiGroup and a version, e.g. "apigroup/version".\nThe API group can be a wildcard ("*"), in which case it will match any API group.',
            min_length=1,
            title='API Groups',
        ),
    ]
    permissions: Annotated[
        Literal['none', 'read', 'readWrite'],
        Field(
            description='Permissions for resources specified by the rule.',
            title='Permissions',
        ),
    ]
    resources: Annotated[
        List[Resource],
        Field(
            description='Names for the resources controlled by the rule.\nIt can be a wildcard ("*"), in which case it will match any resource\nin the matching API groups.',
            min_length=1,
            title='Resources',
        ),
    ]


class TableRule(BaseModel):
    path: Annotated[
        str,
        Field(
            description='EDB path to which this rule applies. It can end in ".*"\nin which case the final portion of the table path can be anything, if the\nprefix matches. It can end in ".**" in which case the table path can be\nanything if the prefix matches.',
            min_length=1,
            pattern='^\\..*',
            title='Path',
        ),
    ]
    permissions: Annotated[
        Literal['none', 'read'],
        Field(description='Permissions for the given EDB path.', title='Permissions'),
    ]


class UrlRule(BaseModel):
    path: Annotated[
        str,
        Field(
            description='The API server URL path to which this rule applies. It can end in "/*"\nin which case the final portion of the URL path can be anything, if the\nprefix matches. It can end in "/**" in which case the URL path can be\nanything if the prefix matches.',
            min_length=1,
            pattern='^/.*',
            title='Path',
        ),
    ]
    permissions: Annotated[
        Literal['none', 'read', 'readWrite'],
        Field(
            description='The permissions for the API server URL for the rule.',
            title='Permissions',
        ),
    ]


class Spec(BaseModel):
    description: Annotated[
        Optional[str],
        Field(description='A description for the role.', title='Description'),
    ] = None
    resourceRules: Annotated[
        Optional[List[ResourceRule]],
        Field(description='Rules for access to resources.', title='Resource Rules'),
    ] = None
    tableRules: Annotated[
        Optional[List[TableRule]],
        Field(
            description='Rules for access to EDB tables, including via EQL.',
            title='Table Rules',
        ),
    ] = None
    urlRules: Annotated[
        Optional[List[UrlRule]],
        Field(
            description='Rules for access to APIServer proxied routes.',
            title='URL Rules',
        ),
    ] = None


class ClusterRole(BaseModel):
    apiVersion: str
    kind: str
    metadata: Metadata
    spec: Annotated[
        Spec,
        Field(
            description='ClusterRole defines a set of permissions to access EDA resources.\nClusterRoles and users are bound via groups, selecting a set of users and a set of ClusterRoles to bind.',
            title='Specification',
        ),
    ]
    status: Annotated[
        Optional[Dict[str, Any]],
        Field(
            description='RoleStatus defines the observed state of Role', title='Status'
        ),
    ] = None


class ClusterRoleList(BaseModel):
    apiVersion: str
    items: Optional[List[ClusterRole]] = None
    kind: str


class AssociatedCr(BaseModel):
    groupVersion: Annotated[
        str,
        Field(
            description='Group and version of the resource.', title='Group + Version'
        ),
    ]
    kind: Annotated[str, Field(description='Kind of the resource.', title='Kind')]
    name: Annotated[str, Field(description='Name of the resource.', title='Name')]


class SpecModel(BaseModel):
    accepted: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether this Deviation has been accepted.',
            title='Accepted',
        ),
    ] = None
    associatedCrs: Annotated[
        Optional[List[AssociatedCr]],
        Field(
            description='Resources impacted by this Deviation.',
            title='Associated Resources',
        ),
    ] = None
    intendedValues: Annotated[
        Optional[str],
        Field(
            description='JSON object containing intended values of fields at the specified path.',
            title='Intended Values',
        ),
    ] = None
    nodeEndpoint: Annotated[
        str,
        Field(description='Target on which this Deviation is present.', title='Target'),
    ]
    operation: Annotated[
        Literal['create', 'delete'],
        Field(
            description='Indicates the operation in this Deviation.', title='Operation'
        ),
    ]
    path: Annotated[
        str,
        Field(
            description='Path on the target this Deviation is present at. This path is relative to the target\'s root, without any EDA prefixes - for example ".system" rather than ".namespace.node.srl.system".',
            title='Path',
        ),
    ]
    runningValues: Annotated[
        Optional[str],
        Field(
            description='JSON object containing running values of fields at the specified path.',
            title='Running Values',
        ),
    ] = None


class Deviation(BaseModel):
    apiVersion: str
    kind: str
    metadata: Metadata
    spec: Annotated[
        SpecModel,
        Field(
            description='Deviations are used to represent differences between the intended and actual state of a target.\nThey indicate the intended state - or the computed configuration EDA expects, and compare this to the actual or running state, or the configuration retrieved from the target.\nDeviations are most often generated by out-of-band changes to a target by an external system or user, and\ncan be accepted or rejected. Rejecting a Deviation will result in the intended configuration being re-applied, undoing the out-of-band change.\nDeviations are raised per table, meaning a single change on a target may result in more than one Deviation.',
            title='Specification',
        ),
    ]
    status: Annotated[
        Optional[Dict[str, Any]],
        Field(
            description='DeviationStatus defines the observed state of Deviation',
            title='Status',
        ),
    ] = None


class Action(BaseModel):
    action: Annotated[
        Literal['setAccept', 'clearAccept', 'reject'],
        Field(description='Action to perform on matching Deviations.', title='Action'),
    ]
    path: Annotated[
        str,
        Field(
            description='Path to match Deviation resources on this target. Only one action is allowed per path.',
            title='Path',
        ),
    ]
    recurse: Annotated[
        Optional[bool],
        Field(
            description='Recursively accept/reject Deviations from the specified path.',
            title='Recurse',
        ),
    ] = None


class SpecModel1(BaseModel):
    actions: Annotated[
        List[Action],
        Field(
            description='The set of actions to perform on the target.', title='Actions'
        ),
    ]
    nodeEndpoint: Annotated[
        str,
        Field(
            description='The target on which this action is to be performed.',
            title='Target',
        ),
    ]


class Status(BaseModel):
    result: Annotated[
        Optional[Literal['OK', 'Failed']],
        Field(description='The result of the set of actions.', title='Result'),
    ] = None
    transactionId: Annotated[
        Optional[int],
        Field(
            description='The transaction id these actions were part of.',
            title='Transaction Id',
        ),
    ] = None


class DeviationAction(BaseModel):
    apiVersion: str
    kind: str
    metadata: Metadata
    spec: Annotated[
        SpecModel1,
        Field(
            description='DeviationAction allows manual and API-driven actions to be performed on Deviation resources.\nThey are the only means to which and end user can accept or reject deviations, as Deviation resources themselves are read only.',
            title='Specification',
        ),
    ]
    status: Annotated[
        Optional[Status],
        Field(
            description='DeviationActionStatus defines the observed state of DeviationAction',
            title='Status',
        ),
    ] = None


class DeviationActionList(BaseModel):
    apiVersion: str
    items: Optional[List[DeviationAction]] = None
    kind: str


class DeviationList(BaseModel):
    apiVersion: str
    items: Optional[List[Deviation]] = None
    kind: str


class GatewayIPV4Address(BaseModel):
    ipPrefix: Annotated[
        str, Field(description='Address and mask to use', title='IP Prefix')
    ]
    primary: Annotated[
        Optional[bool],
        Field(
            description='Indicates which address to use as primary for broadcast',
            title='Primary',
        ),
    ] = None


class GatewayIPV6Address(BaseModel):
    ipPrefix: Annotated[
        str, Field(description='Address and mask to use', title='IP Prefix')
    ]
    primary: Annotated[
        Optional[bool],
        Field(
            description='Indicates which address to use as primary for broadcast',
            title='Primary',
        ),
    ] = None


class SpecModel2(BaseModel):
    bridgeDomain: Annotated[
        Optional[str],
        Field(description='Reference to a Bridge Domain', title='bridgeDomain'),
    ] = None
    encapType: Annotated[
        Literal['null', 'dot1q'],
        Field(
            description='Indicates if the EdgeInterface uses VLAN tagging',
            title='Encapsulation',
        ),
    ]
    gatewayIPV4Addresses: Annotated[
        Optional[List[GatewayIPV4Address]],
        Field(
            description='List of gateway IPv4 addresses in ip/mask form - e.g. 192.168.0.1/24',
            title='Gateway IPv4 Addresses',
        ),
    ] = None
    gatewayIPV6Addresses: Annotated[
        Optional[List[GatewayIPV6Address]],
        Field(
            description='List of gateway IPv6 addresses in ip/mask form - e.g. fc00::1/120',
            title='Gateway IPv6 Addresses',
        ),
    ] = None
    interfaceResource: Annotated[
        str, Field(description='Reference to an interface', title='Interface Resource')
    ]
    router: Annotated[
        Optional[str], Field(description='Reference to a Router', title='Router')
    ] = None
    vlanID: Annotated[
        Optional[int],
        Field(
            description='Single value between 0-4094 supported',
            ge=0,
            le=4094,
            title='VLAN ID',
        ),
    ] = None


class EdgeInterface(BaseModel):
    apiVersion: str
    kind: str
    metadata: Metadata
    spec: Annotated[
        SpecModel2,
        Field(
            description='EdgeInterfaceSpec defines the desired state of EdgeInterface',
            title='Specification',
        ),
    ]
    status: Annotated[
        Optional[Dict[str, Any]],
        Field(
            description='EdgeInterfaceStatus defines the observed state of EdgeInterface',
            title='Status',
        ),
    ] = None


class EdgeInterfaceList(BaseModel):
    apiVersion: str
    items: Optional[List[EdgeInterface]] = None
    kind: str


class SpecModel3(BaseModel):
    authType: Annotated[
        Literal['atDestination', 'inApiServer'],
        Field(
            description='Determines where authentication happens.\nIf "atDestination", then no authentication happens in API server and any auth tokens are forwarded as is.\nIf "inApiServer", then authentication happens within the API server and auth tokens are stripped prior to forwarding.',
            title='Authentication Type',
        ),
    ]
    rootUrl: Annotated[
        str,
        Field(
            description='The proxy destination, including the protocol.', title='Git'
        ),
    ]


class HttpProxy(BaseModel):
    apiVersion: str
    kind: str
    metadata: Metadata
    spec: Annotated[
        SpecModel3,
        Field(
            description='HttpProxySpec defines the desired state of HttpProxy',
            title='Specification',
        ),
    ]
    status: Annotated[
        Optional[Dict[str, Any]],
        Field(
            description='HttpProxyStatus defines the observed state of HttpProxy',
            title='Status',
        ),
    ] = None


class HttpProxyList(BaseModel):
    apiVersion: str
    items: Optional[List[HttpProxy]] = None
    kind: str


class Allocation(BaseModel):
    name: Annotated[str, Field(description='Name of this allocation.', title='Name')]
    value: Annotated[str, Field(description='Allocation to reserve.', title='Value')]


class Reservation(BaseModel):
    end: Annotated[str, Field(description='Value to reserve to.', title='End')]
    start: Annotated[str, Field(description='Value to start reserving.', title='Start')]


class Segment(BaseModel):
    allocations: Annotated[
        Optional[List[Allocation]],
        Field(
            description='List of reservations to exclude from allocations from this segment.',
            title='Allocations',
        ),
    ] = None
    reservations: Annotated[
        Optional[List[Reservation]],
        Field(
            description='List of ranges to exclude from allocations from this segment.',
            title='Reservations',
        ),
    ] = None
    subnet: Annotated[
        str, Field(description='IPv4 or IPv6 subnet, e.g. 10.1.1.0/24.', title='Subnet')
    ]


class SpecModel4(BaseModel):
    segments: Annotated[
        Optional[List[Segment]],
        Field(
            description='List of segments containing IPv4 or IPv6 addresses to allocate.',
            min_length=1,
            title='Segments',
        ),
    ] = None


class IPAllocationPool(BaseModel):
    apiVersion: str
    kind: str
    metadata: Metadata
    spec: Annotated[
        SpecModel4,
        Field(
            description='IPAllocationPool is a generic IP allocation pool supporting allocation of IPv4 and/or IPv6 addresses from a set of segments.\nIt is different from IPInSubnetAllocationPool in that it returns a single unzoned IP address, i.e. an IP address without a subnet. For example a 10.1.1.0/24 segment could return 10.1.1.1.\nConsult application documentation to know which pool type to use for a given use case.',
            title='Specification',
        ),
    ]
    status: Annotated[
        Optional[Dict[str, Any]],
        Field(
            description='IPAllocationPoolStatus defines the observed state of IPAllocationPool',
            title='Status',
        ),
    ] = None


class IPAllocationPoolList(BaseModel):
    apiVersion: str
    items: Optional[List[IPAllocationPool]] = None
    kind: str


class IPInSubnetAllocationPool(BaseModel):
    apiVersion: str
    kind: str
    metadata: Metadata
    spec: Annotated[
        SpecModel4,
        Field(
            description='IPInSubnetAllocationPool is a generic IP allocation pool supporting allocation of IPv4 and/or IPv6 addresses from a set of segments.\nIt is different from IPAllocationPool in that it returns a single zoned IP address, i.e. an IP address with a subnet. For example a 10.1.1.0/24 segment could return 10.1.1.1/24.\nConsult application documentation to know which pool type to use for a given use case.',
            title='Specification',
        ),
    ]
    status: Annotated[
        Optional[Dict[str, Any]],
        Field(
            description='IPInSubnetAllocationPoolStatus defines the observed state of IPInSubnetAllocationPool',
            title='Status',
        ),
    ] = None


class IPInSubnetAllocationPoolList(BaseModel):
    apiVersion: str
    items: Optional[List[IPInSubnetAllocationPool]] = None
    kind: str


class AllocationModel(BaseModel):
    name: Annotated[str, Field(description='Name of this allocation.', title='Name')]
    value: Annotated[int, Field(description='Index to reserve.', title='Value')]


class ReservationModel(BaseModel):
    end: Annotated[int, Field(description='Value to reserve to.', title='End')]
    start: Annotated[int, Field(description='Value to start reserving.', title='Start')]


class SegmentModel(BaseModel):
    allocations: Annotated[
        Optional[List[AllocationModel]],
        Field(
            description='List of reservations to exclude from allocations from this segment.',
            title='Allocations',
        ),
    ] = None
    reservations: Annotated[
        Optional[List[ReservationModel]],
        Field(
            description='Range of reservations to exclude from allocations from this segment.',
            title='Reservations',
        ),
    ] = None
    size: Annotated[
        int, Field(description='Number of elements in the segment.', title='Size')
    ]
    start: Annotated[
        int, Field(description='Starting value of the segment.', title='Start')
    ]


class SpecModel5(BaseModel):
    segments: Annotated[
        List[SegmentModel],
        Field(
            description='List of segments containing indexes to allocate.',
            min_length=1,
            title='Segments',
        ),
    ]


class IndexAllocationPool(BaseModel):
    apiVersion: str
    kind: str
    metadata: Metadata
    spec: Annotated[
        SpecModel5,
        Field(
            description='IndexAllocationPool is a generic allocation pool supporting allocation of indexes from a set of segments.\nIt supports allocating things like VLANs, subinterface indexes, autonomous system numbers, or any other integer-based index.',
            title='Specification',
        ),
    ]
    status: Annotated[
        Optional[Dict[str, Any]],
        Field(
            description='IndexAllocationPoolStatus defines the observed state of IndexAllocationPool',
            title='Status',
        ),
    ] = None


class IndexAllocationPoolList(BaseModel):
    apiVersion: str
    items: Optional[List[IndexAllocationPool]] = None
    kind: str


class SpecModel6(BaseModel):
    data: Annotated[
        str,
        Field(
            description='The license key. This is a base64 encoded string.',
            title='Data',
        ),
    ]
    enabled: Annotated[
        Optional[bool],
        Field(
            description='Indicates if this license is available for use.',
            title='Enabled',
        ),
    ] = True


class Status1Model(BaseModel):
    comment: Annotated[
        Optional[str],
        Field(description='Any comment provided in the license.', title='Comment'),
    ] = None
    expirationDate: Annotated[
        Optional[date],
        Field(
            description='Date and time the license expires.', title='Expiration Date'
        ),
    ] = None
    expired: Annotated[
        bool,
        Field(description='Indicates if the license has expired.', title='Expired'),
    ]
    issuedDate: Annotated[
        Optional[date],
        Field(description='Date and time the license was issued.', title='Issued Date'),
    ] = None
    used: Annotated[
        bool, Field(description='Indicates if license has been used.', title='Used')
    ]
    valid: Annotated[
        bool, Field(description='Indicates if the license is valid.', title='Valid')
    ]


class License(BaseModel):
    apiVersion: str
    kind: str
    metadata: Metadata
    spec: Annotated[
        SpecModel6,
        Field(
            description='A License represents an application license providing functionality within EDA. A license providing the "base" feature must be provided/valid for transactions to be processed.',
            title='Specification',
        ),
    ]
    status: Annotated[
        Optional[Status1Model],
        Field(description='Status information for this license.', title='Status'),
    ] = None


class LicenseList(BaseModel):
    apiVersion: str
    items: Optional[List[License]] = None
    kind: str


class SpecModel7(BaseModel):
    description: Annotated[
        Optional[str],
        Field(
            description='An optional description of the use of the namespace.',
            title='Description',
        ),
    ] = None


class Namespace(BaseModel):
    apiVersion: str
    kind: str
    metadata: Metadata
    spec: Annotated[
        SpecModel7,
        Field(
            description='A Namespace is a logical partition within the cluster that provides a mechanism for isolating resources.\nNamespaces allow for resource segmentation, enabling multiple teams or applications to share the same cluster without conflict.',
            title='Specification',
        ),
    ]
    status: Annotated[
        Optional[Dict[str, Any]],
        Field(
            description='NamespaceStatus defines the observed state of Namespace',
            title='Status',
        ),
    ] = None


class NamespaceList(BaseModel):
    apiVersion: str
    items: Optional[List[Namespace]] = None
    kind: str


class Dhcp4Option(BaseModel):
    option: Annotated[
        Literal[
            '1-SubnetMask',
            '2-TimeOffset',
            '3-Router',
            '4-TimeServer',
            '5-NameServer',
            '6-DomainNameServer',
            '7-LogServer',
            '8-QuoteServer',
            '9-LPRServer',
            '10-ImpressServer',
            '11-ResourceLocationServer',
            '12-HostName',
            '13-BootFileSize',
            '14-MeritDumpFile',
            '15-DomainName',
            '16-SwapServer',
            '17-RootPath',
            '18-ExtensionsPath',
            '19-IPForwarding',
            '20-NonLocalSourceRouting',
            '21-PolicyFilter',
            '22-MaximumDatagramAssemblySize',
            '23-DefaultIPTTL',
            '24-PathMTUAgingTimeout',
            '25-PathMTUPlateauTable',
            '26-InterfaceMTU',
            '27-AllSubnetsAreLocal',
            '28-BroadcastAddress',
            '29-PerformMaskDiscovery',
            '30-MaskSupplier',
            '31-PerformRouterDiscovery',
            '32-RouterSolicitationAddress',
            '33-StaticRoutingTable',
            '34-TrailerEncapsulation',
            '35-ArpCacheTimeout',
            '36-EthernetEncapsulation',
            '37-DefaulTCPTTL',
            '38-TCPKeepaliveInterval',
            '39-TCPKeepaliveGarbage',
            '40-NetworkInformationServiceDomain',
            '41-NetworkInformationServers',
            '42-NTPServers',
            '43-VendorSpecificInformation',
            '44-NetBIOSOverTCPIPNameServer',
            '45-NetBIOSOverTCPIPDatagramDistributionServer',
            '46-NetBIOSOverTCPIPNodeType',
            '47-NetBIOSOverTCPIPScope',
            '48-XWindowSystemFontServer',
            '49-XWindowSystemDisplayManager',
            '50-RequestedIPAddress',
            '51-IPAddressLeaseTime',
            '52-OptionOverload',
            '53-DHCPMessageType',
            '54-ServerIdentifier',
            '55-ParameterRequestList',
            '56-Message',
            '57-MaximumDHCPMessageSize',
            '58-RenewTimeValue',
            '59-RebindingTimeValue',
            '60-ClassIdentifier',
            '61-ClientIdentifier',
            '62-NetWareIPDomainName',
            '63-NetWareIPInformation',
            '64-NetworkInformationServicePlusDomain',
            '65-NetworkInformationServicePlusServers',
            '66-TFTPServerName',
            '67-BootfileName',
            '68-MobileIPHomeAgent',
            '69-SimpleMailTransportProtocolServer',
            '70-PostOfficeProtocolServer',
            '71-NetworkNewsTransportProtocolServer',
            '72-DefaultWorldWideWebServer',
            '73-DefaultFingerServer',
            '74-DefaultInternetRelayChatServer',
            '75-StreetTalkServer',
            '76-StreetTalkDirectoryAssistanceServer',
            '77-UserClassInformation',
            '78-SLPDirectoryAgent',
            '79-SLPServiceScope',
            '80-RapidCommit',
            '81-FQDN',
            '82-RelayAgentInformation',
            '83-InternetStorageNameService',
            '85-NDSServers',
            '86-NDSTreeName',
            '87-NDSContext',
            '88-BCMCSControllerDomainNameList',
            '89-BCMCSControllerIPv4AddressList',
            '90-Authentication',
            '91-ClientLastTransactionTime',
            '92-AssociatedIP',
            '93-ClientSystemArchitectureType',
            '94-ClientNetworkInterfaceIdentifier',
            '95-LDAP',
            '97-ClientMachineIdentifier',
            '98-OpenGroupUserAuthentication',
            '99-GeoConfCivic',
            '100-IEEE10031TZString',
            '101-ReferenceToTZDatabase',
            '112-NetInfoParentServerAddress',
            '113-NetInfoParentServerTag',
            '114-URL',
            '116-AutoConfigure',
            '117-NameServiceSearch',
            '118-SubnetSelection',
            '119-DNSDomainSearchList',
            '120-SIPServers',
            '121-ClasslessStaticRoute',
            '122-CCC',
            '123-GeoConf',
            '124-VendorIdentifyingVendorClass',
            '125-VendorIdentifyingVendorSpecific',
            '128-TFTPServerIPAddress',
            '129-CallServerIPAddress',
            '130-DiscriminationString',
            '131-RemoteStatisticsServerIPAddress',
            '132-8021PVLANID',
            '133-8021QL2Priority',
            '134-DiffservCodePoint',
            '135-HTTPProxyForPhoneSpecificApplications',
            '136-PANAAuthenticationAgent',
            '137-LoSTServer',
            '138-CAPWAPAccessControllerAddresses',
            '139-OPTIONIPv4AddressMoS',
            '140-OPTIONIPv4FQDNMoS',
            '141-SIPUAConfigurationServiceDomains',
            '142-OPTIONIPv4AddressANDSF',
            '143-OPTIONIPv6AddressANDSF',
            '150-TFTPServerAddress',
            '151-StatusCode',
            '152-BaseTime',
            '153-StartTimeOfState',
            '154-QueryStartTime',
            '155-QueryEndTime',
            '156-DHCPState',
            '157-DataSource',
            '175-Etherboot',
            '176-IPTelephone',
            '177-EtherbootPacketCableAndCableHome',
            '208-PXELinuxMagicString',
            '209-PXELinuxConfigFile',
            '210-PXELinuxPathPrefix',
            '211-PXELinuxRebootTime',
            '212-OPTION6RD',
            '213-OPTIONv4AccessDomain',
            '220-SubnetAllocation',
            '221-VirtualSubnetAllocation',
            '224-Reserved',
            '225-Reserved',
            '226-Reserved',
            '227-Reserved',
            '228-Reserved',
            '229-Reserved',
            '230-Reserved',
            '231-Reserved',
            '232-Reserved',
            '233-Reserved',
            '234-Reserved',
            '235-Reserved',
            '236-Reserved',
            '237-Reserved',
            '238-Reserved',
            '239-Reserved',
            '240-Reserved',
            '241-Reserved',
            '242-Reserved',
            '243-Reserved',
            '244-Reserved',
            '245-Reserved',
            '246-Reserved',
            '247-Reserved',
            '248-Reserved',
            '249-Reserved',
            '250-Reserved',
            '251-Reserved',
            '252-Reserved',
            '253-Reserved',
            '254-Reserved',
            '255-End',
        ],
        Field(description='DHCPv4 option to return to the TopoNode.', title='Option'),
    ]
    value: Annotated[
        List[str],
        Field(
            description='Value to return to the TopoNode for the specified option.',
            min_length=1,
            title='Value',
        ),
    ]


class Dhcp6Option(BaseModel):
    option: Annotated[
        Literal['59-BootfileUrl'],
        Field(description='DHCPv6 option to return to the TopoNode.', title='Option'),
    ]
    value: Annotated[
        List[str],
        Field(
            description='Value to return to the TopoNode for the specified option.',
            min_length=1,
            title='Value',
        ),
    ]


class Dhcp(BaseModel):
    dhcp4Options: Annotated[
        Optional[List[Dhcp4Option]],
        Field(
            description='DHCPv4 options to return to TopoNodes referencing this NodeProfile.',
            title='DHCPv4 Options',
        ),
    ] = None
    dhcp6Options: Annotated[
        Optional[List[Dhcp6Option]],
        Field(
            description='DHCPv6 options to return to TopoNodes referencing this NodeProfile.',
            title='DHCPv6 Options',
        ),
    ] = None
    managementPoolv4: Annotated[
        Optional[str],
        Field(
            description='IPInSubnetAllocationPool to use for IPv4 allocations of the management address for TopoNodes referencing this NodeProfile.',
            title='Management Pool - IPv4',
        ),
    ] = None
    managementPoolv6: Annotated[
        Optional[str],
        Field(
            description='IPInSubnetAllocationPool to use for IPv6 allocations of the management address for TopoNodes referencing this NodeProfile.',
            title='Management Pool - IPv6',
        ),
    ] = None
    preferredAddressFamily: Annotated[
        Optional[Literal['IPv4', 'IPv6']],
        Field(
            description='Preferred IP address family', title='Preferred Address Family'
        ),
    ] = None


class Image(BaseModel):
    image: Annotated[
        str,
        Field(
            description='URL hosting the software image, e.g. srlimages/srlinux-24.7.1.bin.',
            title='Image',
        ),
    ]
    imageMd5: Annotated[
        Optional[str],
        Field(
            description='URL hosting the software image md5 hash. e.g. srlimages/srlinux-24.7.1.bin.md5.',
            title='Image MD5',
        ),
    ] = None


class SpecModel8(BaseModel):
    annotate: Annotated[
        Optional[bool],
        Field(
            description='Indicates if NPP should annotate sent configuration.',
            title='Annotations',
        ),
    ] = False
    containerImage: Annotated[
        Optional[str],
        Field(
            description='Container image to use when simulating TopoNodes referencing this NodeProfile, e.g. ghcr.io/nokia/srlinux:24.7.1.',
            title='Container Image',
        ),
    ] = None
    dhcp: Annotated[
        Optional[Dhcp],
        Field(
            description='DHCP options to use when onboarding the TopoNode. Optional if not bootstrapping using EDA.',
            title='DHCP',
        ),
    ] = None
    imagePullSecret: Annotated[
        Optional[str],
        Field(
            description='Secret used to authenticate to the container registry where the container image is hosted.',
            title='Image Pull Secret',
        ),
    ] = None
    images: Annotated[
        Optional[List[Image]],
        Field(
            description='URLs hosting software images for bootstrapping TopoNodes referencing this NodeProfile.',
            title='Images',
        ),
    ] = None
    license: Annotated[
        Optional[str],
        Field(
            description='ConfigMap containing a license for TopoNodes referencing this NodeProfile.',
            title='License',
        ),
    ] = None
    nodeUser: Annotated[
        str,
        Field(
            description='Reference to a NodeUser to use for authentication to TopoNodes referencing this NodeProfile.',
            title='Node User',
        ),
    ]
    onboardingPassword: Annotated[
        Optional[SecretStr],
        Field(
            description='The password to use when onboarding TopoNodes referencing this NodeProfile, e.g. admin.',
            title='Onboarding Password',
        ),
    ] = None
    onboardingUsername: Annotated[
        Optional[str],
        Field(
            description='The username to use when onboarding TopoNodes referencing this NodeProfile, e.g. admin.',
            title='Onboarding Username',
        ),
    ] = None
    operatingSystem: Annotated[
        Literal['srl', 'sros'],
        Field(
            description='Sets the operating system of this NodeProfile, e.g. srl.',
            title='Operating System',
        ),
    ]
    platformPath: Annotated[
        Optional[str],
        Field(
            description='JSPath to use for retrieving the version string from TopoNodes referencing this NodeProfile, e.g. .platform.chassis.type.',
            title='Platform Path',
        ),
    ] = None
    port: Annotated[
        Optional[int],
        Field(
            description='Port used to establish a connection to the TopoNode, e.g. 57400.',
            ge=1,
            le=65535,
            title='Port',
        ),
    ] = 57400
    serialNumberPath: Annotated[
        Optional[str],
        Field(
            description='JSPath to use for retrieving the serial number string from TopoNodes referencing this NodeProfile, e.g. .platform.chassis.serial-number.',
            title='Serial Number Path',
        ),
    ] = None
    version: Annotated[
        str,
        Field(
            description='Sets the software version of this NodeProfile, e.g. 24.7.1 (for srl), or 24.7.r1 (for sros).',
            title='Version',
        ),
    ]
    versionMatch: Annotated[
        Optional[str],
        Field(
            description='Regular expression to match the node-retrieved version string to TopoNode version, e.g. v0\\.0\\.0.*.',
            title='Version Match',
        ),
    ] = None
    versionPath: Annotated[
        Optional[str],
        Field(
            description='JSPath to use for retrieving the version string from TopoNodes referencing this NodeProfile, e.g. .system.information.version.',
            title='Version Path',
        ),
    ] = None
    yang: Annotated[
        str,
        Field(
            description='URL containing YANG modules and schema profile to use when interacting with TopoNodes referencing this NodeProfile, e.g. http://eda-asvr/schemaprofiles/srlinux-24.7.1.zip.',
            title='YANG',
        ),
    ]


class NodeProfile(BaseModel):
    apiVersion: str
    kind: str
    metadata: Metadata
    spec: Annotated[
        SpecModel8,
        Field(
            description='NodeProfileSpec defines the desired state of NodeProfile',
            title='Specification',
        ),
    ]
    status: Annotated[Optional[Dict[str, Any]], Field(title='Status')] = None


class NodeProfileList(BaseModel):
    apiVersion: str
    items: Optional[List[NodeProfile]] = None
    kind: str


class GroupBinding(BaseModel):
    groups: Annotated[
        List[str], Field(description='Assigned groups for this user.', title='Groups')
    ]
    nodeSelector: Annotated[
        Optional[List[str]],
        Field(
            description='Selector to use when selecting TopoNodes to deploy this user to.',
            title='Node Selector',
        ),
    ] = None
    nodes: Annotated[
        Optional[List[str]],
        Field(description=' TopoNodes to deploy this user to.', title='Nodes'),
    ] = None


class SpecModel9(BaseModel):
    groupBindings: Annotated[
        List[GroupBinding],
        Field(
            description='Matching of this user to node-specific permissions via groups.',
            title='Group Bindings',
        ),
    ]
    password: Annotated[
        SecretStr, Field(description='Password for this user.', title='Password')
    ]
    sshPublicKeys: Annotated[
        Optional[List[str]],
        Field(
            description='SSH public keys to deploy for the user.',
            title='SSH Public Keys',
        ),
    ] = None
    username: Annotated[
        Optional[str],
        Field(
            description='Name of this user. If not provided, the name of the resource will be used.',
            max_length=32,
            title='Username',
        ),
    ] = None


class GroupBindingModel(BaseModel):
    groups: Annotated[
        Optional[List[str]],
        Field(
            description='Groups this user is a member of on this node.', title='Groups'
        ),
    ] = None
    node: Annotated[
        Optional[str], Field(description='Node this user is deployed to.', title='Node')
    ] = None


class Status1Model1(BaseModel):
    groupBindings: Annotated[
        Optional[List[GroupBindingModel]],
        Field(
            description='List of TopoNodes user has been deployed to, along with corresponding groups.',
            title='Group Bindings',
        ),
    ] = None


class NodeUser(BaseModel):
    apiVersion: str
    kind: str
    metadata: Metadata
    spec: Annotated[
        SpecModel9,
        Field(
            description="The NodeUser resource represents a user that can be deployed to a set of TopoNodes. It supports managing the user's password, SSH keys, and group bindings.\nAdditionally a NodeUser is referenced by a NodeProfile to indicate how NPP should connect to TopoNodes.",
            title='Specification',
        ),
    ]
    status: Annotated[
        Optional[Status1Model1],
        Field(description='Deployment status of this NodeUser.', title='Status'),
    ] = None


class NodeUserList(BaseModel):
    apiVersion: str
    items: Optional[List[NodeUser]] = None
    kind: str


class SpecModel10(BaseModel):
    description: Annotated[
        Optional[str],
        Field(description='A description for the role.', title='Description'),
    ] = None
    resourceRules: Annotated[
        Optional[List[ResourceRule]],
        Field(
            description='The rules for access to kubernetes resources',
            title='Resource Rules',
        ),
    ] = None
    tableRules: Annotated[
        Optional[List[TableRule]],
        Field(
            description='The rules for access to the database tables.',
            title='Table Rules',
        ),
    ] = None
    urlRules: Annotated[
        Optional[List[UrlRule]],
        Field(
            description='The rules for access to api-server proxied routes.',
            title='URL Rules',
        ),
    ] = None


class Role(BaseModel):
    apiVersion: str
    kind: str
    metadata: Metadata
    spec: Annotated[
        SpecModel10,
        Field(
            description='RoleSpec defines the desired state of Role',
            title='Specification',
        ),
    ]
    status: Annotated[
        Optional[Dict[str, Any]],
        Field(
            description='RoleStatus defines the observed state of Role', title='Status'
        ),
    ] = None


class RoleList(BaseModel):
    apiVersion: str
    items: Optional[List[Role]] = None
    kind: str


class AllocationModel1(BaseModel):
    name: Annotated[str, Field(description='Name of this allocation.', title='Name')]
    value: Annotated[str, Field(description='Allocation to reserve.', title='Value')]


class ReservationModel1(BaseModel):
    end: Annotated[str, Field(description='Value to reserve to.', title='End')]
    start: Annotated[str, Field(description='Value to start reserving.', title='Start')]


class SegmentModel1(BaseModel):
    allocations: Annotated[
        Optional[List[AllocationModel1]],
        Field(
            description='List of reservations to exclude from allocations from this segment.',
            title='Allocations',
        ),
    ] = None
    reservations: Annotated[
        Optional[List[ReservationModel1]],
        Field(
            description='List of ranges to exclude from allocations from this segment.',
            title='Reservations',
        ),
    ] = None
    subnet: Annotated[
        str,
        Field(
            description='IPv4 or IPv6 subnet to allocate subnets from, e.g. 10.1.0.0/16.',
            title='Subnet',
        ),
    ]
    subnetLength: Annotated[
        int,
        Field(
            description='The size of the subnets to be allocated from within the parent subnet, e.g. 29 (which could allocate 10.1.0.8/29, for example).',
            title='Subnet Length',
        ),
    ]


class SpecModel11(BaseModel):
    segments: Annotated[
        Optional[List[SegmentModel1]],
        Field(
            description='List of segments containing subnets to allocate.',
            min_length=1,
            title='Segments',
        ),
    ] = None


class SubnetAllocationPool(BaseModel):
    apiVersion: str
    kind: str
    metadata: Metadata
    spec: Annotated[
        SpecModel11,
        Field(
            description='SubnetAllocationPool is a generic subnet allocation pool supporting allocation of IPv4 and/or IPv6 child subnets from a list of parent subnet segments.\nIt allocates a subnet of the configured length from the provided parent subnet.\nFor example a pool could return 10.1.0.8/29 when a segment is defined as subnet 10.1.0.0/16 with subnet length 29.\nConsult application documentation to know which pool type to use for a given use case.',
            title='Specification',
        ),
    ]
    status: Annotated[
        Optional[Dict[str, Any]],
        Field(
            description='SubnetAllocationPoolStatus defines the observed state of SubnetAllocationPool',
            title='Status',
        ),
    ] = None


class SubnetAllocationPoolList(BaseModel):
    apiVersion: str
    items: Optional[List[SubnetAllocationPool]] = None
    kind: str


class SpecModel12(BaseModel):
    channels: Annotated[
        int,
        Field(
            description='The number of breakout channels to create',
            ge=1,
            le=8,
            title='Number of Channels',
        ),
    ]
    interface: Annotated[
        Optional[List[str]],
        Field(
            description='A list of normalized parent interface/port',
            title='Nomalized Parent Interface',
        ),
    ] = None
    node: Annotated[
        List[str],
        Field(
            description='Reference to a list of TopoNodes where the parent interfaces are to be broken out',
            title='Node',
        ),
    ]
    speed: Annotated[
        Literal['800G', '400G', '200G', '100G', '50G', '40G', '25G', '10G'],
        Field(description='The speed of each breakout channel', title='Speed'),
    ]


class TopoBreakout(BaseModel):
    apiVersion: str
    kind: str
    metadata: Metadata
    spec: Annotated[
        SpecModel12,
        Field(
            description='TopoBreakoutSpec defines the desired state of TopoBreakout',
            title='Specification',
        ),
    ]
    status: Annotated[
        Optional[Dict[str, Any]],
        Field(
            description='TopoBreakoutStatus defines the observed state of TopoBreakout',
            title='Status',
        ),
    ] = None


class TopoBreakoutList(BaseModel):
    apiVersion: str
    items: Optional[List[TopoBreakout]] = None
    kind: str


class Local(BaseModel):
    interface: Annotated[
        Optional[str],
        Field(
            description='Normalized name of the interface/port, e.g. ethernet-1-1.',
            title='Interface',
        ),
    ] = None
    interfaceResource: Annotated[
        str, Field(description='Reference to a Interface.', title='Interface Resource')
    ]
    node: Annotated[str, Field(description='Reference to a TopoNode.', title='Node')]


class Remote(BaseModel):
    interface: Annotated[
        Optional[str],
        Field(
            description='Normalized name of the interface/port, e.g. ethernet-1-1.',
            title='Interface',
        ),
    ] = None
    interfaceResource: Annotated[
        str, Field(description='Reference to a Interface.', title='Interface Resource')
    ]
    node: Annotated[str, Field(description='Reference to a TopoNode.', title='Node')]


class Link(BaseModel):
    local: Annotated[
        Local, Field(description='Local, or "A" endpoint of the link.', title='A')
    ]
    remote: Annotated[
        Optional[Remote],
        Field(description='Remote, or "B" endpoint of the link.', title='B'),
    ] = None
    speed: Annotated[
        Optional[
            Literal[
                '800G',
                '400G',
                '200G',
                '100G',
                '50G',
                '40G',
                '25G',
                '10G',
                '2.5G',
                '1G',
                '100M',
            ]
        ],
        Field(description='Speed of the link.', title='Speed'),
    ] = None
    type: Annotated[
        Literal['edge', 'interSwitch', 'loopback'],
        Field(
            description='Specify the type of link.\nIf type is set to edge, topology information for the remote device can be set; when doing so the Remote Node can be set as the hostname of the remote device and Remote Interface as the remote interface name in the device specific format, e.g. eth0.',
            title='Type',
        ),
    ]


class SpecModel13(BaseModel):
    links: Annotated[
        List[Link],
        Field(
            description='Define the set of physical links making up this TopoLink.',
            min_length=1,
            title='Links',
        ),
    ]


class Member(BaseModel):
    interface: Annotated[
        Optional[str], Field(description='Reference to an Interface', title='Interface')
    ] = None
    node: Annotated[str, Field(description='Reference to a TopoNode', title='Node')]
    operationalState: Annotated[
        str,
        Field(
            description='Indicates the operational state of the TopoLink member.',
            title='Operational State',
        ),
    ]


class Status1Model2(BaseModel):
    members: Annotated[
        Optional[List[Member]],
        Field(description='List of members present on the TopoLink.', title='Members'),
    ] = None
    operationalState: Annotated[
        str,
        Field(
            description='Indicates the aggregate operational state of the TopoLink.',
            title='Operational State',
        ),
    ]


class TopoLink(BaseModel):
    apiVersion: str
    kind: str
    metadata: Metadata
    spec: Annotated[
        SpecModel13,
        Field(
            description='TopoLink represents a logical link between two TopoNodes. It may include more than one physical link, being used to represent a LAG or multihomed link.\nTo create a point to point link with a single interface on both sides use a single link property.\nTo create a point to point link with a LAG configured on both side, use two links with matching nodes.\nA multihomed LAG is created by using two or more links where the A side and/or B side can be different.\nCreating a link with only A specified will create an edge interface.',
            title='Specification',
        ),
    ]
    status: Annotated[
        Optional[Status1Model2],
        Field(
            description='TopoLinkStatus defines the observed state of TopoLink',
            title='Status',
        ),
    ] = None


class TopoLinkList(BaseModel):
    apiVersion: str
    items: Optional[List[TopoLink]] = None
    kind: str


class ComponentItem(BaseModel):
    kind: Annotated[
        Literal['lineCard', 'fabric', 'mda', 'connector'],
        Field(description='The kind of Component, e.g. lineCard.', title='Kind'),
    ]
    slot: Annotated[
        Optional[str],
        Field(
            description='The slot this Component resides in, unset for Components that do not have a slot or ID.\ne.g. 1 would denote the linecard slot 1, 1/1 would denote linecard slot 1 mda slot 1.',
            title='Slot',
        ),
    ] = None
    type: Annotated[
        str,
        Field(
            description='Denotes the type of hardware being provisioned, e.g. xcm-x20.',
            title='Type',
        ),
    ]


class Npp(BaseModel):
    mode: Annotated[
        Optional[Literal['normal', 'maintenance', 'null', 'emulate']],
        Field(
            description='The mode in which this TopoNode is functioning.\n"normal" (the default)\n   indicates that NPP is expecting an endpoint to exist, and will accept and confirm changes only if the endpoint\n   accepts them.\n"maintenance"\n   indicates that no changes will be accepted for the TopoNode, irrespective if the endpoint is up and reachable.\n   The exception is if an upgrade is occuring, in which case changes will be accepted.\n"null"\n\t  indicates that changes will be accepted from CRs and no NPP will be spun up. NPP validation will not occur.\n   This may be useful in playground mode to avoid spinning up of 1000s of NPPs.\n"emulate"\n   indicates that changes will be accepted at the NPP level, without pushing them to a endpoint. NPP validation\n   still occurs.  If no IP address is present, we also run in emulate mode.',
            title='Mode',
        ),
    ] = 'normal'


class ProductionAddress(BaseModel):
    ipv4: Annotated[
        Optional[str], Field(description='The IPv4 production address', title='IPv4')
    ] = None
    ipv6: Annotated[
        Optional[str], Field(description='The IPv6 production address', title='IPv6')
    ] = None


class SpecModel14(BaseModel):
    component: Annotated[
        Optional[List[ComponentItem]],
        Field(
            description='List of components within the TopoNode.\nUsed to define the type and location of linecards, fabrics (SFM), media adapter cards (MDA) and control cards (CPM).',
            title='Components',
        ),
    ] = None
    license: Annotated[
        Optional[str],
        Field(
            description='Reference to a ConfigMap containing a license for the TopoNode. Overrides the license set in the referenced NodeProfile, if present.',
            title='License',
        ),
    ] = None
    macAddress: Annotated[
        Optional[str],
        Field(
            description='MAC address to associate with this TopoNode.\nTypically the chassis MAC address, optionally sent by a node in DHCP requests.\nNot required when a TopoNode is not being bootstrapped by EDA, or is simulated through CX.',
            title='MAC Address',
        ),
    ] = None
    nodeProfile: Annotated[
        str,
        Field(
            description='Reference to a NodeProfile to use with this TopoNode.',
            title='Node Profile',
        ),
    ]
    npp: Annotated[
        Optional[Npp],
        Field(
            description='Options relating to NPP interactions with the node.',
            title='NPP',
        ),
    ] = None
    onBoarded: Annotated[
        Optional[bool],
        Field(
            description='Indicates if this TopoNode has been bootstrapped or is reachable via configured credentials. Set by BootstrapServer when it completes onboarding functions for a given TopoNode.\nMost applications ignore TopoNodes that have not been onboarded yet.',
            title='Onboarded',
        ),
    ] = False
    operatingSystem: Annotated[
        Literal['srl', 'sros'],
        Field(
            description='Operating system running on this TopoNode, e.g. srl.',
            title='Operating System',
        ),
    ]
    platform: Annotated[
        str,
        Field(
            description='Platform type of this TopoNode, e.g. 7220 IXR-D3L.',
            title='Platform',
        ),
    ]
    productionAddress: Annotated[
        Optional[ProductionAddress],
        Field(
            description='Production address of this TopoNode - this is the address the real, production instance of this TopoNode uses.\nIf left blank, an address will be allocated from the management IP pool specified in the referenced NodeProfile.\nIf this TopoNode is not bootstrapped by EDA this field must be provided.',
            title='Production Address',
        ),
    ] = None
    serialNumber: Annotated[
        Optional[str],
        Field(
            description='Serial number of this TopoNode, optionally sent by a node in DHCP requests.\nNot required when a TopoNode is not being bootstrapped by EDA, or is simulated through CX.',
            title='Serial Number',
        ),
    ] = None
    systemInterface: Annotated[
        Optional[str],
        Field(
            description='Name of the Interface resource representing the primary loopback on the TopoNode.',
            title='System Interface',
        ),
    ] = None
    version: Annotated[
        str,
        Field(
            description='Sets the software version of this TopoNode, e.g. 24.7.1 (for srl), or 24.7.r1 (for sros).',
            title='Version',
        ),
    ]


class Status1Model3(BaseModel):
    node_details: Annotated[
        Optional[str],
        Field(
            alias='node-details',
            description='Address and port used to connected to the node.',
            title='Node Address',
        ),
    ] = None
    node_state: Annotated[
        Optional[str],
        Field(
            alias='node-state',
            description='The current state of the connection between NPP and the node.',
            title='Node',
        ),
    ] = None
    npp_details: Annotated[
        Optional[str],
        Field(
            alias='npp-details',
            description='NPP address and port for this TopoNode.',
            title='NPP Address',
        ),
    ] = None
    npp_state: Annotated[
        Optional[str],
        Field(
            alias='npp-state',
            description='The current state of the connection between ConfigEngine and NPP.',
            title='NPP',
        ),
    ] = None
    operatingSystem: Annotated[
        Optional[str],
        Field(
            description='Operational operating system running on this TopoNode, e.g. srl, sros.',
            title='Operating System',
        ),
    ] = None
    platform: Annotated[
        Optional[str],
        Field(
            description='Operational platform type of this TopoNode, e.g. 7220 IXR-D3L.',
            title='Platform',
        ),
    ] = None
    simulate: Annotated[
        Optional[bool],
        Field(
            description='Simulate using CX - if true CX is reponsible for generating the TargetNode resource.',
            title='Simulate',
        ),
    ] = None
    version: Annotated[
        Optional[str],
        Field(
            description='Operational software version of this TopoNode, e.g. 24.7.1 (for srl), or 24.7.r1 (for sros).',
            title='Version',
        ),
    ] = None


class TopoNode(BaseModel):
    apiVersion: str
    kind: str
    metadata: Metadata
    spec: Annotated[
        SpecModel14,
        Field(
            description='A managed network element is represented via a TopoNode resource, describing characteristics of a specific element in the topology.',
            title='Specification',
        ),
    ]
    status: Annotated[
        Optional[Status1Model3],
        Field(
            description='TopoNodeStatus defines the observed state of TopoNode',
            title='Status',
        ),
    ] = None


class TopoNodeList(BaseModel):
    apiVersion: str
    items: Optional[List[TopoNode]] = None
    kind: str


class SpecModel15(BaseModel):
    bufferSize: Annotated[
        int,
        Field(
            description='The proxy will use a buffer of this size for all datagrams it receives and this must be sized\nto accommodate the largest datagrams expected',
            ge=64,
            le=65535,
            title='Buffer Size',
        ),
    ]
    destHost: Annotated[
        str,
        Field(
            description='The destination hostname or IP address to forward the datagrams to',
            title='Destination Host',
        ),
    ]
    destPort: Annotated[
        int,
        Field(
            description='The destination UDP port to forward the datagrams to',
            ge=1,
            le=65535,
            title='Destination Port',
        ),
    ]
    idleTimeout: Annotated[
        int,
        Field(
            description='The proxy will listen for responses from the destination and forward it back to the source\nof the datagram until there is no traffic at all for at least the idle timeout in seconds',
            ge=1,
            title='Idle Timeout',
        ),
    ]
    proxyPort: Annotated[
        int,
        Field(
            description='The UDP port on which to listen for datagrams and then proxy to the destination',
            ge=1,
            le=65535,
            title='Proxy Port',
        ),
    ]


class UdpProxy(BaseModel):
    apiVersion: str
    kind: str
    metadata: Metadata
    spec: Annotated[
        SpecModel15,
        Field(
            description='UdpProxySpec defines the desired state of UdpProxy',
            title='Specification',
        ),
    ]
    status: Annotated[
        Optional[Dict[str, Any]],
        Field(
            description='UdpProxyStatus defines the observed state of UdpProxy',
            title='Status',
        ),
    ] = None


class UdpProxyList(BaseModel):
    apiVersion: str
    items: Optional[List[UdpProxy]] = None
    kind: str


class FlowDefinitionSchema(BaseModel):
    jsonSchemaSpec: Annotated[
        Optional[str],
        Field(
            description='A string containing the JSON schema the workflow accepts as input.',
            title='JSON Schema (Spec)',
        ),
    ] = None
    jsonSchemaStatus: Annotated[
        Optional[str],
        Field(
            description='A string containing the JSON schema the workflow will populate as output.',
            title='JSON Schema (Status)',
        ),
    ] = None


class SpecModel16(BaseModel):
    flowDefinitionSchema: Annotated[
        Optional[FlowDefinitionSchema],
        Field(
            description='the schema for the flow, can only be set if Resource is not set'
        ),
    ] = None
    image: Annotated[
        str,
        Field(
            description='Container image containing the flow. For example "ghcr.io/nokia-eda/apps/operatingsystem:v1.0.0".',
            title='Image',
        ),
    ]
    imagePullSecrets: Annotated[
        Optional[List[str]],
        Field(
            description='Secrets to use to pull the image for this workflow.',
            title='Image Pull Secrets',
        ),
    ] = None


class WorkflowDefinition(BaseModel):
    apiVersion: str
    kind: str
    metadata: Metadata
    spec: Annotated[
        SpecModel16,
        Field(
            description='WorkflowDefinitionSpec defines the desired state of FlowDefinition',
            title='Specification',
        ),
    ]
    status: Annotated[
        Optional[Dict[str, Any]],
        Field(
            description='WorkflowDefinitionStatus defines the observed state of FlowDefinition',
            title='Status',
        ),
    ] = None


class WorkflowDefinitionList(BaseModel):
    apiVersion: str
    items: Optional[List[WorkflowDefinition]] = None
    kind: str
