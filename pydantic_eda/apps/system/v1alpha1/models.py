# generated by datamodel-codegen:
#   filename:  system.json

from __future__ import annotations

from typing import Annotated, Any, Dict, List, Optional

from pydantic import AwareDatetime, BaseModel, Field, RootModel


class AppGroupVersion(BaseModel):
    groupVersion: Optional[str] = None
    version: Optional[str] = None


class ErrorIndex(BaseModel):
    index: Optional[int] = None


class ErrorItem(BaseModel):
    error: Optional[Dict[str, Any]] = None
    type: Optional[str] = None


class ErrorResponse(BaseModel):
    """
    Generic error response for REST APIs
    """

    code: Annotated[
        int, Field(description="the numeric HTTP error code for the response.")
    ]
    details: Annotated[
        Optional[str], Field(description="The optional details of the error response.")
    ] = None
    dictionary: Annotated[
        Optional[Dict[str, Any]],
        Field(
            description='Dictionary/map of associated data/information relevant to the error.\nThe error "message" may contain {{name}} escapes that should be substituted\nwith information from this dictionary.'
        ),
    ] = None
    domain: Annotated[
        Optional[str],
        Field(
            description='The "domain" for the error.  If empty, it is an EDA\ncore error.  Alternatively it can be an EDA application\n"apiVersion" value (e.g. interfaces.eda.nokia.com/v1alpha1)\nindicating that the error is specific to that application.\nThe domain gives the receiver information that they can use\nto help them interpret the "internal" error code value, or\nto find an internationalization translation for the message.'
        ),
    ] = None
    errors: Annotated[
        Optional[List[ErrorItem]],
        Field(
            description="Collection of errors in cases where more than one exists. This needs to be\nflexible so we can support multiple formats"
        ),
    ] = None
    index: Optional[ErrorIndex] = None
    internal: Annotated[
        Optional[int],
        Field(
            description="Internal error code in cases where we don't have an array of errors"
        ),
    ] = None
    message: Annotated[
        str, Field(description="The basic text error message for the error response.")
    ]
    ref: Annotated[
        Optional[str],
        Field(
            description="Reference to the error source. Should typically be the URI of the request"
        ),
    ] = None
    type: Annotated[
        Optional[str],
        Field(
            description="URI pointing at a document that describes the error and mitigation steps\nIf there is no document, point to the RFC for the HTTP error code"
        ),
    ] = None


class K8SPatchOp(BaseModel):
    from_: Annotated[Optional[str], Field(alias="from")] = None
    op: str
    path: str
    value: Optional[Dict[str, Any]] = None
    x_permissive: Annotated[Optional[bool], Field(alias="x-permissive")] = None


class Patch(RootModel[List[K8SPatchOp]]):
    root: List[K8SPatchOp]


class Resource(BaseModel):
    kind: Optional[str] = None
    name: Optional[str] = None
    namespaced: Optional[bool] = None
    readOnly: Optional[bool] = None
    singularName: Optional[str] = None
    uiCategory: Optional[str] = None


class ResourceHistoryEntry(BaseModel):
    author: Optional[str] = None
    changeType: Optional[str] = None
    commitTime: Optional[AwareDatetime] = None
    hash: Optional[str] = None
    message: Optional[str] = None
    transactionId: Optional[int] = None


class ResourceList(BaseModel):
    apiVersion: Optional[str] = None
    groupVersion: Optional[str] = None
    kind: Optional[str] = None
    resources: Optional[List[Resource]] = None


class StatusDetails(BaseModel):
    group: Optional[str] = None
    kind: Optional[str] = None
    name: Optional[str] = None


class TopoAttrMetadata(BaseModel):
    type: Optional[str] = None
    ui_description: Optional[str] = None
    ui_description_key: Optional[str] = None
    ui_name: Optional[str] = None
    ui_name_key: Optional[str] = None


class TopoLinkEndpoint(BaseModel):
    endpoint: Optional[str] = None
    node: Optional[str] = None
    node_key: Optional[str] = None


class TopoNodeGrouping(BaseModel):
    group: Optional[str] = None
    tier: Optional[int] = None


class TopoOverlayEndpointState(BaseModel):
    state: Optional[int] = None


TopoOverlayLinkState = TopoOverlayEndpointState


class TopoOverlayNodeState(BaseModel):
    badges: Optional[List[int]] = None
    state: Optional[int] = None


class TopoSchema(BaseModel):
    group: Optional[str] = None
    kind: Optional[str] = None
    version: Optional[str] = None


class UIResult(RootModel[str]):
    root: str


class MonitorSpecCpuUtilization(BaseModel):
    """
    Parameters relating to CPU utilization monitoring.
    """

    criticalThreshold: Annotated[
        Optional[int],
        Field(
            description="The minimum average utilization over the last 1 minute to trigger a critical alarm.\nThis value must be greater than the majorThreshold.",
            ge=1,
            le=100,
            title="Critical Threshold",
        ),
    ] = 95
    fallingDelta: Annotated[
        Optional[int],
        Field(
            description="The delta in which a triggered threshold must drop below to clear an alarm.\nFor example, with a criticalThreshold of 90 and a fallingDelta of 5, the critical alarm will clear when the utilization drops below 85.",
            ge=1,
            le=25,
            title="Falling Delta",
        ),
    ] = 5
    majorThreshold: Annotated[
        Optional[int],
        Field(
            description="The minimum average utilization over the last 1 minute to trigger a major alarm.\nThis value must be greater than the minorThreshold.",
            ge=1,
            le=100,
            title="Major Threshold",
        ),
    ] = 90
    minorThreshold: Annotated[
        Optional[int],
        Field(
            description="The minimum average utilization over the last 1 minute to trigger a minor alarm.",
            ge=1,
            le=100,
            title="Minor Threshold",
        ),
    ] = 80


class MonitorSpecCpu(BaseModel):
    """
    CPU monitoring for targets matching this Monitor.
    """

    enabled: Annotated[
        bool, Field(description="Enable or disable CPU monitoring.", title="Enabled")
    ]
    utilization: Annotated[
        Optional[MonitorSpecCpuUtilization],
        Field(
            description="Parameters relating to CPU utilization monitoring.",
            title="Thresholds",
        ),
    ] = None


class MonitorSpecDiskUtilization(BaseModel):
    """
    Parameters relating to disk utilization monitoring.
    """

    criticalThreshold: Annotated[
        Optional[int],
        Field(
            description="The minimum average utilization over the last 1 minute to trigger a critical alarm.\nThis value must be greater than the majorThreshold.",
            ge=1,
            le=100,
            title="Critical Threshold",
        ),
    ] = 95
    fallingDelta: Annotated[
        Optional[int],
        Field(
            description="The delta in which a triggered threshold must drop below to clear an alarm.\nFor example, with a criticalThreshold of 90 and a fallingDelta of 5, the critical alarm will clear when the utilization drops below 85.",
            ge=1,
            le=25,
            title="Falling Delta",
        ),
    ] = 5
    majorThreshold: Annotated[
        Optional[int],
        Field(
            description="The minimum average utilization over the last 1 minute to trigger a major alarm.\nThis value must be greater than the minorThreshold.",
            ge=1,
            le=100,
            title="Major Threshold",
        ),
    ] = 90
    minorThreshold: Annotated[
        Optional[int],
        Field(
            description="The minimum average utilization over the last 1 minute to trigger a minor alarm.",
            ge=1,
            le=100,
            title="Minor Threshold",
        ),
    ] = 80


class MonitorSpecDisk(BaseModel):
    """
    Disk monitoring for targets matching this Monitor.
    """

    enabled: Annotated[
        bool, Field(description="Enable or disable disk monitoring.", title="Enabled")
    ]
    utilization: Annotated[
        Optional[MonitorSpecDiskUtilization],
        Field(
            description="Parameters relating to disk utilization monitoring.",
            title="Thresholds",
        ),
    ] = None


class MonitorSpecMemoryUtilization(BaseModel):
    """
    Parameters relating to memory utilization monitoring.
    """

    criticalThreshold: Annotated[
        Optional[int],
        Field(
            description="The minimum average utilization over the last 1 minute to trigger a critical alarm.\nThis value must be greater than the majorThreshold.",
            ge=1,
            le=100,
            title="Critical Threshold",
        ),
    ] = 95
    fallingDelta: Annotated[
        Optional[int],
        Field(
            description="The delta in which a triggered threshold must drop below to clear an alarm.\nFor example, with a criticalThreshold of 90 and a fallingDelta of 5, the critical alarm will clear when the utilization drops below 85.",
            ge=1,
            le=25,
            title="Falling Delta",
        ),
    ] = 5
    majorThreshold: Annotated[
        Optional[int],
        Field(
            description="The minimum average utilization over the last 1 minute to trigger a major alarm.\nThis value must be greater than the minorThreshold.",
            ge=1,
            le=100,
            title="Major Threshold",
        ),
    ] = 90
    minorThreshold: Annotated[
        Optional[int],
        Field(
            description="The minimum average utilization over the last 1 minute to trigger a minor alarm.",
            ge=1,
            le=100,
            title="Minor Threshold",
        ),
    ] = 80


class MonitorSpecMemory(BaseModel):
    """
    Memory monitoring for targets matching this Monitor.
    """

    enabled: Annotated[
        bool, Field(description="Enable or disable memory monitoring.", title="Enabled")
    ]
    utilization: Annotated[
        Optional[MonitorSpecMemoryUtilization],
        Field(
            description="Parameters relating to memory utilization monitoring.",
            title="Thresholds",
        ),
    ] = None


class MonitorSpec(BaseModel):
    """
    MonitorSpec defines the desired state of Monitor
    """

    cpu: Annotated[
        Optional[MonitorSpecCpu],
        Field(
            description="CPU monitoring for targets matching this Monitor.", title="CPU"
        ),
    ] = None
    disk: Annotated[
        Optional[MonitorSpecDisk],
        Field(
            description="Disk monitoring for targets matching this Monitor.",
            title="Disk",
        ),
    ] = None
    memory: Annotated[
        Optional[MonitorSpecMemory],
        Field(
            description="Memory monitoring for targets matching this Monitor.",
            title="Memory",
        ),
    ] = None
    nodeSelector: Annotated[
        Optional[List[str]],
        Field(
            description="Selector to use when including TopoNodes to monitor.",
            title="Node Selector",
        ),
    ] = None
    nodes: Annotated[
        Optional[List[str]],
        Field(description="References to TopoNodes to monitor.", title="Nodes"),
    ] = None


class MonitorStatus(BaseModel):
    """
    MonitorStatus defines the observed state of Monitor
    """

    nodes: Annotated[
        Optional[List[str]],
        Field(description="TopoNodes being monitored.", title="Nodes"),
    ] = None


class MonitorAggregateStateSpec(BaseModel):
    """
    MonitorAggregateStateSpec defines the desired state of MonitorAggregateState
    """

    nodes: Annotated[
        Optional[List[str]],
        Field(
            description="List of TopoNodes monitored by this instance", title="Nodes"
        ),
    ] = None


class MonitorAggregateStateDeletedResourceEntry(BaseModel):
    commitTime: Optional[AwareDatetime] = None
    hash: Optional[str] = None
    name: Optional[str] = None
    namespace: Optional[str] = None
    transactionId: Optional[int] = None


class MonitorAggregateStateDeletedResources(
    RootModel[List[MonitorAggregateStateDeletedResourceEntry]]
):
    root: List[MonitorAggregateStateDeletedResourceEntry]


class MonitorAggregateStateMetadata(BaseModel):
    annotations: Optional[Dict[str, str]] = None
    labels: Optional[Dict[str, str]] = None
    name: Annotated[
        str,
        Field(
            max_length=253,
            pattern="^[a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*$",
        ),
    ]
    namespace: str


MonitorStateSpecMonitorSpecCpuUtilization = MonitorSpecCpuUtilization


class MonitorStateSpecMonitorSpecCpu(BaseModel):
    """
    CPU monitoring for targets matching this Monitor.
    """

    enabled: Annotated[
        bool, Field(description="Enable or disable CPU monitoring.", title="Enabled")
    ]
    utilization: Annotated[
        Optional[MonitorStateSpecMonitorSpecCpuUtilization],
        Field(
            description="Parameters relating to CPU utilization monitoring.",
            title="Thresholds",
        ),
    ] = None


MonitorStateSpecMonitorSpecDiskUtilization = MonitorSpecDiskUtilization


class MonitorStateSpecMonitorSpecDisk(BaseModel):
    """
    Disk monitoring for targets matching this Monitor.
    """

    enabled: Annotated[
        bool, Field(description="Enable or disable disk monitoring.", title="Enabled")
    ]
    utilization: Annotated[
        Optional[MonitorStateSpecMonitorSpecDiskUtilization],
        Field(
            description="Parameters relating to disk utilization monitoring.",
            title="Thresholds",
        ),
    ] = None


MonitorStateSpecMonitorSpecMemoryUtilization = MonitorSpecMemoryUtilization


class MonitorStateSpecMonitorSpecMemory(BaseModel):
    """
    Memory monitoring for targets matching this Monitor.
    """

    enabled: Annotated[
        bool, Field(description="Enable or disable memory monitoring.", title="Enabled")
    ]
    utilization: Annotated[
        Optional[MonitorStateSpecMonitorSpecMemoryUtilization],
        Field(
            description="Parameters relating to memory utilization monitoring.",
            title="Thresholds",
        ),
    ] = None


class MonitorStateSpecMonitorSpec(BaseModel):
    """
    The spec of the input Monitor
    """

    cpu: Annotated[
        Optional[MonitorStateSpecMonitorSpecCpu],
        Field(
            description="CPU monitoring for targets matching this Monitor.", title="CPU"
        ),
    ] = None
    disk: Annotated[
        Optional[MonitorStateSpecMonitorSpecDisk],
        Field(
            description="Disk monitoring for targets matching this Monitor.",
            title="Disk",
        ),
    ] = None
    memory: Annotated[
        Optional[MonitorStateSpecMonitorSpecMemory],
        Field(
            description="Memory monitoring for targets matching this Monitor.",
            title="Memory",
        ),
    ] = None
    nodeSelector: Annotated[
        Optional[List[str]],
        Field(
            description="Selector to use when including TopoNodes to monitor.",
            title="Node Selector",
        ),
    ] = None
    nodes: Annotated[
        Optional[List[str]],
        Field(description="References to TopoNodes to monitor.", title="Nodes"),
    ] = None


class MonitorStateSpec(BaseModel):
    """
    MonitorStateSpec defines the desired state of MonitorState
    """

    monitorSpec: Annotated[
        MonitorStateSpecMonitorSpec, Field(description="The spec of the input Monitor")
    ]
    node: Annotated[str, Field(description="Reference to the TopoNode being monitored")]
    operatingSystem: Annotated[
        str, Field(description="The operating system of the TopoNode being monitored")
    ]
    version: Annotated[
        str, Field(description="The version of the TopoNode being monitored")
    ]


MonitorStateDeletedResourceEntry = MonitorAggregateStateDeletedResourceEntry


class MonitorStateDeletedResources(RootModel[List[MonitorStateDeletedResourceEntry]]):
    root: List[MonitorStateDeletedResourceEntry]


MonitorStateMetadata = MonitorAggregateStateMetadata


MonitorDeletedResourceEntry = MonitorAggregateStateDeletedResourceEntry


class MonitorDeletedResources(RootModel[List[MonitorDeletedResourceEntry]]):
    root: List[MonitorDeletedResourceEntry]


MonitorMetadata = MonitorAggregateStateMetadata


class AppGroup(BaseModel):
    apiVersion: Optional[str] = None
    kind: Optional[str] = None
    name: Optional[str] = None
    preferredVersion: Optional[AppGroupVersion] = None
    versions: Optional[List[AppGroupVersion]] = None


class ResourceHistory(RootModel[List[ResourceHistoryEntry]]):
    root: List[ResourceHistoryEntry]


class Status(BaseModel):
    apiVersion: Optional[str] = None
    details: Optional[StatusDetails] = None
    kind: Optional[str] = None
    string: Optional[str] = None


class TopoElemMetadata(BaseModel):
    attributes: Optional[Dict[str, TopoAttrMetadata]] = None
    schema_: Annotated[Optional[TopoSchema], Field(alias="schema")] = None
    subtitle: Optional[str] = None
    subtitle_key: Optional[str] = None


class TopoOverlayEndpoint(BaseModel):
    attributes: Optional[Dict[str, Dict[str, Any]]] = None
    cr_name: Optional[str] = None
    labels: Optional[Dict[str, str]] = None
    name: Optional[str] = None
    namespace: Optional[str] = None
    overlays: Optional[Dict[str, TopoOverlayEndpointState]] = None
    schema_: Annotated[Optional[TopoSchema], Field(alias="schema")] = None
    state: Optional[int] = None
    ui_name: Optional[str] = None


class TopoOverlayLink(BaseModel):
    attributes: Optional[Dict[str, Dict[str, Any]]] = None
    cr_name: Optional[str] = None
    endpoint_a: Optional[TopoLinkEndpoint] = None
    endpoint_a_details: Optional[TopoOverlayEndpoint] = None
    endpoint_b: Optional[TopoLinkEndpoint] = None
    endpoint_b_details: Optional[TopoOverlayEndpoint] = None
    key: Optional[str] = None
    labels: Optional[Dict[str, str]] = None
    name: Optional[str] = None
    namespace: Optional[str] = None
    overlays: Optional[Dict[str, TopoOverlayLinkState]] = None
    schema_: Annotated[Optional[TopoSchema], Field(alias="schema")] = None
    state: Optional[int] = None
    ui_name: Optional[str] = None


class TopoOverlayNode(BaseModel):
    attributes: Optional[Dict[str, Dict[str, Any]]] = None
    badges: Optional[List[int]] = None
    cr_name: Optional[str] = None
    grouping: Optional[TopoNodeGrouping] = None
    key: Optional[str] = None
    labels: Optional[Dict[str, str]] = None
    name: Optional[str] = None
    namespace: Optional[str] = None
    overlays: Optional[Dict[str, TopoOverlayNodeState]] = None
    schema_: Annotated[Optional[TopoSchema], Field(alias="schema")] = None
    state: Optional[int] = None
    ui_name: Optional[str] = None


class Topology(BaseModel):
    endpoints: Optional[TopoElemMetadata] = None
    group: Optional[str] = None
    grouping: Optional[TopoSchema] = None
    links: Optional[TopoElemMetadata] = None
    name: Optional[str] = None
    nodes: Optional[TopoElemMetadata] = None
    ui_description: Optional[str] = None
    ui_description_key: Optional[str] = None
    ui_name: Optional[str] = None
    ui_name_key: Optional[str] = None
    version: Optional[str] = None


class Monitor(BaseModel):
    """
    Monitor is the Schema for the monitors API
    """

    apiVersion: Annotated[str, Field(pattern="^system\\.eda\\.nokia\\.com/v1alpha1$")]
    kind: Annotated[str, Field(pattern="^Monitor$")]
    metadata: MonitorMetadata
    spec: Annotated[
        MonitorSpec,
        Field(
            description="MonitorSpec defines the desired state of Monitor",
            title="Specification",
        ),
    ]
    status: Annotated[
        Optional[MonitorStatus],
        Field(
            description="MonitorStatus defines the observed state of Monitor",
            title="Status",
        ),
    ] = None


class MonitorAggregateState(BaseModel):
    """
    MonitorAggregateState is the Schema for the monitoraggregatestates API
    """

    apiVersion: Annotated[str, Field(pattern="^system\\.eda\\.nokia\\.com/v1alpha1$")]
    kind: Annotated[str, Field(pattern="^MonitorAggregateState$")]
    metadata: MonitorAggregateStateMetadata
    spec: Annotated[
        MonitorAggregateStateSpec,
        Field(
            description="MonitorAggregateStateSpec defines the desired state of MonitorAggregateState",
            title="Specification",
        ),
    ]
    status: Annotated[
        Optional[Dict[str, Any]],
        Field(
            description="MonitorAggregateStateStatus defines the observed state of MonitorAggregateState",
            title="Status",
        ),
    ] = None


class MonitorAggregateStateList(BaseModel):
    """
    MonitorAggregateStateList is a list of monitoraggregatestates
    """

    apiVersion: str
    items: Optional[List[MonitorAggregateState]] = None
    kind: str


class MonitorList(BaseModel):
    """
    MonitorList is a list of monitors
    """

    apiVersion: str
    items: Optional[List[Monitor]] = None
    kind: str


class MonitorState(BaseModel):
    """
    MonitorState is the Schema for the monitorstates API
    """

    apiVersion: Annotated[str, Field(pattern="^system\\.eda\\.nokia\\.com/v1alpha1$")]
    kind: Annotated[str, Field(pattern="^MonitorState$")]
    metadata: MonitorStateMetadata
    spec: Annotated[
        MonitorStateSpec,
        Field(
            description="MonitorStateSpec defines the desired state of MonitorState",
            title="Specification",
        ),
    ]
    status: Annotated[
        Optional[Dict[str, Any]],
        Field(
            description="MonitorStateStatus defines the observed state of MonitorState",
            title="Status",
        ),
    ] = None


class MonitorStateList(BaseModel):
    """
    MonitorStateList is a list of monitorstates
    """

    apiVersion: str
    items: Optional[List[MonitorState]] = None
    kind: str


class OverlayState(BaseModel):
    links: Optional[Dict[str, TopoOverlayLink]] = None
    nodes: Optional[Dict[str, TopoOverlayNode]] = None


class ResourceTopology(BaseModel):
    topology: Optional[OverlayState] = None
    topologyMetadata: Optional[Topology] = None
