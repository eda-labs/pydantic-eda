# generated by datamodel-codegen:
#   filename:  interfaces.json

from __future__ import annotations
from typing import Annotated, Any, Dict, List, Literal, Optional
from pydantic import BaseModel, Field, RootModel
from datetime import date


class AppGroupVersion(BaseModel):
    groupVersion: Optional[str] = None
    version: Optional[str] = None


class ErrorIndex(BaseModel):
    index: Optional[int] = None


class ErrorItem(BaseModel):
    error: Optional[Dict[str, Any]] = None
    type: Optional[str] = None


class ErrorResponse(BaseModel):
    """
    Generic error response for REST APIs
    """

    code: Annotated[
        int, Field(description="the numeric HTTP error code for the response.")
    ]
    details: Annotated[
        Optional[str], Field(description="The optional details of the error response.")
    ] = None
    dictionary: Annotated[
        Optional[Dict[str, Any]],
        Field(
            description='Dictionary/map of associated data/information relevant to the error.\nThe error "message" may contain {{name}} escapes that should be substituted\nwith information from this dictionary.'
        ),
    ] = None
    errors: Annotated[
        Optional[List[ErrorItem]],
        Field(
            description="Collection of errors in cases where more than one exists. This needs to be\nflexible so we can support multiple formats"
        ),
    ] = None
    index: Optional[ErrorIndex] = None
    internal: Annotated[
        Optional[int],
        Field(
            description="Internal error code in cases where we don't have an array of errors"
        ),
    ] = None
    message: Annotated[
        str, Field(description="The basic text error message for the error response.")
    ]
    ref: Annotated[
        Optional[str],
        Field(
            description="Reference to the error source. Should typically be the URI of the request"
        ),
    ] = None
    type: Annotated[
        Optional[str],
        Field(
            description="URI pointing at a document that describes the error and mitigation steps\nIf there is no document, point to the RFC for the HTTP error code"
        ),
    ] = None


class K8SPatchOp(BaseModel):
    from_: Annotated[Optional[str], Field(alias="from")] = None
    op: str
    path: str
    value: Optional[Dict[str, Any]] = None
    x_permissive: Annotated[Optional[bool], Field(alias="x-permissive")] = None


class Patch(RootModel[List[K8SPatchOp]]):
    root: List[K8SPatchOp]


class Resource(BaseModel):
    kind: Optional[str] = None
    name: Optional[str] = None
    namespaced: Optional[bool] = None
    readOnly: Optional[bool] = None
    singularName: Optional[str] = None
    uiCategory: Optional[str] = None


class ResourceHistoryEntry(BaseModel):
    author: Optional[str] = None
    changeType: Optional[str] = None
    commitTime: Optional[str] = None
    hash: Optional[str] = None
    message: Optional[str] = None
    transactionId: Optional[int] = None


class ResourceList(BaseModel):
    apiVersion: Optional[str] = None
    groupVersion: Optional[str] = None
    kind: Optional[str] = None
    resources: Optional[List[Resource]] = None


class StatusDetails(BaseModel):
    group: Optional[str] = None
    kind: Optional[str] = None
    name: Optional[str] = None


class UIResult(RootModel[str]):
    root: str


class BreakoutSpec(BaseModel):
    """
    Breakout allows for the configuration of interface breakouts on specified Nodes. This resource specifies the Nodes, parent Interfaces, the number of breakout channels, and the speed of each channel.
    """

    channels: Annotated[
        int,
        Field(
            description="The number of breakout channels to create.",
            ge=1,
            le=8,
            title="Number of Channels",
        ),
    ]
    interface: Annotated[
        Optional[List[str]],
        Field(
            description="A list of normalized parent interface/port.",
            title="Nomalized Parent Interface",
        ),
    ] = None
    node: Annotated[
        List[str],
        Field(
            description="Reference to a list of TopoNodes where the parent interfaces are to be broken out.",
            title="Nodes",
        ),
    ]
    nodeSelector: Annotated[
        Optional[List[str]],
        Field(
            description="TopoNode where the parent interfaces are to be broken out.",
            title="TopoNode",
        ),
    ] = None
    speed: Annotated[
        Literal["800G", "400G", "200G", "100G", "50G", "40G", "25G", "10G"],
        Field(description="The speed of each breakout channel.", title="Speed"),
    ]


class BreakoutDeletedResourceEntry(BaseModel):
    commitTime: Optional[str] = None
    hash: Optional[str] = None
    name: Optional[str] = None
    namespace: Optional[str] = None
    transactionId: Optional[int] = None


class BreakoutDeletedResources(RootModel[List[BreakoutDeletedResourceEntry]]):
    root: List[BreakoutDeletedResourceEntry]


class BreakoutMetadata(BaseModel):
    annotations: Optional[Dict[str, str]] = None
    labels: Optional[Dict[str, str]] = None
    name: Annotated[
        str,
        Field(
            max_length=253,
            pattern="^[a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*$",
        ),
    ]
    namespace: str


class InterfaceSpecEthernetStormControl(BaseModel):
    """
    Enables storm control.
    """

    broadcastRate: Annotated[
        Optional[int],
        Field(
            description="Sets the maximum rate allowed for ingress broadcast frames on the interface.",
            ge=0,
            le=100000000,
            title="Broadcast Rate",
        ),
    ] = None
    enabled: Annotated[
        Optional[bool], Field(description="Enables storm control.", title="Enabled")
    ] = None
    multicastRate: Annotated[
        Optional[int],
        Field(
            description="Sets the maximum rate allowed for ingress multicast frames on the interface.",
            ge=0,
            le=100000000,
            title="Multicast Rate",
        ),
    ] = None
    units: Annotated[
        Optional[Literal["kbps", "percentage"]],
        Field(description="Set the units to be used for measurement.", title="Units"),
    ] = None
    unknownUnicastRate: Annotated[
        Optional[int],
        Field(
            description="Sets the maximum rate allowed for ingress unknown unicast frames on the interface.",
            ge=0,
            le=100000000,
            title="Unknown Unicast Rate",
        ),
    ] = None


class InterfaceSpecEthernet(BaseModel):
    """
    Ethernet configuration options.
    """

    fec: Annotated[
        Optional[Literal["disabled", "rs528", "rs544", "baser", "rs108"]],
        Field(
            description="Sets the Forward Error Correction (FEC) on the members of the interface.",
            title="Forward Error Correction",
        ),
    ] = None
    holdDownTimer: Annotated[
        Optional[int],
        Field(
            description="The hold-time down behavior is triggered with events that try to bring the ethernet interface down and can change quickly. It is not triggered with an admin-state disable event or interface disable due to other internal reasons.  Units in milliseconds.",
            ge=100,
            le=86400000,
            title="Hold Down Timer",
        ),
    ] = None
    holdUpTimer: Annotated[
        Optional[int],
        Field(
            description="The hold-time up behavior is triggered with any event that tries to bring up the ethernet interface.  While the hold-time up is running, the transceiver laser will be enabled, however the higher layers will not be notified that the interface is operationally up until the timer expires.  Units in milliseconds.",
            ge=100,
            le=86400000,
            title="Hold Up Timer",
        ),
    ] = None
    reloadDelayTimer: Annotated[
        Optional[int],
        Field(
            description="After the system boots, the reload-delay timer in seconds keeps an interface shut down with the laser off for a configured amount of time until connectivity with the rest of network is established.",
            ge=1,
            le=86400,
            title="Reload Delay Timer",
        ),
    ] = None
    speed: Annotated[
        Optional[Literal["100G", "10G", "1G", "25G", "40G", "50G", "400G"]],
        Field(
            description="The speed of this interface, in human-readable format - e.g. 25G, 100G.",
            title="Speed",
        ),
    ] = None
    standbySignaling: Annotated[
        Optional[Literal["lacp", "power-off"]],
        Field(
            description="Indicates the standby-signaling used in the interface.",
            title="Standby Signaling",
        ),
    ] = None
    stormControl: Annotated[
        Optional[InterfaceSpecEthernetStormControl],
        Field(description="Enables storm control.", title="Storm Control"),
    ] = None
    transparentL2CPProtocols: Annotated[
        Optional[List[Literal["LLDP", "LACP", "xSTP", "Dot1x", "PTP", "All"]]],
        Field(
            description="A list of L2CP protocols to tunnel. Options: LLDP, LACP, xSTP, Dot1x, PTP, All.",
            title="Transparent L2CP Protocols",
        ),
    ] = None


class InterfaceSpecLagLacpLacpFallback(BaseModel):
    """
    LACP fallback allows one or more designated links of an LACP controlled LAG to go into forwarding mode if LACP is not yet operational after a configured timeout period. [default=disabled]
    """

    mode: Annotated[
        Optional[Literal["static"]],
        Field(description="Specifies lacp-fallback mode if enabled.", title="Mode"),
    ] = "static"
    timeout: Annotated[
        Optional[int],
        Field(
            description="Specifies the LACP-fallback timeout interval in seconds. [default=60]",
            ge=4,
            le=3600,
            title="Timeout",
        ),
    ] = 60


class InterfaceSpecLagLacp(BaseModel):
    adminKey: Annotated[
        Optional[int],
        Field(
            description="Configure the LACP admin-key to be advertised by the local system.",
            ge=1,
            le=65535,
            title="Admin Key",
        ),
    ] = None
    interval: Annotated[
        Optional[Literal["fast", "slow"]],
        Field(
            description='Set the period between LACP messages, uses the lacp-period-type enumeration. [default="fast"]',
            title="Interval",
        ),
    ] = "fast"
    lacpFallback: Annotated[
        Optional[InterfaceSpecLagLacpLacpFallback],
        Field(
            description="LACP fallback allows one or more designated links of an LACP controlled LAG to go into forwarding mode if LACP is not yet operational after a configured timeout period. [default=disabled]",
            title="Fallback",
        ),
    ] = None
    mode: Annotated[
        Optional[Literal["active", "passive"]],
        Field(
            description='Active is to initiate the transmission of LACP PDUs. Passive is to wait for peer to initiate the transmission of LACP PDUs.[default="active"]',
            title="Mode",
        ),
    ] = "active"
    systemIdMac: Annotated[
        Optional[str],
        Field(
            description="The MAC address portion of the Node's System ID. This is combined with the system priority to construct the 8-octet system-id.",
            title="System ID MAC",
        ),
    ] = None
    systemPriority: Annotated[
        Optional[int],
        Field(
            description="System priority used by the Node on this LAG interface. Lower value is higher priority for determining which Node is the controlling system.[default=32768]",
            ge=0,
            le=65535,
            title="System Priority",
        ),
    ] = 32768


class InterfaceSpecLagMultihoming(BaseModel):
    esi: Annotated[
        Optional[str],
        Field(
            description="10 byte Ethernet Segment Identifier, if not set a type 0 ESI is generated. [default=auto]",
            title="ESI",
        ),
    ] = "auto"
    mode: Annotated[
        Optional[Literal["all-active", "single-active", "port-active"]],
        Field(
            description='"all-active": All interfaces are active.\n"single-active": In a single active MH LAG, the active and standby function is handled at the sub-interface layer within a network-instance.  That is, the physical interfaces within the same LAG all remain operationally up, however each sub-interface associated with a network-instance has its operational state up or down based on whether it is selected to be the active or standby sub-interface.\n"port-active": When port active MH LAG is enabled, the active and standby function is handled at the interface level.',
            title="Mode",
        ),
    ] = "all-active"
    preferredActiveNode: Annotated[
        Optional[str],
        Field(
            description="To be used in single-active or port-active modes.  This references the Node object and when set, the DF algorithm is configured to type preference and the selected Node is set with a higher preference value.  All other Nodes have a lower value configured.",
            title="Preferred Active Node",
        ),
    ] = None
    reloadDelayTimer: Annotated[
        Optional[int],
        Field(
            description="After the system boots, the reload-delay timer in seconds keeps an interface shut down with the laser off for a configured amount of time until connectivity with the rest of network is established. [default=100]",
            ge=1,
            le=86400,
            title="Reload Delay Timer",
        ),
    ] = 100
    revertive: Annotated[
        Optional[bool],
        Field(
            description="To be used in single-active or port-active modes.  When true, if there is a switch of active interface in the LAG and the original interface comes back up, the LAG will switch back to using the original interface as active. [default=false]",
            title="Revertive",
        ),
    ] = False


class InterfaceSpecLag(BaseModel):
    """
    LAG configuration options.
    """

    lacp: Annotated[Optional[InterfaceSpecLagLacp], Field(title="LACP")] = None
    minLinks: Annotated[
        Optional[int],
        Field(
            description="The min-link threshold specifies the minimum number of member links that must be active in order for the LAG to be operationally up. If the number of active links falls below this threshold, the entire LAG is brought operationally down.[default=1]",
            ge=1,
            le=64,
            title="Minimum Links",
        ),
    ] = 1
    multihoming: Annotated[
        Optional[InterfaceSpecLagMultihoming], Field(title="Multi Homing")
    ] = None
    type: Annotated[
        Optional[Literal["lacp", "static"]],
        Field(
            description="This type defines whether whether it is a static or LACP LAG. [default=lacp]",
            title="Type",
        ),
    ] = "lacp"


class InterfaceSpecMember(BaseModel):
    aggregateId: Annotated[
        Optional[str],
        Field(
            description="When using a LAG, the aggregateId can be specified per set of interfaces on a node.\nLAG interface with which this interface is associated.",
            title="Aggregate ID",
        ),
    ] = None
    description: Annotated[
        Optional[str],
        Field(
            description="Description of the member, inherited from the interface if not provided.",
            title="Description",
        ),
    ] = None
    enabled: Annotated[
        Optional[bool],
        Field(description="Enable or disable this member.", title="Enabled"),
    ] = True
    interface: Annotated[
        str,
        Field(
            description="Reference to an interface in the normalized format. Ex: SRL ethernet-1/1 would be ethernet-1-1. SROS port 2/1/1 would be ethernet-2-1.",
            title="Interface",
        ),
    ]
    lacpPortPriority: Annotated[
        Optional[int],
        Field(
            description="Configure the port priority for LACP. This value is used to determine which port should be activated with LACP fallback mode. Lower values are more preferred.[default=32768]",
            ge=0,
            le=65535,
            title="LACP Port Priority",
        ),
    ] = 32768
    node: Annotated[str, Field(description="Node name.", title="Node Name")]


class InterfaceSpec(BaseModel):
    """
    Interface allows for the configuration of various interface properties such as enabling/disabling the interface, setting descriptions, specifying interface types (e.g., LAG, interface, loopback), configuring VLAN encapsulation, and setting Ethernet or LAG-specific options.
    """

    ddm: Annotated[
        Optional[bool],
        Field(description="Enables reporting of DDM events.", title="DDM"),
    ] = None
    description: Annotated[
        Optional[str],
        Field(description="Description of the interface.", title="Description"),
    ] = None
    enabled: Annotated[
        Optional[bool],
        Field(description="Enable or disable the interface.", title="Enabled"),
    ] = True
    encapType: Annotated[
        Optional[Literal["null", "dot1q"]],
        Field(
            description='Enable or disable VLAN tagging on this interface. [default="null"]',
            title="Encapsulation Type",
        ),
    ] = "null"
    ethernet: Annotated[
        Optional[InterfaceSpecEthernet],
        Field(description="Ethernet configuration options.", title="Ethernet"),
    ] = None
    lag: Annotated[
        Optional[InterfaceSpecLag],
        Field(description="LAG configuration options.", title="LAG"),
    ] = None
    lldp: Annotated[
        Optional[bool],
        Field(
            description="Enable or disable LLDP on the members of the interface.",
            title="Link Layer Discovery Protocol",
        ),
    ] = True
    members: Annotated[
        List[InterfaceSpecMember],
        Field(
            description="List of members on which to apply properties, for single interface this would be a list of 1.",
            title="Members",
        ),
    ]
    mtu: Annotated[
        Optional[int],
        Field(
            description="MTU to apply on the interface(s).",
            ge=1450,
            le=9500,
            title="MTU",
        ),
    ] = None
    type: Annotated[
        Optional[Literal["lag", "interface", "loopback"]],
        Field(
            description="Type defines whether the interface is a Lag or Interface.",
            title="Type",
        ),
    ] = "interface"


class InterfaceStatusLag(BaseModel):
    adminKey: Annotated[Optional[int], Field(title="Admin Key")] = None
    systemIdMac: Annotated[Optional[str], Field(title="System ID MAC")] = None


class InterfaceStatusMemberNeighbor(BaseModel):
    interface: Annotated[
        Optional[str],
        Field(
            description="The name of a neighbor interface of this member in node specific format.",
            title="Interface",
        ),
    ] = None
    node: Annotated[
        Optional[str],
        Field(
            description="The name of a neighbor node of this member in node specific format.",
            title="Node",
        ),
    ] = None


class InterfaceStatusMember(BaseModel):
    enabled: Annotated[
        Optional[bool],
        Field(description="The administrative status of this member.", title="Enabled"),
    ] = None
    interface: Annotated[
        Optional[str],
        Field(
            description="The name of the interface in normalized format.",
            title="Interface",
        ),
    ] = None
    lastChange: Annotated[
        Optional[date],
        Field(
            description="Indicates when this member last changed state.",
            title="Last Change",
        ),
    ] = None
    neighbors: Annotated[
        Optional[List[InterfaceStatusMemberNeighbor]],
        Field(
            description="List of discovered neighbors on this member.",
            title="Neighbors",
        ),
    ] = None
    node: Annotated[
        Optional[str],
        Field(
            description="The node on which the interface is configured.", title="Node"
        ),
    ] = None
    nodeInterface: Annotated[
        str,
        Field(
            description='Node specific interface name, for example "ethernet-1/1", "1/1/c1/1".',
            title="Node Interface",
        ),
    ]
    operationalState: Annotated[
        Optional[str],
        Field(
            description="Indicates the current operational state of this member.",
            title="Operational State",
        ),
    ] = None
    speed: Annotated[
        Optional[str],
        Field(
            description="Indicates the operational speed of the member.", title="Speed"
        ),
    ] = None


class InterfaceStatus(BaseModel):
    enabled: Annotated[
        Optional[bool],
        Field(
            description="The administrative status of the Interface.", title="Enabled"
        ),
    ] = None
    lag: Annotated[Optional[InterfaceStatusLag], Field(title="Lag")] = None
    lastChange: Annotated[
        Optional[date],
        Field(
            description="Indicates when this Interface last changed state.",
            title="Last Change",
        ),
    ] = None
    members: Annotated[
        Optional[List[InterfaceStatusMember]],
        Field(description="List of members in this Interface.", title="Members"),
    ] = None
    operationalState: Annotated[
        Optional[str],
        Field(
            description="Indicates the current operational state of the Interface.",
            title="Operational State",
        ),
    ] = None
    speed: Annotated[
        Optional[str],
        Field(
            description="Indicates the operational speed of the Interface in aggregate.",
            title="Speed",
        ),
    ] = None


InterfaceStateSpecLag = InterfaceStatusLag


class InterfaceStateSpecMember(BaseModel):
    aggregateId: Annotated[
        Optional[str],
        Field(description="LAG interface with which this interface is associated"),
    ] = None
    enabled: Annotated[
        Optional[bool], Field(description="Enable or disable this member.")
    ] = None
    interface: Annotated[str, Field(description="Normalized interface name")]
    node: Annotated[
        str, Field(description="Reference to the TopoNode on which this member resides")
    ]
    nodeInterface: Annotated[
        str,
        Field(
            description='Node specific interface name, for example "ethernet-1/1", "1/1/c1/1"'
        ),
    ]
    operatingSystem: Annotated[
        str,
        Field(
            description="The operating system of the TopoNode on which this member resides"
        ),
    ]
    version: Annotated[
        str,
        Field(
            description="The version of the TopoNode on which this interface resides"
        ),
    ]


class InterfaceStateSpec(BaseModel):
    enabled: Annotated[
        Optional[bool], Field(description="Enable or disable the interface.")
    ] = None
    lag: Annotated[Optional[InterfaceStateSpecLag], Field(title="Lag")] = None
    members: Annotated[
        List[InterfaceStateSpecMember],
        Field(description="List of members on which to monitor state for"),
    ]
    role: Annotated[
        Optional[Literal["isl", "edge", "loopback"]],
        Field(
            description='Role of this interface. This is used to calculate severity of alarms. [default="edge"]'
        ),
    ] = "edge"


InterfaceStateDeletedResourceEntry = BreakoutDeletedResourceEntry


class InterfaceStateDeletedResources(
    RootModel[List[InterfaceStateDeletedResourceEntry]]
):
    root: List[InterfaceStateDeletedResourceEntry]


InterfaceStateMetadata = BreakoutMetadata


InterfaceDeletedResourceEntry = BreakoutDeletedResourceEntry


class InterfaceDeletedResources(RootModel[List[InterfaceDeletedResourceEntry]]):
    root: List[InterfaceDeletedResourceEntry]


InterfaceMetadata = BreakoutMetadata


class AppGroup(BaseModel):
    apiVersion: Optional[str] = None
    kind: Optional[str] = None
    name: Optional[str] = None
    preferredVersion: Optional[AppGroupVersion] = None
    versions: Optional[List[AppGroupVersion]] = None


class ResourceHistory(RootModel[List[ResourceHistoryEntry]]):
    root: List[ResourceHistoryEntry]


class Status(BaseModel):
    apiVersion: Optional[str] = None
    details: Optional[StatusDetails] = None
    kind: Optional[str] = None
    string: Optional[str] = None


class Breakout(BaseModel):
    """
    Breakout is the Schema for the breakouts API
    """

    apiVersion: str
    kind: str
    metadata: BreakoutMetadata
    spec: Annotated[
        BreakoutSpec,
        Field(
            description="Breakout allows for the configuration of interface breakouts on specified Nodes. This resource specifies the Nodes, parent Interfaces, the number of breakout channels, and the speed of each channel.",
            title="Specification",
        ),
    ]
    status: Annotated[
        Optional[Dict[str, Any]],
        Field(
            description="BreakoutStatus defines the observed state of Breakout",
            title="Status",
        ),
    ] = None


class BreakoutList(BaseModel):
    """
    BreakoutList is a list of breakouts
    """

    apiVersion: str
    items: Optional[List[Breakout]] = None
    kind: str


class Interface(BaseModel):
    """
    Interface is the Schema for the interfaces API
    """

    apiVersion: str
    kind: str
    metadata: InterfaceMetadata
    spec: Annotated[
        InterfaceSpec,
        Field(
            description="Interface allows for the configuration of various interface properties such as enabling/disabling the interface, setting descriptions, specifying interface types (e.g., LAG, interface, loopback), configuring VLAN encapsulation, and setting Ethernet or LAG-specific options.",
            title="Specification",
        ),
    ]
    status: Annotated[Optional[InterfaceStatus], Field(title="Status")] = None


class InterfaceList(BaseModel):
    """
    InterfaceList is a list of interfaces
    """

    apiVersion: str
    items: Optional[List[Interface]] = None
    kind: str


class InterfaceState(BaseModel):
    """
    InterfaceState is the Schema for the interfacestates API
    """

    apiVersion: str
    kind: str
    metadata: InterfaceStateMetadata
    spec: Annotated[InterfaceStateSpec, Field(title="Specification")]
    status: Annotated[
        Optional[Dict[str, Any]],
        Field(
            description="InterfaceStateStatus defines the observed state of Interface",
            title="Status",
        ),
    ] = None


class InterfaceStateList(BaseModel):
    """
    InterfaceStateList is a list of interfacestates
    """

    apiVersion: str
    items: Optional[List[InterfaceState]] = None
    kind: str
