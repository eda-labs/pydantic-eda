# generated by datamodel-codegen:
#   filename:  appstore.json

from __future__ import annotations

from typing import Annotated, Any, Dict, List, Literal, Optional

from pydantic import AwareDatetime, BaseModel, Field, RootModel


class AppGroupVersion(BaseModel):
    groupVersion: Optional[str] = None
    version: Optional[str] = None


class ErrorIndex(BaseModel):
    index: Optional[int] = None


class ErrorItem(BaseModel):
    error: Optional[Dict[str, Any]] = None
    type: Optional[str] = None


class ErrorResponse(BaseModel):
    """
    Generic error response for REST APIs
    """

    code: Annotated[
        int, Field(description="the numeric HTTP error code for the response.")
    ]
    details: Annotated[
        Optional[str], Field(description="The optional details of the error response.")
    ] = None
    dictionary: Annotated[
        Optional[Dict[str, Any]],
        Field(
            description='Dictionary/map of associated data/information relevant to the error.\nThe error "message" may contain {{name}} escapes that should be substituted\nwith information from this dictionary.'
        ),
    ] = None
    domain: Annotated[
        Optional[str],
        Field(
            description='The "domain" for the error.  If empty, it is an EDA\ncore error.  Alternatively it can be an EDA application\n"apiVersion" value (e.g. interfaces.eda.nokia.com/v1alpha1)\nindicating that the error is specific to that application.\nThe domain gives the receiver information that they can use\nto help them interpret the "internal" error code value, or\nto find an internationalization translation for the message.'
        ),
    ] = None
    errors: Annotated[
        Optional[List[ErrorItem]],
        Field(
            description="Collection of errors in cases where more than one exists. This needs to be\nflexible so we can support multiple formats"
        ),
    ] = None
    index: Optional[ErrorIndex] = None
    internal: Annotated[
        Optional[int],
        Field(
            description="Internal error code in cases where we don't have an array of errors"
        ),
    ] = None
    message: Annotated[
        str, Field(description="The basic text error message for the error response.")
    ]
    ref: Annotated[
        Optional[str],
        Field(
            description="Reference to the error source. Should typically be the URI of the request"
        ),
    ] = None
    type: Annotated[
        Optional[str],
        Field(
            description="URI pointing at a document that describes the error and mitigation steps\nIf there is no document, point to the RFC for the HTTP error code"
        ),
    ] = None


class K8SPatchOp(BaseModel):
    from_: Annotated[Optional[str], Field(alias="from")] = None
    op: str
    path: str
    value: Optional[Dict[str, Any]] = None
    x_permissive: Annotated[Optional[bool], Field(alias="x-permissive")] = None


class Patch(RootModel[List[K8SPatchOp]]):
    root: List[K8SPatchOp]


class Resource(BaseModel):
    kind: Optional[str] = None
    name: Optional[str] = None
    namespaced: Optional[bool] = None
    readOnly: Optional[bool] = None
    singularName: Optional[str] = None
    uiCategory: Optional[str] = None


class ResourceHistoryEntry(BaseModel):
    author: Optional[str] = None
    changeType: Optional[str] = None
    commitTime: Optional[AwareDatetime] = None
    hash: Optional[str] = None
    message: Optional[str] = None
    transactionId: Optional[int] = None


class ResourceList(BaseModel):
    apiVersion: Optional[str] = None
    groupVersion: Optional[str] = None
    kind: Optional[str] = None
    resources: Optional[List[Resource]] = None


class StatusDetails(BaseModel):
    group: Optional[str] = None
    kind: Optional[str] = None
    name: Optional[str] = None


class TopoAttrMetadata(BaseModel):
    type: Optional[str] = None
    ui_description: Optional[str] = None
    ui_description_key: Optional[str] = None
    ui_name: Optional[str] = None
    ui_name_key: Optional[str] = None


class TopoLinkEndpoint(BaseModel):
    endpoint: Optional[str] = None
    node: Optional[str] = None
    node_key: Optional[str] = None


class TopoNodeGrouping(BaseModel):
    group: Optional[str] = None
    tier: Optional[int] = None


class TopoOverlayEndpointState(BaseModel):
    state: Optional[int] = None


TopoOverlayLinkState = TopoOverlayEndpointState


class TopoOverlayNodeState(BaseModel):
    badges: Optional[List[int]] = None
    state: Optional[int] = None


class TopoSchema(BaseModel):
    group: Optional[str] = None
    kind: Optional[str] = None
    version: Optional[str] = None


class UIResult(RootModel[str]):
    root: str


class WorkflowGetInputsRespElem(BaseModel):
    ackPrompt: Optional[str] = None
    group: str
    kind: str
    name: str
    namespace: Optional[str] = None
    schemaPrompt: Optional[Dict[str, Any]] = None
    version: str


class WorkflowId(BaseModel):
    id: Annotated[
        Optional[int],
        Field(
            description="A workflow identifier; these are assigned by the system to a posted workflow."
        ),
    ] = None


class WorkflowIdentifier(BaseModel):
    group: str
    kind: str
    name: str
    namespace: Optional[str] = None
    version: str


class WorkflowInputDataElem(BaseModel):
    ack: Annotated[
        Optional[bool], Field(description="acknowledge or reject the input request")
    ] = None
    input: Annotated[
        Optional[Dict[str, Any]],
        Field(description="provide a json blob to the workflow"),
    ] = None
    subflow: Optional[WorkflowIdentifier] = None


class AppInstallerSpecAppVersion(BaseModel):
    """
    Version of the App that is to be installed.
    """

    type: Annotated[
        Optional[Literal["semver", "commit"]],
        Field(
            description="The version type of the App. Currently supported: semver, commit.\nDefault is semver.",
            title="Type",
        ),
    ] = "semver"
    value: Annotated[
        str,
        Field(
            description='The version of the App.\nIf the VersionType is set to semver,\nthen the semantic version of the git tag in the form of "apps/<appname>/<semver>" is used.\nIf the VersionType is set to commit,\nthen the commit reference (e.g. git hash) is expected.',
            title="Value",
        ),
    ]


class AppInstallerSpecApp(BaseModel):
    appId: Annotated[
        str,
        Field(
            description="AppID of the app, which is the unique identifier of an app. It should be equal to the group of the app.",
            title="App ID",
        ),
    ]
    appSettings: Annotated[
        Optional[Any],
        Field(
            description="AppSettings defines a list of variables and their value. Only variables that are customised need to be mentioned.\nIf AppSettings are not again mentioned on upgrade, values will remain as is.",
            title="App Settings",
        ),
    ] = None
    catalog: Annotated[
        str,
        Field(
            description="Catalog of the app to be installed.\nThis is where app manifest is retrieved from, along with some other metadata.",
            title="Catalog",
        ),
    ]
    version: Annotated[
        AppInstallerSpecAppVersion,
        Field(
            description="Version of the App that is to be installed.", title="Version"
        ),
    ]


class AppInstallerSpec(BaseModel):
    apps: Annotated[
        List[AppInstallerSpecApp],
        Field(description="Apps are the input apps to the installer.", title="Apps"),
    ]
    autoProcessRequirements: Annotated[
        Optional[List[str]],
        Field(
            description="AutoProcessRequirements tells the installer what it can do w.r.t. the requirements of an app.\nCurrently only 'strict' is supported.",
            title="Auto Process Requirements",
        ),
    ] = None
    operation: Annotated[
        Literal["install", "delete"],
        Field(
            description="Operation is the installing operation.\nCurrently supported are 'install', 'delete'.",
            title="Operation",
        ),
    ]


class AppInstallerStatus(BaseModel):
    error: Annotated[Optional[str], Field(title="Error")] = None
    id: Annotated[
        Optional[int],
        Field(
            description="ID is the workflow ID that can be used to get more information on.",
            title="ID",
        ),
    ] = None
    result: Annotated[str, Field(title="Result")]


class AppInstallerMetadata(BaseModel):
    annotations: Optional[Dict[str, str]] = None
    labels: Optional[Dict[str, str]] = None
    name: Annotated[
        str,
        Field(
            max_length=253,
            pattern="^[a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*$",
        ),
    ]


class CatalogSpec(BaseModel):
    """
    CatalogSpec defines the desired state of a Catalog.
    """

    authSecretRef: Annotated[
        Optional[str],
        Field(
            description="AuthSecretRef is the authentication secret reference, used for authentication.\nMust be in the same namespace as the catalog.",
            title="Authentication Secret Reference",
        ),
    ] = None
    description: Annotated[
        Optional[str],
        Field(
            description="Description is an optional short description of the catalog.",
            max_length=70,
            title="Description",
        ),
    ] = None
    refreshInterval: Annotated[
        Optional[int],
        Field(
            description="RefreshInterval tells the controller how often it should check the remote catalog for new updates, in seconds.\nDefault is 180 seconds. Minimum is 30 seconds for production environments; 10 seconds for test environments.",
            title="Refresh Interval",
        ),
    ] = 180
    remoteType: Annotated[
        Optional[Literal["git"]],
        Field(
            description="RemoteType type of the catalog, only 'git' is supported at the moment.",
            title="Remote Type",
        ),
    ] = "git"
    remoteURL: Annotated[
        Optional[str],
        Field(
            description="RemoteURL is the HTTP(S) remote URL of the catalog. Supported URI schemes: 'https://' and 'http://'.\nDefault is HTTPS if no scheme is given.",
            title="Remote URL",
        ),
    ] = None
    skipTLSVerify: Annotated[
        Optional[bool],
        Field(
            description="SkipTLSVerify skips the validity check for the server's certificate. This will make HTTPS connections insecure.",
            title="Skip TLS Verify",
        ),
    ] = False
    title: Annotated[
        Optional[str],
        Field(
            description="Title is an UI-friendly name for the catalog.",
            max_length=50,
            title="Title",
        ),
    ] = None


class CatalogStatus(BaseModel):
    """
    CatalogStatus defines the observed state of a Catalog.
    """

    error: Annotated[
        Optional[str],
        Field(
            description="Error denotes the last error that was encountered by the controller.",
            title="Error",
        ),
    ] = None
    lastRefreshTime: Annotated[
        Optional[AwareDatetime],
        Field(
            description="LastRefreshTime is the last attempt to refresh the catalog cache by the controller.",
            title="Last Refresh Time",
        ),
    ] = None
    operational: Annotated[
        Optional[bool],
        Field(
            description="Operational reports whether the catalog remote is operational.",
            title="Operational",
        ),
    ] = False


class CatalogDeletedResourceEntry(BaseModel):
    commitTime: Optional[AwareDatetime] = None
    hash: Optional[str] = None
    name: Optional[str] = None
    transactionId: Optional[int] = None


class CatalogDeletedResources(RootModel[List[CatalogDeletedResourceEntry]]):
    root: List[CatalogDeletedResourceEntry]


CatalogMetadata = AppInstallerMetadata


class RegistrySpec(BaseModel):
    """
    RegistrySpec defines the desired state of a Registry
    """

    authSecretRef: Annotated[
        Optional[str],
        Field(
            description="AuthSecretRef is the authentication secret reference, used for authentication.\nMust be in the same namespace as the catalog.",
            title="Authentication Secret Reference",
        ),
    ] = None
    mirror: Annotated[
        Optional[str],
        Field(
            description="Mirror registry of the original remote registry.\nApp store will use the mirror instead of the original registry that is referenced by a catalog.",
            title="Mirror",
        ),
    ] = None
    remoteURL: Annotated[
        str,
        Field(
            description="RemoteURL is the remote URL of the registry. Supported URI schemes: 'https://' and 'http://'.\n\tDefault is HTTPS if no scheme is given.",
            title="Remote URL",
        ),
    ]
    skipTLSVerify: Annotated[
        Optional[bool],
        Field(
            description="Skip TLS Verification on connection", title="Skip TLS Verify"
        ),
    ] = False
    title: Annotated[
        Optional[str],
        Field(
            description="Title is an UI-friendly name for the catalog.",
            max_length=50,
            title="Title",
        ),
    ] = None


class RegistryStatus(BaseModel):
    """
    RegistryStatus defines the observed state of Registry
    """

    error: Annotated[
        str,
        Field(
            description="Error denotes the last error that was encountered by the controller.",
            title="Error",
        ),
    ]
    reachable: Annotated[
        Optional[bool],
        Field(
            description="Reachable indicates if the registry is reachable.",
            title="Reachable",
        ),
    ] = False


RegistryDeletedResourceEntry = CatalogDeletedResourceEntry


class RegistryDeletedResources(RootModel[List[RegistryDeletedResourceEntry]]):
    root: List[RegistryDeletedResourceEntry]


RegistryMetadata = AppInstallerMetadata


class AppGroup(BaseModel):
    apiVersion: Optional[str] = None
    kind: Optional[str] = None
    name: Optional[str] = None
    preferredVersion: Optional[AppGroupVersion] = None
    versions: Optional[List[AppGroupVersion]] = None


class ResourceHistory(RootModel[List[ResourceHistoryEntry]]):
    root: List[ResourceHistoryEntry]


class Status(BaseModel):
    apiVersion: Optional[str] = None
    details: Optional[StatusDetails] = None
    kind: Optional[str] = None
    string: Optional[str] = None


class TopoElemMetadata(BaseModel):
    attributes: Optional[Dict[str, TopoAttrMetadata]] = None
    schema_: Annotated[Optional[TopoSchema], Field(alias="schema")] = None
    subtitle: Optional[str] = None
    subtitle_key: Optional[str] = None


class TopoOverlayEndpoint(BaseModel):
    attributes: Optional[Dict[str, Dict[str, Any]]] = None
    cr_name: Optional[str] = None
    labels: Optional[Dict[str, str]] = None
    name: Optional[str] = None
    namespace: Optional[str] = None
    overlays: Optional[Dict[str, TopoOverlayEndpointState]] = None
    schema_: Annotated[Optional[TopoSchema], Field(alias="schema")] = None
    state: Optional[int] = None
    ui_name: Optional[str] = None


class TopoOverlayLink(BaseModel):
    attributes: Optional[Dict[str, Dict[str, Any]]] = None
    cr_name: Optional[str] = None
    endpoint_a: Optional[TopoLinkEndpoint] = None
    endpoint_a_details: Optional[TopoOverlayEndpoint] = None
    endpoint_b: Optional[TopoLinkEndpoint] = None
    endpoint_b_details: Optional[TopoOverlayEndpoint] = None
    key: Optional[str] = None
    labels: Optional[Dict[str, str]] = None
    name: Optional[str] = None
    namespace: Optional[str] = None
    overlays: Optional[Dict[str, TopoOverlayLinkState]] = None
    schema_: Annotated[Optional[TopoSchema], Field(alias="schema")] = None
    state: Optional[int] = None
    ui_name: Optional[str] = None


class TopoOverlayNode(BaseModel):
    attributes: Optional[Dict[str, Dict[str, Any]]] = None
    badges: Optional[List[int]] = None
    cr_name: Optional[str] = None
    grouping: Optional[TopoNodeGrouping] = None
    key: Optional[str] = None
    labels: Optional[Dict[str, str]] = None
    name: Optional[str] = None
    namespace: Optional[str] = None
    overlays: Optional[Dict[str, TopoOverlayNodeState]] = None
    schema_: Annotated[Optional[TopoSchema], Field(alias="schema")] = None
    state: Optional[int] = None
    ui_name: Optional[str] = None


class Topology(BaseModel):
    endpoints: Optional[TopoElemMetadata] = None
    group: Optional[str] = None
    grouping: Optional[TopoSchema] = None
    links: Optional[TopoElemMetadata] = None
    name: Optional[str] = None
    nodes: Optional[TopoElemMetadata] = None
    ui_description: Optional[str] = None
    ui_description_key: Optional[str] = None
    ui_name: Optional[str] = None
    ui_name_key: Optional[str] = None
    version: Optional[str] = None


class WorkflowInputData(RootModel[List[WorkflowInputDataElem]]):
    root: List[WorkflowInputDataElem]


class AppInstaller(BaseModel):
    """
    AppInstaller is the Schema for the appinstallers API
    """

    apiVersion: Annotated[str, Field(pattern="^appstore\\.eda\\.nokia\\.com/v1$")]
    kind: Annotated[str, Field(pattern="^AppInstaller$")]
    metadata: AppInstallerMetadata
    spec: Annotated[AppInstallerSpec, Field(title="Specification")]
    status: Annotated[Optional[AppInstallerStatus], Field(title="Status")] = None


class AppInstallerList(BaseModel):
    """
    AppInstallerList is a list of appinstallers
    """

    apiVersion: str
    items: Optional[List[AppInstaller]] = None
    kind: str


class Catalog(BaseModel):
    """
    Catalog is the Schema for the catalogs API
    """

    apiVersion: Annotated[str, Field(pattern="^appstore\\.eda\\.nokia\\.com/v1$")]
    kind: Annotated[str, Field(pattern="^Catalog$")]
    metadata: CatalogMetadata
    spec: Annotated[
        CatalogSpec,
        Field(
            description="CatalogSpec defines the desired state of a Catalog.",
            title="Specification",
        ),
    ]
    status: Annotated[
        Optional[CatalogStatus],
        Field(
            description="CatalogStatus defines the observed state of a Catalog.",
            title="Status",
        ),
    ] = None


class CatalogList(BaseModel):
    """
    CatalogList is a list of catalogs
    """

    apiVersion: str
    items: Optional[List[Catalog]] = None
    kind: str


class Registry(BaseModel):
    """
    Registry is the Schema for the registries API
    """

    apiVersion: Annotated[str, Field(pattern="^appstore\\.eda\\.nokia\\.com/v1$")]
    kind: Annotated[str, Field(pattern="^Registry$")]
    metadata: RegistryMetadata
    spec: Annotated[
        RegistrySpec,
        Field(
            description="RegistrySpec defines the desired state of a Registry",
            title="Specification",
        ),
    ]
    status: Annotated[
        Optional[RegistryStatus],
        Field(
            description="RegistryStatus defines the observed state of Registry",
            title="Status",
        ),
    ] = None


class RegistryList(BaseModel):
    """
    RegistryList is a list of registries
    """

    apiVersion: str
    items: Optional[List[Registry]] = None
    kind: str


class OverlayState(BaseModel):
    links: Optional[Dict[str, TopoOverlayLink]] = None
    nodes: Optional[Dict[str, TopoOverlayNode]] = None


class ResourceTopology(BaseModel):
    topology: Optional[OverlayState] = None
    topologyMetadata: Optional[Topology] = None
