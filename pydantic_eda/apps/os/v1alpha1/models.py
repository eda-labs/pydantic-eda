# generated by datamodel-codegen:
#   filename:  os.json

from __future__ import annotations

from typing import Annotated, Any, Dict, List, Literal, Optional

from pydantic import AwareDatetime, BaseModel, Field, RootModel


class ErrorIndex(BaseModel):
    index: Optional[int] = None


class ErrorItem(BaseModel):
    error: Optional[Dict[str, Any]] = None
    type: Optional[str] = None


class ErrorResponse(BaseModel):
    """
    Generic error response for REST APIs
    """

    code: Annotated[
        int, Field(description="the numeric HTTP error code for the response.")
    ]
    details: Annotated[
        Optional[str], Field(description="The optional details of the error response.")
    ] = None
    dictionary: Annotated[
        Optional[Dict[str, Any]],
        Field(
            description='Dictionary/map of associated data/information relevant to the error.\nThe error "message" may contain {{name}} escapes that should be substituted\nwith information from this dictionary.'
        ),
    ] = None
    domain: Annotated[
        Optional[str],
        Field(
            description='The "domain" for the error.  If empty, it is an EDA\ncore error.  Alternatively it can be an EDA application\n"apiVersion" value (e.g. interfaces.eda.nokia.com/v1alpha1)\nindicating that the error is specific to that application.\nThe domain gives the receiver information that they can use\nto help them interpret the "internal" error code value, or\nto find an internationalization translation for the message.'
        ),
    ] = None
    errors: Annotated[
        Optional[List[ErrorItem]],
        Field(
            description="Collection of errors in cases where more than one exists. This needs to be\nflexible so we can support multiple formats"
        ),
    ] = None
    index: Optional[ErrorIndex] = None
    internal: Annotated[
        Optional[int],
        Field(
            description="Internal error code in cases where we don't have an array of errors"
        ),
    ] = None
    message: Annotated[
        str, Field(description="The basic text error message for the error response.")
    ]
    ref: Annotated[
        Optional[str],
        Field(
            description="Reference to the error source. Should typically be the URI of the request"
        ),
    ] = None
    type: Annotated[
        Optional[str],
        Field(
            description="URI pointing at a document that describes the error and mitigation steps\nIf there is no document, point to the RFC for the HTTP error code"
        ),
    ] = None


class WorkflowGetInputsRespElem(BaseModel):
    ackPrompt: Optional[str] = None
    group: str
    kind: str
    name: str
    namespace: Optional[str] = None
    schemaPrompt: Optional[Dict[str, Any]] = None
    version: str


class WorkflowId(BaseModel):
    id: Annotated[
        Optional[int],
        Field(
            description="A workflow identifier; these are assigned by the system to a posted workflow."
        ),
    ] = None


class WorkflowIdentifier(BaseModel):
    group: str
    kind: str
    name: str
    namespace: Optional[str] = None
    version: str


class WorkflowInputDataElem(BaseModel):
    ack: Annotated[
        Optional[bool], Field(description="acknowledge or reject the input request")
    ] = None
    input: Annotated[
        Optional[Dict[str, Any]],
        Field(description="provide a json blob to the workflow"),
    ] = None
    subflow: Optional[WorkflowIdentifier] = None


class DeployImageSpecChecks(BaseModel):
    """
    Configure pre and post checks.
    """

    checks: Annotated[
        Optional[List[Literal["Interface", "DefaultBGP", "PingISL", "PingSystem"]]],
        Field(
            description="Checks to run before (pre) and after (post) any image changes.\nIf none are specified, a default set of checks will be run.",
            title="Checks to Run",
        ),
    ] = None
    force: Annotated[
        Optional[bool],
        Field(
            description="Ignore result of pre and post checks, do not prompt on failure.",
            title="Force",
        ),
    ] = None
    skip: Annotated[
        Optional[bool],
        Field(
            description="Do not run any checks pre or post image change.",
            title="Skip Checks",
        ),
    ] = None


class DeployImageSpecDrains(BaseModel):
    """
    Configure drains to gracefully drain traffic away from nodes before imaging.
    """

    minimumWaitTimeSeconds: Annotated[
        Optional[int],
        Field(
            description="Seconds to wait before rebooting a node after it has been drained.\nThis is used to allow time for any traffic to drain away from the node before reboot.",
            title="Minimum Wait Time",
        ),
    ] = 60
    skip: Annotated[
        Optional[bool],
        Field(
            description="Do not run any drain operations. Nodes will be rebooted without attempting to gracefully drain them.",
            title="Skip Drains",
        ),
    ] = None


class DeployImageSpecTranch(BaseModel):
    name: Annotated[
        Optional[str],
        Field(
            description="Name of the tranche.\nThis is used to identify the tranche in the UI and in logs.",
            title="Name",
        ),
    ] = None
    nodeSelectors: Annotated[
        Optional[List[str]],
        Field(
            description='Node Selectors is a list of node selectors to select nodes to deploy images on in this tranche.\nThis matches labels on TopoNode resources, including those TopoNodes in the list of nodes that will be imaged.\nThis is a list of label expressions, e.g. ["eda.nokia.com/role=leaf"].',
            title="Node Selectors",
        ),
    ] = None


class DeployImageSpec(BaseModel):
    """
    Upgrade / downgrade images on targets.
    This workflow can be used directly on a target or list of targets, or with selectors to select targets through labels.
    It also supports tranches, which are groups of targets that can be upgraded together.
    By default a set of checks are run before and after the image change, but this can be controlled via the checks field.
    It also supports canaries, which are upgraded before any other targets.
    """

    canaries: Annotated[
        Optional[List[str]],
        Field(
            description='List of node selectors to use to match canary nodes.\nThis matches labels on TopoNode resources, including those TopoNodes in the list of nodes that will be imaged.\nCanary nodes are upgraded before any other nodes, and are used to test images before broader roll out.\nThis is a list of label expressions, e.g. ["eda.nokia.com/role=canary"].',
            title="Canaries",
        ),
    ] = None
    checks: Annotated[
        Optional[DeployImageSpecChecks],
        Field(description="Configure pre and post checks.", title="Checks"),
    ] = None
    drains: Annotated[
        Optional[DeployImageSpecDrains],
        Field(
            description="Configure drains to gracefully drain traffic away from nodes before imaging.",
            title="Drains",
        ),
    ] = None
    nodeProfile: Annotated[
        str,
        Field(
            description="Destination profile to use for imaging.\nThis profile contains the image to deploy, and other configuration for the node.",
            title="Node Profile",
        ),
    ]
    nodeSelectors: Annotated[
        Optional[List[str]],
        Field(
            description='List of node selectors to select nodes to deploy images on.\nThis matches labels on TopoNode resources, including those TopoNodes in the list of nodes that will be imaged.\nIf no nodes are specified, and no node selectors are specified, all nodes in the given namespace will be selected.\nThis is a list of label expressions, e.g. ["eda.nokia.com/role=leaf"].',
            title="Node Selectors",
        ),
    ] = None
    nodes: Annotated[
        Optional[List[str]],
        Field(description="List of nodes to deploy images on.", title="Nodes"),
    ] = None
    prompt: Annotated[
        Optional[List[Literal["AfterPreChecks", "AfterPostChecks"]]],
        Field(
            description="Control when to prompt the user for input.\nIf any pre or post checks fail, the user will be prompted for input, but this may be used to prompt even if they're successful.",
            title="Prompt",
        ),
    ] = None
    tranches: Annotated[
        Optional[List[DeployImageSpecTranch]],
        Field(
            description="List of tranches to use for imaging.\nA tranche is a list of node selectors, and a name.\nTranches are upgraded in order, sequentially.",
            title="Tranches",
        ),
    ] = None


class DeployImageStatusDetail(BaseModel):
    drainedTime: Annotated[
        Optional[AwareDatetime],
        Field(
            description="The time when the node was drained.\nThis is the time when the node was drained before the imaging operation.",
            title="Drained Time",
        ),
    ] = None
    newNodeProfile: Annotated[
        Optional[str],
        Field(description="The new profile of the node.", title="New Node Profile"),
    ] = None
    newVersion: Annotated[
        Optional[str],
        Field(description="The new version of the node.", title="New Version"),
    ] = None
    node: Annotated[
        Optional[str],
        Field(description="The name of the node this result is for.", title="Node"),
    ] = None
    postCheckSuccessful: Annotated[
        Optional[bool],
        Field(
            description="Indicates if post checks were successful for this node.\nThis is true if all post checks passed, false if any post checks failed.",
            title="Post Check Successful",
        ),
    ] = None
    preCheckSuccessful: Annotated[
        Optional[bool],
        Field(
            description="Indicates if pre checks were successful for this node.\nThis is true if all pre checks passed, false if any pre checks failed.",
            title="Pre Check Successful",
        ),
    ] = None
    previousNodeProfile: Annotated[
        Optional[str],
        Field(
            description="The previous profile of the node.\nThis is the node profile that was running before the imaging operation.",
            title="Previous Node Profile",
        ),
    ] = None
    previousVersion: Annotated[
        Optional[str],
        Field(
            description="The previous version of the node.\nThis is the version of the image that was running before the imaging operation.",
            title="Previous Version",
        ),
    ] = None
    rebootRecoveryTime: Annotated[
        Optional[AwareDatetime],
        Field(
            description="The time when the node was recovered after reboot.\nThis is the time when the node was recovered after the imaging operation.",
            title="Reboot Recovery Time",
        ),
    ] = None
    rebootTime: Annotated[
        Optional[AwareDatetime],
        Field(
            description="The time when the node was rebooted.\nThis is the time when the node was rebooted during the imaging operation.",
            title="Reboot Time",
        ),
    ] = None
    success: Annotated[
        Optional[bool],
        Field(
            description="Indicates if the imaging operation was successful for this node.\nThis is true if the imaging operation was successful, false if it failed.",
            title="Success",
        ),
    ] = None
    undrainedTime: Annotated[
        Optional[AwareDatetime],
        Field(
            description="The time when the node was undrained.\nThis is the time when the node was undrained after the imaging operation.",
            title="Undrained Time",
        ),
    ] = None


class DeployImageStatus(BaseModel):
    """
    Status of the imaging operation.
    """

    details: Annotated[
        Optional[List[DeployImageStatusDetail]],
        Field(description="Per-node image deployment details.", title="Details"),
    ] = None
    firstNodeDrained: Annotated[
        Optional[AwareDatetime],
        Field(
            description="The time when the first node was drained.",
            title="First Node Drained",
        ),
    ] = None
    firstNodeRebooted: Annotated[
        Optional[AwareDatetime],
        Field(
            description="The time when the first node was rebooted.",
            title="First Node Rebooted",
        ),
    ] = None
    lastNodeRebootRecovered: Annotated[
        Optional[AwareDatetime],
        Field(
            description="The time when the last node recovered post reboot.",
            title="Last Node Recovered",
        ),
    ] = None
    lastNodeUndrained: Annotated[
        Optional[AwareDatetime],
        Field(
            description="The time when the last node was undrained.",
            title="Last Node Undrained",
        ),
    ] = None
    result: Annotated[
        Literal["Success", "Failed", "PartialSuccess"],
        Field(
            description='Result is the overall result of the image operation.\nIt can be one of the following values:\n- "Success": All images were successfully deployed.\n- "Failed": No images were successfully deployed.\n- "PartialSuccess": Some images were successfully deployed, but not all.',
            title="Result",
        ),
    ]


class DeployImageMetadata(BaseModel):
    annotations: Optional[Dict[str, str]] = None
    labels: Optional[Dict[str, str]] = None
    name: Annotated[
        str,
        Field(
            max_length=253,
            pattern="^[a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*$",
        ),
    ]
    namespace: str


class WorkflowInputData(RootModel[List[WorkflowInputDataElem]]):
    root: List[WorkflowInputDataElem]


class DeployImage(BaseModel):
    """
    DeployImage is the Schema for the deployimages API
    """

    apiVersion: Annotated[str, Field(pattern="^os\\.eda\\.nokia\\.com/v1alpha1$")]
    kind: Annotated[str, Field(pattern="^DeployImage$")]
    metadata: DeployImageMetadata
    spec: Annotated[
        DeployImageSpec,
        Field(
            description="Upgrade / downgrade images on targets.\nThis workflow can be used directly on a target or list of targets, or with selectors to select targets through labels.\nIt also supports tranches, which are groups of targets that can be upgraded together.\nBy default a set of checks are run before and after the image change, but this can be controlled via the checks field.\nIt also supports canaries, which are upgraded before any other targets.",
            title="Specification",
        ),
    ]
    status: Annotated[
        Optional[DeployImageStatus],
        Field(description="Status of the imaging operation.", title="Status"),
    ] = None


class DeployImageList(BaseModel):
    """
    DeployImageList is a list of deployimages
    """

    apiVersion: str
    items: Optional[List[DeployImage]] = None
    kind: str
