# generated by datamodel-codegen:
#   filename:  core.json

from __future__ import annotations

from datetime import date
from typing import Annotated, Any, Dict, List, Literal, Optional

from pydantic import AwareDatetime, BaseModel, Field, RootModel, SecretStr


class AppGroupVersion(BaseModel):
    groupVersion: Optional[str] = None
    version: Optional[str] = None


class ErrorIndex(BaseModel):
    index: Optional[int] = None


class ErrorItem(BaseModel):
    error: Optional[Dict[str, Any]] = None
    type: Optional[str] = None


class ErrorResponse(BaseModel):
    """
    Generic error response for REST APIs
    """

    code: Annotated[
        int, Field(description="the numeric HTTP error code for the response.")
    ]
    details: Annotated[
        Optional[str], Field(description="The optional details of the error response.")
    ] = None
    dictionary: Annotated[
        Optional[Dict[str, Any]],
        Field(
            description='Dictionary/map of associated data/information relevant to the error.\nThe error "message" may contain {{name}} escapes that should be substituted\nwith information from this dictionary.'
        ),
    ] = None
    domain: Annotated[
        Optional[str],
        Field(
            description='The "domain" for the error.  If empty, it is an EDA\ncore error.  Alternatively it can be an EDA application\n"apiVersion" value (e.g. interfaces.eda.nokia.com/v1alpha1)\nindicating that the error is specific to that application.\nThe domain gives the receiver information that they can use\nto help them interpret the "internal" error code value, or\nto find an internationalization translation for the message.'
        ),
    ] = None
    errors: Annotated[
        Optional[List[ErrorItem]],
        Field(
            description="Collection of errors in cases where more than one exists. This needs to be\nflexible so we can support multiple formats"
        ),
    ] = None
    index: Optional[ErrorIndex] = None
    internal: Annotated[
        Optional[int],
        Field(
            description="Internal error code in cases where we don't have an array of errors"
        ),
    ] = None
    message: Annotated[
        str, Field(description="The basic text error message for the error response.")
    ]
    ref: Annotated[
        Optional[str],
        Field(
            description="Reference to the error source. Should typically be the URI of the request"
        ),
    ] = None
    type: Annotated[
        Optional[str],
        Field(
            description="URI pointing at a document that describes the error and mitigation steps\nIf there is no document, point to the RFC for the HTTP error code"
        ),
    ] = None


class K8SPatchOp(BaseModel):
    from_: Annotated[Optional[str], Field(alias="from")] = None
    op: str
    path: str
    value: Optional[Dict[str, Any]] = None
    x_permissive: Annotated[Optional[bool], Field(alias="x-permissive")] = None


class Patch(RootModel[List[K8SPatchOp]]):
    root: List[K8SPatchOp]


class Resource(BaseModel):
    kind: Optional[str] = None
    name: Optional[str] = None
    namespaced: Optional[bool] = None
    readOnly: Optional[bool] = None
    singularName: Optional[str] = None
    uiCategory: Optional[str] = None


class ResourceHistoryEntry(BaseModel):
    author: Optional[str] = None
    changeType: Optional[str] = None
    commitTime: Optional[AwareDatetime] = None
    hash: Optional[str] = None
    message: Optional[str] = None
    transactionId: Optional[int] = None


class ResourceList(BaseModel):
    apiVersion: Optional[str] = None
    groupVersion: Optional[str] = None
    kind: Optional[str] = None
    resources: Optional[List[Resource]] = None


class StatusDetails(BaseModel):
    group: Optional[str] = None
    kind: Optional[str] = None
    name: Optional[str] = None


class TopoAttrMetadata(BaseModel):
    type: Optional[str] = None
    ui_description: Optional[str] = None
    ui_description_key: Optional[str] = None
    ui_name: Optional[str] = None
    ui_name_key: Optional[str] = None


class TopoLinkEndpoint(BaseModel):
    endpoint: Optional[str] = None
    node: Optional[str] = None
    node_key: Optional[str] = None


class TopoNodeGrouping(BaseModel):
    group: Optional[str] = None
    tier: Optional[int] = None


class TopoOverlayEndpointState(BaseModel):
    state: Optional[int] = None


TopoOverlayLinkState = TopoOverlayEndpointState


class TopoOverlayNodeState(BaseModel):
    badges: Optional[List[int]] = None
    state: Optional[int] = None


class TopoSchema(BaseModel):
    group: Optional[str] = None
    kind: Optional[str] = None
    version: Optional[str] = None


class UIResult(RootModel[str]):
    root: str


class WorkflowGetInputsRespElem(BaseModel):
    ackPrompt: Optional[str] = None
    group: str
    kind: str
    name: str
    namespace: Optional[str] = None
    schemaPrompt: Optional[Dict[str, Any]] = None
    version: str


class WorkflowId(BaseModel):
    id: Annotated[
        Optional[int],
        Field(
            description="A workflow identifier; these are assigned by the system to a posted workflow."
        ),
    ] = None


class WorkflowIdentifier(BaseModel):
    group: str
    kind: str
    name: str
    namespace: Optional[str] = None
    version: str


class WorkflowInputDataElem(BaseModel):
    ack: Annotated[
        Optional[bool], Field(description="acknowledge or reject the input request")
    ] = None
    input: Annotated[
        Optional[Dict[str, Any]],
        Field(description="provide a json blob to the workflow"),
    ] = None
    subflow: Optional[WorkflowIdentifier] = None


class ClusterRoleSpecResourceRuleApiGroup(RootModel[str]):
    root: Annotated[str, Field(min_length=1)]


class ClusterRoleSpecResourceRuleResource(ClusterRoleSpecResourceRuleApiGroup):
    pass


class ClusterRoleSpecResourceRule(BaseModel):
    """
    A role rule controlling access to a kubernetes resource.
    """

    apiGroups: Annotated[
        List[ClusterRoleSpecResourceRuleApiGroup],
        Field(
            description='The API groups for the resources controlled by the rule.\nAn API group consists of an apiGroup and a version, e.g. "apigroup/version".\nThe API group can be a wildcard ("*"), in which case it will match any API group.',
            min_length=1,
            title="API Groups",
        ),
    ]
    permissions: Annotated[
        Literal["none", "read", "readWrite"],
        Field(
            description="Permissions for resources specified by the rule.",
            title="Permissions",
        ),
    ]
    resources: Annotated[
        List[ClusterRoleSpecResourceRuleResource],
        Field(
            description='Names for the resources controlled by the rule.\nIt can be a wildcard ("*"), in which case it will match any resource\nin the matching API groups.',
            min_length=1,
            title="Resources",
        ),
    ]


class ClusterRoleSpecTableRule(BaseModel):
    """
    A role rule controlling access to a EDB table.  Note that
    there is never write access to EDB.
    """

    path: Annotated[
        str,
        Field(
            description='EDB path to which this rule applies. It can end in ".*"\nin which case the final portion of the table path can be anything, if the\nprefix matches. It can end in ".**" in which case the table path can be\nanything if the prefix matches.',
            min_length=1,
            pattern="^\\..*",
            title="Path",
        ),
    ]
    permissions: Annotated[
        Literal["none", "read"],
        Field(description="Permissions for the given EDB path.", title="Permissions"),
    ]


class ClusterRoleSpecUrlRule(BaseModel):
    """
    A role rule controlling access to an API server proxy.
    """

    path: Annotated[
        str,
        Field(
            description='The API server URL path to which this rule applies. It can end in "/*"\nin which case the final portion of the URL path can be anything, if the\nprefix matches. It can end in "/**" in which case the URL path can be\nanything if the prefix matches.',
            min_length=1,
            pattern="^/.*",
            title="Path",
        ),
    ]
    permissions: Annotated[
        Literal["none", "read", "readWrite"],
        Field(
            description="The permissions for the API server URL for the rule.",
            title="Permissions",
        ),
    ]


class ClusterRoleSpec(BaseModel):
    """
    ClusterRole defines a set of permissions to access EDA resources.
    ClusterRoles and users are bound via groups, selecting a set of users and a set of ClusterRoles to bind.
    """

    description: Annotated[
        Optional[str],
        Field(description="A description for the role.", title="Description"),
    ] = None
    resourceRules: Annotated[
        Optional[List[ClusterRoleSpecResourceRule]],
        Field(description="Rules for access to resources.", title="Resource Rules"),
    ] = None
    tableRules: Annotated[
        Optional[List[ClusterRoleSpecTableRule]],
        Field(
            description="Rules for access to EDB tables, including via EQL.",
            title="Table Rules",
        ),
    ] = None
    urlRules: Annotated[
        Optional[List[ClusterRoleSpecUrlRule]],
        Field(
            description="Rules for access to APIServer proxied routes.",
            title="URL Rules",
        ),
    ] = None


class ClusterRoleDeletedResourceEntry(BaseModel):
    commitTime: Optional[AwareDatetime] = None
    hash: Optional[str] = None
    name: Optional[str] = None
    transactionId: Optional[int] = None


class ClusterRoleDeletedResources(RootModel[List[ClusterRoleDeletedResourceEntry]]):
    root: List[ClusterRoleDeletedResourceEntry]


class ClusterRoleMetadata(BaseModel):
    annotations: Optional[Dict[str, str]] = None
    labels: Optional[Dict[str, str]] = None
    name: Annotated[
        str,
        Field(
            max_length=253,
            pattern="^[a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*$",
        ),
    ]


class DeviationSpecAssociatedCr(BaseModel):
    groupVersion: Annotated[
        str,
        Field(
            description="Group and version of the resource.", title="Group + Version"
        ),
    ]
    kind: Annotated[str, Field(description="Kind of the resource.", title="Kind")]
    name: Annotated[str, Field(description="Name of the resource.", title="Name")]


class DeviationSpec(BaseModel):
    """
    Deviations are used to represent differences between the intended and actual state of a target.
    They indicate the intended state - or the computed configuration EDA expects, and compare this to the actual or running state, or the configuration retrieved from the target.
    Deviations are most often generated by out-of-band changes to a target by an external system or user, and
    can be accepted or rejected. Rejecting a Deviation will result in the intended configuration being re-applied, undoing the out-of-band change.
    Deviations are raised per table, meaning a single change on a target may result in more than one Deviation.
    """

    accepted: Annotated[
        Optional[bool],
        Field(
            description="Indicates whether this Deviation has been accepted.",
            title="Accepted",
        ),
    ] = None
    associatedCrs: Annotated[
        Optional[List[DeviationSpecAssociatedCr]],
        Field(
            description="Resources impacted by this Deviation.",
            title="Associated Resources",
        ),
    ] = None
    intendedValues: Annotated[
        Optional[str],
        Field(
            description="JSON object containing intended values of fields at the specified path.",
            title="Intended Values",
        ),
    ] = None
    nodeEndpoint: Annotated[
        str,
        Field(description="Target on which this Deviation is present.", title="Target"),
    ]
    operation: Annotated[
        Literal["create", "delete"],
        Field(
            description="Indicates the operation in this Deviation.", title="Operation"
        ),
    ]
    path: Annotated[
        str,
        Field(
            description='Path on the target this Deviation is present at. This path is relative to the target\'s root, without any EDA prefixes - for example ".system" rather than ".namespace.node.srl.system".',
            title="Path",
        ),
    ]
    runningValues: Annotated[
        Optional[str],
        Field(
            description="JSON object containing running values of fields at the specified path.",
            title="Running Values",
        ),
    ] = None


class DeviationActionSpecAction(BaseModel):
    action: Annotated[
        Literal["setAccept", "clearAccept", "reject"],
        Field(description="Action to perform on matching Deviations.", title="Action"),
    ]
    path: Annotated[
        str,
        Field(
            description="Path to match Deviation resources on this target. Only one action is allowed per path.",
            title="Path",
        ),
    ]
    recurse: Annotated[
        Optional[bool],
        Field(
            description="Recursively accept/reject Deviations from the specified path.",
            title="Recurse",
        ),
    ] = None


class DeviationActionSpec(BaseModel):
    """
    DeviationAction allows manual and API-driven actions to be performed on Deviation resources.
    They are the only means to which and end user can accept or reject deviations, as Deviation resources themselves are read only.
    """

    actions: Annotated[
        List[DeviationActionSpecAction],
        Field(
            description="The set of actions to perform on the target.", title="Actions"
        ),
    ]
    nodeEndpoint: Annotated[
        str,
        Field(
            description="The target on which this action is to be performed.",
            title="Target",
        ),
    ]


class DeviationActionStatus(BaseModel):
    """
    DeviationActionStatus defines the observed state of DeviationAction
    """

    result: Annotated[
        Optional[Literal["OK", "Failed"]],
        Field(description="The result of the set of actions.", title="Result"),
    ] = None
    transactionId: Annotated[
        Optional[int],
        Field(
            description="The transaction id these actions were part of.",
            title="Transaction Id",
        ),
    ] = None


class DeviationActionDeletedResourceEntry(BaseModel):
    commitTime: Optional[AwareDatetime] = None
    hash: Optional[str] = None
    name: Optional[str] = None
    namespace: Optional[str] = None
    transactionId: Optional[int] = None


class DeviationActionDeletedResources(
    RootModel[List[DeviationActionDeletedResourceEntry]]
):
    root: List[DeviationActionDeletedResourceEntry]


class DeviationActionMetadata(BaseModel):
    annotations: Optional[Dict[str, str]] = None
    labels: Optional[Dict[str, str]] = None
    name: Annotated[
        str,
        Field(
            max_length=253,
            pattern="^[a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*$",
        ),
    ]
    namespace: str


DeviationMetadata = DeviationActionMetadata


class EdgeInterfaceSpecGatewayIPV4Address(BaseModel):
    ipPrefix: Annotated[
        str, Field(description="Address and mask to use", title="IP Prefix")
    ]
    primary: Annotated[
        Optional[bool],
        Field(
            description="Indicates which address to use as primary for broadcast",
            title="Primary",
        ),
    ] = None


EdgeInterfaceSpecGatewayIPV6Address = EdgeInterfaceSpecGatewayIPV4Address


class EdgeInterfaceSpec(BaseModel):
    """
    EdgeInterfaceSpec defines the desired state of EdgeInterface
    """

    bridgeDomain: Annotated[
        Optional[str],
        Field(description="Reference to a Bridge Domain", title="bridgeDomain"),
    ] = None
    encapType: Annotated[
        Literal["null", "dot1q"],
        Field(
            description="Indicates if the EdgeInterface uses VLAN tagging",
            title="Encapsulation",
        ),
    ]
    gatewayIPV4Addresses: Annotated[
        Optional[List[EdgeInterfaceSpecGatewayIPV4Address]],
        Field(
            description="List of gateway IPv4 addresses in ip/mask form - e.g. 192.168.0.1/24",
            title="Gateway IPv4 Addresses",
        ),
    ] = None
    gatewayIPV6Addresses: Annotated[
        Optional[List[EdgeInterfaceSpecGatewayIPV6Address]],
        Field(
            description="List of gateway IPv6 addresses in ip/mask form - e.g. fc00::1/120",
            title="Gateway IPv6 Addresses",
        ),
    ] = None
    interfaceResource: Annotated[
        str, Field(description="Reference to an interface", title="Interface Resource")
    ]
    router: Annotated[
        Optional[str], Field(description="Reference to a Router", title="Router")
    ] = None
    vlanID: Annotated[
        Optional[int],
        Field(
            description="Single value between 0-4094 supported",
            ge=0,
            le=4094,
            title="VLAN ID",
        ),
    ] = None


EdgeInterfaceDeletedResourceEntry = DeviationActionDeletedResourceEntry


class EdgeInterfaceDeletedResources(RootModel[List[EdgeInterfaceDeletedResourceEntry]]):
    root: List[EdgeInterfaceDeletedResourceEntry]


EdgeInterfaceMetadata = DeviationActionMetadata


class HttpProxySpec(BaseModel):
    """
    HttpProxySpec defines the desired state of HttpProxy
    """

    authType: Annotated[
        Literal["atDestination", "inApiServer"],
        Field(
            description='Determines where authentication happens.\nIf "atDestination", then no authentication happens in API server and any auth tokens are forwarded as is.\nIf "inApiServer", then authentication happens within the API server and auth tokens are stripped prior to forwarding.',
            title="Authentication Type",
        ),
    ]
    rootUrl: Annotated[
        str,
        Field(
            description="The proxy destination, including the protocol.", title="Git"
        ),
    ]


HttpProxyDeletedResourceEntry = ClusterRoleDeletedResourceEntry


class HttpProxyDeletedResources(RootModel[List[HttpProxyDeletedResourceEntry]]):
    root: List[HttpProxyDeletedResourceEntry]


HttpProxyMetadata = ClusterRoleMetadata


class IPAllocationPoolSpecSegmentAllocation(BaseModel):
    name: Annotated[str, Field(description="Name of this allocation.", title="Name")]
    value: Annotated[str, Field(description="Allocation to reserve.", title="Value")]


class IPAllocationPoolSpecSegmentReservation(BaseModel):
    end: Annotated[str, Field(description="Value to reserve to.", title="End")]
    start: Annotated[str, Field(description="Value to start reserving.", title="Start")]


class IPAllocationPoolSpecSegment(BaseModel):
    allocateBroadcastAddress: Annotated[
        Optional[bool],
        Field(
            description="Permit the allocation of the broadcast address.",
            title="Allocate Broadcast Address",
        ),
    ] = None
    allocateNetworkAddress: Annotated[
        Optional[bool],
        Field(
            description="Permit the allocation of the network address.",
            title="Allocate Network Address",
        ),
    ] = None
    allocations: Annotated[
        Optional[List[IPAllocationPoolSpecSegmentAllocation]],
        Field(
            description="List of reservations to exclude from allocations from this segment.",
            title="Allocations",
        ),
    ] = None
    reservations: Annotated[
        Optional[List[IPAllocationPoolSpecSegmentReservation]],
        Field(
            description="List of ranges to exclude from allocations from this segment.",
            title="Reservations",
        ),
    ] = None
    subnet: Annotated[
        str, Field(description="IPv4 or IPv6 subnet, e.g. 10.1.1.0/24.", title="Subnet")
    ]


class IPAllocationPoolSpec(BaseModel):
    """
    IPAllocationPool is a generic IP allocation pool supporting allocation of IPv4 and/or IPv6 addresses from a set of segments.
    It is different from IPInSubnetAllocationPool in that it returns a single unzoned IP address, i.e. an IP address without a subnet. For example a 10.1.1.0/24 segment could return 10.1.1.1.
    Consult application documentation to know which pool type to use for a given use case.
    """

    publishAllocations: Annotated[
        Optional[bool],
        Field(
            description="If true, allocations in segments will be published to EDB, available to query via EQL and trigger state applications off of.",
            title="Publish Allocations",
        ),
    ] = None
    segments: Annotated[
        List[IPAllocationPoolSpecSegment],
        Field(
            description="List of segments containing IPv4 or IPv6 addresses to allocate.",
            min_length=1,
            title="Segments",
        ),
    ]


IPAllocationPoolDeletedResourceEntry = DeviationActionDeletedResourceEntry


class IPAllocationPoolDeletedResources(
    RootModel[List[IPAllocationPoolDeletedResourceEntry]]
):
    root: List[IPAllocationPoolDeletedResourceEntry]


IPAllocationPoolMetadata = DeviationActionMetadata


IPInSubnetAllocationPoolSpecSegmentAllocation = IPAllocationPoolSpecSegmentAllocation


IPInSubnetAllocationPoolSpecSegmentReservation = IPAllocationPoolSpecSegmentReservation


class IPInSubnetAllocationPoolSpecSegment(BaseModel):
    allocateBroadcastAddress: Annotated[
        Optional[bool],
        Field(
            description="Permit the allocation of the broadcast address.",
            title="Allocate Broadcast Address",
        ),
    ] = None
    allocateNetworkAddress: Annotated[
        Optional[bool],
        Field(
            description="Permit the allocation of the network address.",
            title="Allocate Network Address",
        ),
    ] = None
    allocations: Annotated[
        Optional[List[IPInSubnetAllocationPoolSpecSegmentAllocation]],
        Field(
            description="List of reservations to exclude from allocations from this segment.",
            title="Allocations",
        ),
    ] = None
    reservations: Annotated[
        Optional[List[IPInSubnetAllocationPoolSpecSegmentReservation]],
        Field(
            description="List of ranges to exclude from allocations from this segment.",
            title="Reservations",
        ),
    ] = None
    subnet: Annotated[
        str, Field(description="IPv4 or IPv6 subnet, e.g. 10.1.1.0/24.", title="Subnet")
    ]


class IPInSubnetAllocationPoolSpec(BaseModel):
    """
    IPInSubnetAllocationPool is a generic IP allocation pool supporting allocation of IPv4 and/or IPv6 addresses from a set of segments.
    It is different from IPAllocationPool in that it returns a single zoned IP address, i.e. an IP address with a subnet. For example a 10.1.1.0/24 segment could return 10.1.1.1/24.
    Consult application documentation to know which pool type to use for a given use case.
    """

    publishAllocations: Annotated[
        Optional[bool],
        Field(
            description="If true, allocations in segments will be published to EDB, available to query via EQL and trigger state applications off of.",
            title="Publish Allocations",
        ),
    ] = None
    segments: Annotated[
        List[IPInSubnetAllocationPoolSpecSegment],
        Field(
            description="List of segments containing IPv4 or IPv6 addresses to allocate.",
            min_length=1,
            title="Segments",
        ),
    ]


IPInSubnetAllocationPoolDeletedResourceEntry = DeviationActionDeletedResourceEntry


class IPInSubnetAllocationPoolDeletedResources(
    RootModel[List[IPInSubnetAllocationPoolDeletedResourceEntry]]
):
    root: List[IPInSubnetAllocationPoolDeletedResourceEntry]


IPInSubnetAllocationPoolMetadata = DeviationActionMetadata


class IndexAllocationPoolSpecSegmentAllocation(BaseModel):
    name: Annotated[str, Field(description="Name of this allocation.", title="Name")]
    value: Annotated[int, Field(description="Index to reserve.", title="Value")]


class IndexAllocationPoolSpecSegmentReservation(BaseModel):
    end: Annotated[int, Field(description="Value to reserve to.", title="End")]
    start: Annotated[int, Field(description="Value to start reserving.", title="Start")]


class IndexAllocationPoolSpecSegment(BaseModel):
    allocations: Annotated[
        Optional[List[IndexAllocationPoolSpecSegmentAllocation]],
        Field(
            description="List of reservations to exclude from allocations from this segment.",
            title="Allocations",
        ),
    ] = None
    reservations: Annotated[
        Optional[List[IndexAllocationPoolSpecSegmentReservation]],
        Field(
            description="Range of reservations to exclude from allocations from this segment.",
            title="Reservations",
        ),
    ] = None
    size: Annotated[
        int, Field(description="Number of elements in the segment.", title="Size")
    ]
    start: Annotated[
        int, Field(description="Starting value of the segment.", title="Start")
    ]


class IndexAllocationPoolSpec(BaseModel):
    """
    IndexAllocationPool is a generic allocation pool supporting allocation of indexes from a set of segments.
    It supports allocating things like VLANs, subinterface indexes, autonomous system numbers, or any other integer-based index.
    """

    publishAllocations: Annotated[
        Optional[bool],
        Field(
            description="If true, allocations in segments will be published to EDB, available to query via EQL and trigger state applications off of.",
            title="Publish Allocations",
        ),
    ] = None
    segments: Annotated[
        List[IndexAllocationPoolSpecSegment],
        Field(
            description="List of segments containing indexes to allocate.",
            min_length=1,
            title="Segments",
        ),
    ]


IndexAllocationPoolDeletedResourceEntry = DeviationActionDeletedResourceEntry


class IndexAllocationPoolDeletedResources(
    RootModel[List[IndexAllocationPoolDeletedResourceEntry]]
):
    root: List[IndexAllocationPoolDeletedResourceEntry]


IndexAllocationPoolMetadata = DeviationActionMetadata


class LicenseSpec(BaseModel):
    """
    A License represents an application license providing functionality within EDA. A license providing the "base" feature must be provided/valid for transactions to be processed.
    """

    data: Annotated[
        str,
        Field(
            description="The license key. This is a base64 encoded string.",
            title="Data",
        ),
    ]
    enabled: Annotated[
        Optional[bool],
        Field(
            description="Indicates if this license is available for use.",
            title="Enabled",
        ),
    ] = True


class LicenseStatus(BaseModel):
    """
    Status information for this license.
    """

    comment: Annotated[
        Optional[str],
        Field(description="Any comment provided in the license.", title="Comment"),
    ] = None
    expirationDate: Annotated[
        Optional[date],
        Field(
            description="Date and time the license expires.", title="Expiration Date"
        ),
    ] = None
    expired: Annotated[
        bool,
        Field(description="Indicates if the license has expired.", title="Expired"),
    ]
    issuedDate: Annotated[
        Optional[date],
        Field(description="Date and time the license was issued.", title="Issued Date"),
    ] = None
    used: Annotated[
        bool, Field(description="Indicates if license has been used.", title="Used")
    ]
    valid: Annotated[
        bool, Field(description="Indicates if the license is valid.", title="Valid")
    ]


LicenseMetadata = ClusterRoleMetadata


class NamespaceSpec(BaseModel):
    """
    A Namespace is a logical partition within the cluster that provides a mechanism for isolating resources.
    Namespaces allow for resource segmentation, enabling multiple teams or applications to share the same cluster without conflict.
    """

    description: Annotated[
        Optional[str],
        Field(
            description="An optional description of the use of the namespace.",
            title="Description",
        ),
    ] = None


NamespaceDeletedResourceEntry = ClusterRoleDeletedResourceEntry


class NamespaceDeletedResources(RootModel[List[NamespaceDeletedResourceEntry]]):
    root: List[NamespaceDeletedResourceEntry]


NamespaceMetadata = ClusterRoleMetadata


class NodeProfileSpecDhcpDhcp4Option(BaseModel):
    option: Annotated[
        Literal[
            "1-SubnetMask",
            "2-TimeOffset",
            "3-Router",
            "4-TimeServer",
            "5-NameServer",
            "6-DomainNameServer",
            "7-LogServer",
            "8-QuoteServer",
            "9-LPRServer",
            "10-ImpressServer",
            "11-ResourceLocationServer",
            "12-HostName",
            "13-BootFileSize",
            "14-MeritDumpFile",
            "15-DomainName",
            "16-SwapServer",
            "17-RootPath",
            "18-ExtensionsPath",
            "19-IPForwarding",
            "20-NonLocalSourceRouting",
            "21-PolicyFilter",
            "22-MaximumDatagramAssemblySize",
            "23-DefaultIPTTL",
            "24-PathMTUAgingTimeout",
            "25-PathMTUPlateauTable",
            "26-InterfaceMTU",
            "27-AllSubnetsAreLocal",
            "28-BroadcastAddress",
            "29-PerformMaskDiscovery",
            "30-MaskSupplier",
            "31-PerformRouterDiscovery",
            "32-RouterSolicitationAddress",
            "33-StaticRoutingTable",
            "34-TrailerEncapsulation",
            "35-ArpCacheTimeout",
            "36-EthernetEncapsulation",
            "37-DefaulTCPTTL",
            "38-TCPKeepaliveInterval",
            "39-TCPKeepaliveGarbage",
            "40-NetworkInformationServiceDomain",
            "41-NetworkInformationServers",
            "42-NTPServers",
            "43-VendorSpecificInformation",
            "44-NetBIOSOverTCPIPNameServer",
            "45-NetBIOSOverTCPIPDatagramDistributionServer",
            "46-NetBIOSOverTCPIPNodeType",
            "47-NetBIOSOverTCPIPScope",
            "48-XWindowSystemFontServer",
            "49-XWindowSystemDisplayManager",
            "50-RequestedIPAddress",
            "51-IPAddressLeaseTime",
            "52-OptionOverload",
            "53-DHCPMessageType",
            "54-ServerIdentifier",
            "55-ParameterRequestList",
            "56-Message",
            "57-MaximumDHCPMessageSize",
            "58-RenewTimeValue",
            "59-RebindingTimeValue",
            "60-ClassIdentifier",
            "61-ClientIdentifier",
            "62-NetWareIPDomainName",
            "63-NetWareIPInformation",
            "64-NetworkInformationServicePlusDomain",
            "65-NetworkInformationServicePlusServers",
            "66-TFTPServerName",
            "67-BootfileName",
            "68-MobileIPHomeAgent",
            "69-SimpleMailTransportProtocolServer",
            "70-PostOfficeProtocolServer",
            "71-NetworkNewsTransportProtocolServer",
            "72-DefaultWorldWideWebServer",
            "73-DefaultFingerServer",
            "74-DefaultInternetRelayChatServer",
            "75-StreetTalkServer",
            "76-StreetTalkDirectoryAssistanceServer",
            "77-UserClassInformation",
            "78-SLPDirectoryAgent",
            "79-SLPServiceScope",
            "80-RapidCommit",
            "81-FQDN",
            "82-RelayAgentInformation",
            "83-InternetStorageNameService",
            "85-NDSServers",
            "86-NDSTreeName",
            "87-NDSContext",
            "88-BCMCSControllerDomainNameList",
            "89-BCMCSControllerIPv4AddressList",
            "90-Authentication",
            "91-ClientLastTransactionTime",
            "92-AssociatedIP",
            "93-ClientSystemArchitectureType",
            "94-ClientNetworkInterfaceIdentifier",
            "95-LDAP",
            "97-ClientMachineIdentifier",
            "98-OpenGroupUserAuthentication",
            "99-GeoConfCivic",
            "100-IEEE10031TZString",
            "101-ReferenceToTZDatabase",
            "112-NetInfoParentServerAddress",
            "113-NetInfoParentServerTag",
            "114-URL",
            "116-AutoConfigure",
            "117-NameServiceSearch",
            "118-SubnetSelection",
            "119-DNSDomainSearchList",
            "120-SIPServers",
            "121-ClasslessStaticRoute",
            "122-CCC",
            "123-GeoConf",
            "124-VendorIdentifyingVendorClass",
            "125-VendorIdentifyingVendorSpecific",
            "128-TFTPServerIPAddress",
            "129-CallServerIPAddress",
            "130-DiscriminationString",
            "131-RemoteStatisticsServerIPAddress",
            "132-8021PVLANID",
            "133-8021QL2Priority",
            "134-DiffservCodePoint",
            "135-HTTPProxyForPhoneSpecificApplications",
            "136-PANAAuthenticationAgent",
            "137-LoSTServer",
            "138-CAPWAPAccessControllerAddresses",
            "139-OPTIONIPv4AddressMoS",
            "140-OPTIONIPv4FQDNMoS",
            "141-SIPUAConfigurationServiceDomains",
            "142-OPTIONIPv4AddressANDSF",
            "143-OPTIONIPv6AddressANDSF",
            "150-TFTPServerAddress",
            "151-StatusCode",
            "152-BaseTime",
            "153-StartTimeOfState",
            "154-QueryStartTime",
            "155-QueryEndTime",
            "156-DHCPState",
            "157-DataSource",
            "175-Etherboot",
            "176-IPTelephone",
            "177-EtherbootPacketCableAndCableHome",
            "208-PXELinuxMagicString",
            "209-PXELinuxConfigFile",
            "210-PXELinuxPathPrefix",
            "211-PXELinuxRebootTime",
            "212-OPTION6RD",
            "213-OPTIONv4AccessDomain",
            "220-SubnetAllocation",
            "221-VirtualSubnetAllocation",
            "224-Reserved",
            "225-Reserved",
            "226-Reserved",
            "227-Reserved",
            "228-Reserved",
            "229-Reserved",
            "230-Reserved",
            "231-Reserved",
            "232-Reserved",
            "233-Reserved",
            "234-Reserved",
            "235-Reserved",
            "236-Reserved",
            "237-Reserved",
            "238-Reserved",
            "239-Reserved",
            "240-Reserved",
            "241-Reserved",
            "242-Reserved",
            "243-Reserved",
            "244-Reserved",
            "245-Reserved",
            "246-Reserved",
            "247-Reserved",
            "248-Reserved",
            "249-Reserved",
            "250-Reserved",
            "251-Reserved",
            "252-Reserved",
            "253-Reserved",
            "254-Reserved",
            "255-End",
        ],
        Field(description="DHCPv4 option to return to the TopoNode.", title="Option"),
    ]
    value: Annotated[
        List[str],
        Field(
            description="Value to return to the TopoNode for the specified option.",
            min_length=1,
            title="Value",
        ),
    ]


class NodeProfileSpecDhcpDhcp6Option(BaseModel):
    option: Annotated[
        Literal["59-BootfileUrl"],
        Field(description="DHCPv6 option to return to the TopoNode.", title="Option"),
    ]
    value: Annotated[
        List[str],
        Field(
            description="Value to return to the TopoNode for the specified option.",
            min_length=1,
            title="Value",
        ),
    ]


class NodeProfileSpecDhcp(BaseModel):
    """
    DHCP options to use when onboarding the TopoNode. Optional if not bootstrapping using EDA.
    """

    dhcp4Options: Annotated[
        Optional[List[NodeProfileSpecDhcpDhcp4Option]],
        Field(
            description="DHCPv4 options to return to TopoNodes referencing this NodeProfile.",
            title="DHCPv4 Options",
        ),
    ] = None
    dhcp6Options: Annotated[
        Optional[List[NodeProfileSpecDhcpDhcp6Option]],
        Field(
            description="DHCPv6 options to return to TopoNodes referencing this NodeProfile.",
            title="DHCPv6 Options",
        ),
    ] = None
    managementPoolv4: Annotated[
        Optional[str],
        Field(
            description="IPInSubnetAllocationPool to use for IPv4 allocations of the management address for TopoNodes referencing this NodeProfile.",
            title="Management Pool - IPv4",
        ),
    ] = None
    managementPoolv6: Annotated[
        Optional[str],
        Field(
            description="IPInSubnetAllocationPool to use for IPv6 allocations of the management address for TopoNodes referencing this NodeProfile.",
            title="Management Pool - IPv6",
        ),
    ] = None
    preferredAddressFamily: Annotated[
        Optional[Literal["IPv4", "IPv6"]],
        Field(
            description="Preferred IP address family", title="Preferred Address Family"
        ),
    ] = None


class NodeProfileSpecImage(BaseModel):
    image: Annotated[
        str,
        Field(
            description="URL hosting the software image, e.g. srlimages/srlinux-24.7.1.bin.",
            title="Image",
        ),
    ]
    imageMd5: Annotated[
        Optional[str],
        Field(
            description="URL hosting the software image md5 hash. e.g. srlimages/srlinux-24.7.1.bin.md5.",
            title="Image MD5",
        ),
    ] = None


class NodeProfileSpec(BaseModel):
    """
    NodeProfileSpec defines the desired state of NodeProfile
    """

    annotate: Annotated[
        Optional[bool],
        Field(
            description="Indicates if NPP should annotate sent configuration.",
            title="Annotations",
        ),
    ] = False
    containerImage: Annotated[
        Optional[str],
        Field(
            description="Container image to use when simulating TopoNodes referencing this NodeProfile, e.g. ghcr.io/nokia/srlinux:24.7.1.",
            title="Container Image",
        ),
    ] = None
    dhcp: Annotated[
        Optional[NodeProfileSpecDhcp],
        Field(
            description="DHCP options to use when onboarding the TopoNode. Optional if not bootstrapping using EDA.",
            title="DHCP",
        ),
    ] = None
    imagePullSecret: Annotated[
        Optional[str],
        Field(
            description="Secret used to authenticate to the container registry where the container image is hosted.",
            title="Image Pull Secret",
        ),
    ] = None
    images: Annotated[
        Optional[List[NodeProfileSpecImage]],
        Field(
            description="URLs hosting software images for bootstrapping TopoNodes referencing this NodeProfile.",
            title="Images",
        ),
    ] = None
    license: Annotated[
        Optional[str],
        Field(
            description="ConfigMap containing a license for TopoNodes referencing this NodeProfile.",
            title="License",
        ),
    ] = None
    llmDb: Annotated[
        Optional[str],
        Field(
            description="URL containing LLDB  to use when interacting with LLM-DB and OpenAI for query autocompletion, e.g. http://eda-asvr/llmdb/ce-llm-db-srlinux-24.7.1.tar.gz.",
            title="LLMDB",
        ),
    ] = None
    nodeUser: Annotated[
        str,
        Field(
            description="Reference to a NodeUser to use for authentication to TopoNodes referencing this NodeProfile.",
            title="Node User",
        ),
    ]
    onboardingPassword: Annotated[
        SecretStr,
        Field(
            description="The password to use when onboarding TopoNodes referencing this NodeProfile, e.g. admin.",
            title="Onboarding Password",
        ),
    ]
    onboardingUsername: Annotated[
        str,
        Field(
            description="The username to use when onboarding TopoNodes referencing this NodeProfile, e.g. admin.",
            title="Onboarding Username",
        ),
    ]
    operatingSystem: Annotated[
        Literal["srl", "sros", "eos", "sonic", "ios-xr", "nxos", "linux"],
        Field(
            description="Sets the operating system of this NodeProfile, e.g. srl.",
            title="Operating System",
        ),
    ]
    platformPath: Annotated[
        Optional[str],
        Field(
            description="JSPath to use for retrieving the version string from TopoNodes referencing this NodeProfile, e.g. .platform.chassis.type.",
            title="Platform Path",
        ),
    ] = None
    port: Annotated[
        Optional[int],
        Field(
            description="Port used to establish a connection to the TopoNode, e.g. 57400.",
            ge=1,
            le=65535,
            title="Port",
        ),
    ] = 57400
    serialNumberPath: Annotated[
        Optional[str],
        Field(
            description="JSPath to use for retrieving the serial number string from TopoNodes referencing this NodeProfile, e.g. .platform.chassis.serial-number.",
            title="Serial Number Path",
        ),
    ] = None
    version: Annotated[
        str,
        Field(
            description="Sets the software version of this NodeProfile, e.g. 24.7.1 (for srl), or 24.7.r1 (for sros).",
            title="Version",
        ),
    ]
    versionMatch: Annotated[
        Optional[str],
        Field(
            description="Regular expression to match the node-retrieved version string to TopoNode version, e.g. v0\\.0\\.0.*.",
            title="Version Match",
        ),
    ] = None
    versionPath: Annotated[
        Optional[str],
        Field(
            description="JSPath to use for retrieving the version string from TopoNodes referencing this NodeProfile, e.g. .system.information.version.",
            title="Version Path",
        ),
    ] = None
    yang: Annotated[
        str,
        Field(
            description="URL containing YANG modules and schema profile to use when interacting with TopoNodes referencing this NodeProfile, e.g. http://eda-asvr/schemaprofiles/srlinux-24.7.1.zip.",
            title="YANG",
        ),
    ]


NodeProfileDeletedResourceEntry = DeviationActionDeletedResourceEntry


class NodeProfileDeletedResources(RootModel[List[NodeProfileDeletedResourceEntry]]):
    root: List[NodeProfileDeletedResourceEntry]


NodeProfileMetadata = DeviationActionMetadata


class NodeUserSpecGroupBinding(BaseModel):
    groups: Annotated[
        List[str], Field(description="Assigned groups for this user.", title="Groups")
    ]
    nodeSelector: Annotated[
        Optional[List[str]],
        Field(
            description="Selector to use when selecting TopoNodes to deploy this user to.",
            title="Node Selector",
        ),
    ] = None
    nodes: Annotated[
        Optional[List[str]],
        Field(description=" TopoNodes to deploy this user to.", title="Nodes"),
    ] = None


class NodeUserSpec(BaseModel):
    """
    The NodeUser resource represents a user that can be deployed to a set of TopoNodes. It supports managing the user's password, SSH keys, and group bindings.
    Additionally a NodeUser is referenced by a NodeProfile to indicate how NPP should connect to TopoNodes.
    """

    groupBindings: Annotated[
        List[NodeUserSpecGroupBinding],
        Field(
            description="Matching of this user to node-specific permissions via groups.",
            title="Group Bindings",
        ),
    ]
    password: Annotated[
        SecretStr, Field(description="Password for this user.", title="Password")
    ]
    sshPublicKeys: Annotated[
        Optional[List[str]],
        Field(
            description="SSH public keys to deploy for the user.",
            title="SSH Public Keys",
        ),
    ] = None
    username: Annotated[
        Optional[str],
        Field(
            description="Name of this user. If not provided, the name of the resource will be used.",
            max_length=32,
            title="Username",
        ),
    ] = None


class NodeUserStatusGroupBinding(BaseModel):
    groups: Annotated[
        Optional[List[str]],
        Field(
            description="Groups this user is a member of on this node.", title="Groups"
        ),
    ] = None
    node: Annotated[
        Optional[str], Field(description="Node this user is deployed to.", title="Node")
    ] = None


class NodeUserStatus(BaseModel):
    """
    Deployment status of this NodeUser.
    """

    groupBindings: Annotated[
        Optional[List[NodeUserStatusGroupBinding]],
        Field(
            description="List of TopoNodes user has been deployed to, along with corresponding groups.",
            title="Group Bindings",
        ),
    ] = None


NodeUserDeletedResourceEntry = DeviationActionDeletedResourceEntry


class NodeUserDeletedResources(RootModel[List[NodeUserDeletedResourceEntry]]):
    root: List[NodeUserDeletedResourceEntry]


NodeUserMetadata = DeviationActionMetadata


class RoleSpecResourceRuleApiGroup(ClusterRoleSpecResourceRuleApiGroup):
    pass


class RoleSpecResourceRuleResource(ClusterRoleSpecResourceRuleApiGroup):
    pass


class RoleSpecResourceRule(BaseModel):
    """
    A role rule controlling access to a kubernetes resource.
    """

    apiGroups: Annotated[
        List[RoleSpecResourceRuleApiGroup],
        Field(
            description='The API groups for the resources controlled by the rule.\nAn API group consists of an apiGroup and a version, e.g. "apigroup/version".\nThe API group can be a wildcard ("*"), in which case it will match any API group.',
            min_length=1,
            title="API Groups",
        ),
    ]
    permissions: Annotated[
        Literal["none", "read", "readWrite"],
        Field(
            description="Permissions for resources specified by the rule.",
            title="Permissions",
        ),
    ]
    resources: Annotated[
        List[RoleSpecResourceRuleResource],
        Field(
            description='Names for the resources controlled by the rule.\nIt can be a wildcard ("*"), in which case it will match any resource\nin the matching API groups.',
            min_length=1,
            title="Resources",
        ),
    ]


RoleSpecTableRule = ClusterRoleSpecTableRule


RoleSpecUrlRule = ClusterRoleSpecUrlRule


class RoleSpec(BaseModel):
    """
    RoleSpec defines the desired state of Role
    """

    description: Annotated[
        Optional[str],
        Field(description="A description for the role.", title="Description"),
    ] = None
    resourceRules: Annotated[
        Optional[List[RoleSpecResourceRule]],
        Field(
            description="The rules for access to kubernetes resources",
            title="Resource Rules",
        ),
    ] = None
    tableRules: Annotated[
        Optional[List[RoleSpecTableRule]],
        Field(
            description="The rules for access to the database tables.",
            title="Table Rules",
        ),
    ] = None
    urlRules: Annotated[
        Optional[List[RoleSpecUrlRule]],
        Field(
            description="The rules for access to api-server proxied routes.",
            title="URL Rules",
        ),
    ] = None


RoleDeletedResourceEntry = DeviationActionDeletedResourceEntry


class RoleDeletedResources(RootModel[List[RoleDeletedResourceEntry]]):
    root: List[RoleDeletedResourceEntry]


RoleMetadata = DeviationActionMetadata


SubnetAllocationPoolSpecSegmentAllocation = IPAllocationPoolSpecSegmentAllocation


SubnetAllocationPoolSpecSegmentReservation = IPAllocationPoolSpecSegmentReservation


class SubnetAllocationPoolSpecSegment(BaseModel):
    allocations: Annotated[
        Optional[List[SubnetAllocationPoolSpecSegmentAllocation]],
        Field(
            description="List of reservations to exclude from allocations from this segment.",
            title="Allocations",
        ),
    ] = None
    reservations: Annotated[
        Optional[List[SubnetAllocationPoolSpecSegmentReservation]],
        Field(
            description="List of ranges to exclude from allocations from this segment.",
            title="Reservations",
        ),
    ] = None
    subnet: Annotated[
        str,
        Field(
            description="IPv4 or IPv6 subnet to allocate subnets from, e.g. 10.1.0.0/16.",
            title="Subnet",
        ),
    ]
    subnetLength: Annotated[
        int,
        Field(
            description="The size of the subnets to be allocated from within the parent subnet, e.g. 29 (which could allocate 10.1.0.8/29, for example).",
            title="Subnet Length",
        ),
    ]


class SubnetAllocationPoolSpec(BaseModel):
    """
    SubnetAllocationPool is a generic subnet allocation pool supporting allocation of IPv4 and/or IPv6 child subnets from a list of parent subnet segments.
    It allocates a subnet of the configured length from the provided parent subnet.
    For example a pool could return 10.1.0.8/29 when a segment is defined as subnet 10.1.0.0/16 with subnet length 29.
    Consult application documentation to know which pool type to use for a given use case.
    """

    publishAllocations: Annotated[
        Optional[bool],
        Field(
            description="If true, allocations in segments will be published to EDB, available to query via EQL and trigger state applications off of.",
            title="Publish Allocations",
        ),
    ] = None
    segments: Annotated[
        List[SubnetAllocationPoolSpecSegment],
        Field(
            description="List of segments containing subnets to allocate.",
            min_length=1,
            title="Segments",
        ),
    ]


SubnetAllocationPoolDeletedResourceEntry = DeviationActionDeletedResourceEntry


class SubnetAllocationPoolDeletedResources(
    RootModel[List[SubnetAllocationPoolDeletedResourceEntry]]
):
    root: List[SubnetAllocationPoolDeletedResourceEntry]


SubnetAllocationPoolMetadata = DeviationActionMetadata


class TopoBreakoutSpec(BaseModel):
    """
    TopoBreakoutSpec defines the desired state of TopoBreakout
    """

    channels: Annotated[
        int,
        Field(
            description="The number of breakout channels to create",
            ge=1,
            le=8,
            title="Number of Channels",
        ),
    ]
    interface: Annotated[
        Optional[List[str]],
        Field(
            description="A list of normalized parent interface/port",
            title="Normalized Parent Interface",
        ),
    ] = None
    node: Annotated[
        List[str],
        Field(
            description="Reference to a list of TopoNodes where the parent interfaces are to be broken out",
            title="Node",
        ),
    ]
    speed: Annotated[
        Literal["800G", "400G", "200G", "100G", "50G", "40G", "25G", "10G"],
        Field(description="The speed of each breakout channel", title="Speed"),
    ]


TopoBreakoutDeletedResourceEntry = DeviationActionDeletedResourceEntry


class TopoBreakoutDeletedResources(RootModel[List[TopoBreakoutDeletedResourceEntry]]):
    root: List[TopoBreakoutDeletedResourceEntry]


TopoBreakoutMetadata = DeviationActionMetadata


class TopoLinkSpecLinkLocal(BaseModel):
    """
    Local, or "A" endpoint of the link.
    """

    interface: Annotated[
        Optional[str],
        Field(
            description="Normalized name of the interface/port, e.g. ethernet-1-1.",
            title="Interface",
        ),
    ] = None
    interfaceResource: Annotated[
        str, Field(description="Reference to a Interface.", title="Interface Resource")
    ]
    node: Annotated[str, Field(description="Reference to a TopoNode.", title="Node")]


class TopoLinkSpecLinkRemote(BaseModel):
    """
    Remote, or "B" endpoint of the link.
    """

    interface: Annotated[
        Optional[str],
        Field(
            description="Normalized name of the interface/port, e.g. ethernet-1-1.",
            title="Interface",
        ),
    ] = None
    interfaceResource: Annotated[
        str, Field(description="Reference to a Interface.", title="Interface Resource")
    ]
    node: Annotated[str, Field(description="Reference to a TopoNode.", title="Node")]


class TopoLinkSpecLink(BaseModel):
    local: Annotated[
        TopoLinkSpecLinkLocal,
        Field(description='Local, or "A" endpoint of the link.', title="A"),
    ]
    remote: Annotated[
        Optional[TopoLinkSpecLinkRemote],
        Field(description='Remote, or "B" endpoint of the link.', title="B"),
    ] = None
    speed: Annotated[
        Optional[
            Literal[
                "800G",
                "400G",
                "200G",
                "100G",
                "50G",
                "40G",
                "25G",
                "10G",
                "2.5G",
                "1G",
                "100M",
            ]
        ],
        Field(description="Speed of the link.", title="Speed"),
    ] = None
    type: Annotated[
        Literal["edge", "interSwitch", "loopback"],
        Field(
            description="Specify the type of link.\nIf type is set to edge, topology information for the remote device can be set; when doing so the Remote Node can be set as the hostname of the remote device and Remote Interface as the remote interface name in the device specific format, e.g. eth0.",
            title="Type",
        ),
    ]


class TopoLinkSpec(BaseModel):
    """
    TopoLink represents a logical link between two TopoNodes. It may include more than one physical link, being used to represent a LAG or multihomed link.
    To create a point to point link with a single interface on both sides use a single link property.
    To create a point to point link with a LAG configured on both side, use two links with matching nodes.
    A multihomed LAG is created by using two or more links where the A side and/or B side can be different.
    Creating a link with only A specified will create an edge interface.
    """

    links: Annotated[
        List[TopoLinkSpecLink],
        Field(
            description="Define the set of physical links making up this TopoLink.",
            min_length=1,
            title="Links",
        ),
    ]


class TopoLinkStatusMember(BaseModel):
    """
    MemberStatus defines the state of each member of a TopoLink
    """

    interface: Annotated[
        Optional[str], Field(description="Reference to an Interface", title="Interface")
    ] = None
    node: Annotated[str, Field(description="Reference to a TopoNode", title="Node")]
    operationalState: Annotated[
        str,
        Field(
            description="Indicates the operational state of the TopoLink member.",
            title="Operational State",
        ),
    ]


class TopoLinkStatus(BaseModel):
    """
    TopoLinkStatus defines the observed state of TopoLink
    """

    members: Annotated[
        Optional[List[TopoLinkStatusMember]],
        Field(description="List of members present on the TopoLink.", title="Members"),
    ] = None
    operationalState: Annotated[
        str,
        Field(
            description="Indicates the aggregate operational state of the TopoLink.",
            title="Operational State",
        ),
    ]


TopoLinkDeletedResourceEntry = DeviationActionDeletedResourceEntry


class TopoLinkDeletedResources(RootModel[List[TopoLinkDeletedResourceEntry]]):
    root: List[TopoLinkDeletedResourceEntry]


TopoLinkMetadata = DeviationActionMetadata


class TopoNodeSpecComponentItem(BaseModel):
    kind: Annotated[
        Literal[
            "controlCard",
            "lineCard",
            "fabric",
            "mda",
            "connector",
            "xiom",
            "powerShelf",
            "powerModule",
        ],
        Field(description="The kind of Component, e.g. lineCard.", title="Kind"),
    ]
    slot: Annotated[
        Optional[str],
        Field(
            description="The slot this Component resides in, unset for Components that do not have a slot or ID.\ne.g. 1 would denote the linecard slot 1, 1/1 would denote linecard slot 1 mda slot 1.",
            title="Slot",
        ),
    ] = None
    type: Annotated[
        str,
        Field(
            description="Denotes the type of hardware being provisioned, e.g. xcm-x20.",
            title="Type",
        ),
    ]


class TopoNodeSpecNpp(BaseModel):
    """
    Options relating to NPP interactions with the node.
    """

    mode: Annotated[
        Optional[Literal["normal", "maintenance", "null", "emulate"]],
        Field(
            description='The mode in which this TopoNode is functioning.\n"normal" (the default)\n   indicates that NPP is expecting an endpoint to exist, and will accept and confirm changes only if the endpoint\n   accepts them.\n"maintenance"\n   indicates that no changes will be accepted for the TopoNode, irrespective if the endpoint is up and reachable.\n   The exception is if an upgrade is occuring, in which case changes will be accepted.\n"null"\n\t  indicates that changes will be accepted from CRs and no NPP will be spun up. NPP validation will not occur.\n   This may be useful in playground mode to avoid spinning up of 1000s of NPPs.\n"emulate"\n   indicates that changes will be accepted at the NPP level, without pushing them to a endpoint. NPP validation\n   still occurs.  If no IP address is present, we also run in emulate mode.',
            title="Mode",
        ),
    ] = "normal"


class TopoNodeSpecProductionAddress(BaseModel):
    """
    Production address of this TopoNode - this is the address the real, production instance of this TopoNode uses.
    If left blank, an address will be allocated from the management IP pool specified in the referenced NodeProfile.
    If this TopoNode is not bootstrapped by EDA this field must be provided.
    """

    ipv4: Annotated[
        Optional[str], Field(description="The IPv4 production address", title="IPv4")
    ] = None
    ipv6: Annotated[
        Optional[str], Field(description="The IPv6 production address", title="IPv6")
    ] = None


class TopoNodeSpec(BaseModel):
    """
    A managed network element is represented via a TopoNode resource, describing characteristics of a specific element in the topology.
    """

    component: Annotated[
        Optional[List[TopoNodeSpecComponentItem]],
        Field(
            description="List of components within the TopoNode.\nUsed to define the type and location of linecards, fabrics (SFM), media adapter cards (MDA) and control cards (CPM).",
            title="Components",
        ),
    ] = None
    license: Annotated[
        Optional[str],
        Field(
            description="Reference to a ConfigMap containing a license for the TopoNode. Overrides the license set in the referenced NodeProfile, if present.",
            title="License",
        ),
    ] = None
    macAddress: Annotated[
        Optional[str],
        Field(
            description="MAC address to associate with this TopoNode.\nTypically the chassis MAC address, optionally sent by a node in DHCP requests.\nNot required when a TopoNode is not being bootstrapped by EDA, or is simulated through CX.",
            title="MAC Address",
        ),
    ] = None
    nodeProfile: Annotated[
        str,
        Field(
            description="Reference to a NodeProfile to use with this TopoNode.",
            title="Node Profile",
        ),
    ]
    npp: Annotated[
        Optional[TopoNodeSpecNpp],
        Field(
            description="Options relating to NPP interactions with the node.",
            title="NPP",
        ),
    ] = None
    onBoarded: Annotated[
        Optional[bool],
        Field(
            description="Indicates if this TopoNode has been bootstrapped or is reachable via configured credentials. Set by BootstrapServer when it completes onboarding functions for a given TopoNode.\nMost applications ignore TopoNodes that have not been onboarded yet.",
            title="Onboarded",
        ),
    ] = False
    operatingSystem: Annotated[
        Literal["srl", "sros", "eos", "sonic", "ios-xr", "nxos", "linux"],
        Field(
            description="Operating system running on this TopoNode, e.g. srl.",
            title="Operating System",
        ),
    ]
    platform: Annotated[
        str,
        Field(
            description="Platform type of this TopoNode, e.g. 7220 IXR-D3L.",
            title="Platform",
        ),
    ]
    productionAddress: Annotated[
        Optional[TopoNodeSpecProductionAddress],
        Field(
            description="Production address of this TopoNode - this is the address the real, production instance of this TopoNode uses.\nIf left blank, an address will be allocated from the management IP pool specified in the referenced NodeProfile.\nIf this TopoNode is not bootstrapped by EDA this field must be provided.",
            title="Production Address",
        ),
    ] = None
    serialNumber: Annotated[
        Optional[str],
        Field(
            description="Serial number of this TopoNode, optionally sent by a node in DHCP requests.\nNot required when a TopoNode is not being bootstrapped by EDA, or is simulated through CX.",
            title="Serial Number",
        ),
    ] = None
    systemInterface: Annotated[
        Optional[str],
        Field(
            description="Deprecated: Name of the Interface resource representing the primary loopback on the TopoNode, this field will be removed in the future version.",
            title="System Interface",
        ),
    ] = None
    version: Annotated[
        str,
        Field(
            description="Sets the software version of this TopoNode, e.g. 24.7.1 (for srl), or 24.7.r1 (for sros).",
            title="Version",
        ),
    ]


class TopoNodeStatus(BaseModel):
    """
    TopoNodeStatus defines the observed state of TopoNode
    """

    node_details: Annotated[
        Optional[str],
        Field(
            alias="node-details",
            description="Address and port used to connected to the node.",
            title="Node Address",
        ),
    ] = None
    node_state: Annotated[
        Optional[str],
        Field(
            alias="node-state",
            description='The current state of the connection between NPP and the node.\n"TryingToConnect"\n   NPP is attempting to connect and establish connectivity to the node\n"WaitingForInitialCfg"\n   NPP is connected to the node but waiting for intial config to push\n"Committing"\n\t  NPP is in progress of commiting\n"RetryingCommit"\n   NPP lost sync to node and is re-pushing current config\n"Synced"\n   NPP is in fully synced state\n"Standby"\n   NPP is running in standby mode. This state is only used on standby clusters with georedundancy.\n"NoIpAddress"\n   NPP is running but there is no IP address for node. This only happen in sim setups when\n   CX has not created the simulated node, or the simulated pod failed to launch due to image error.',
            title="Node",
        ),
    ] = None
    npp_details: Annotated[
        Optional[str],
        Field(
            alias="npp-details",
            description="NPP address and port for this TopoNode.",
            title="NPP Address",
        ),
    ] = None
    npp_pod: Annotated[
        Optional[str],
        Field(alias="npp-pod", description="NPP pod name", title="NPP Pod"),
    ] = None
    npp_state: Annotated[
        Optional[str],
        Field(
            alias="npp-state",
            description="The current state of the connection between ConfigEngine and NPP.",
            title="NPP",
        ),
    ] = None
    operatingSystem: Annotated[
        Optional[str],
        Field(
            description="Operational operating system running on this TopoNode, e.g. srl, sros.",
            title="Operating System",
        ),
    ] = None
    platform: Annotated[
        Optional[str],
        Field(
            description="Operational platform type of this TopoNode, e.g. 7220 IXR-D3L.",
            title="Platform",
        ),
    ] = None
    simulate: Annotated[
        Optional[bool],
        Field(
            description="Simulate using CX - if true CX is reponsible for generating the TargetNode resource.",
            title="Simulate",
        ),
    ] = None
    version: Annotated[
        Optional[str],
        Field(
            description="Operational software version of this TopoNode, e.g. 24.7.1 (for srl), or 24.7.r1 (for sros).",
            title="Version",
        ),
    ] = None


TopoNodeDeletedResourceEntry = DeviationActionDeletedResourceEntry


class TopoNodeDeletedResources(RootModel[List[TopoNodeDeletedResourceEntry]]):
    root: List[TopoNodeDeletedResourceEntry]


TopoNodeMetadata = DeviationActionMetadata


class UdpProxySpec(BaseModel):
    """
    UdpProxySpec defines the desired state of UdpProxy
    """

    bufferSize: Annotated[
        int,
        Field(
            description="The proxy will use a buffer of this size for all datagrams it receives and this must be sized\nto accommodate the largest datagrams expected",
            ge=64,
            le=65535,
            title="Buffer Size",
        ),
    ]
    destHost: Annotated[
        str,
        Field(
            description="The destination hostname or IP address to forward the datagrams to",
            title="Destination Host",
        ),
    ]
    destPort: Annotated[
        int,
        Field(
            description="The destination UDP port to forward the datagrams to",
            ge=1,
            le=65535,
            title="Destination Port",
        ),
    ]
    idleTimeout: Annotated[
        int,
        Field(
            description="The proxy will listen for responses from the destination and forward it back to the source\nof the datagram until there is no traffic at all for at least the idle timeout in seconds",
            ge=1,
            title="Idle Timeout",
        ),
    ]
    proxyPort: Annotated[
        int,
        Field(
            description="The UDP port on which to listen for datagrams and then proxy to the destination",
            ge=1,
            le=65535,
            title="Proxy Port",
        ),
    ]


UdpProxyDeletedResourceEntry = ClusterRoleDeletedResourceEntry


class UdpProxyDeletedResources(RootModel[List[UdpProxyDeletedResourceEntry]]):
    root: List[UdpProxyDeletedResourceEntry]


UdpProxyMetadata = ClusterRoleMetadata


class WorkflowSpec(BaseModel):
    """
    WorkflowSpec defines the desired state of Flow
    """

    input: Annotated[
        Optional[Any],
        Field(
            description="Input to this flow, adhering to the JSON schema defined in the referenced WorkflowDefinition.",
            title="Input",
        ),
    ] = None
    type: Annotated[
        str,
        Field(description="Select the WorkflowDefinition to execute.", title="Type"),
    ]


class WorkflowStatus(BaseModel):
    """
    WorkflowStatus defines the observed state of Flow
    """

    output: Annotated[
        Optional[Any],
        Field(
            description="Output from this flow, adhering to the JSON schema defined in the referenced FlowDefinition",
            title="Output",
        ),
    ] = None


class WorkflowDefinitionSpecFlowDefinitionResource(BaseModel):
    """
    the resource type to be used for this flow, can only be set if Schema is not set
    """

    group: Annotated[Optional[str], Field(title="Group")] = None
    kind: Annotated[str, Field(title="Kind")]
    version: Annotated[str, Field(title="Version")]


class WorkflowDefinitionSpecFlowDefinitionSchema(BaseModel):
    """
    the schema for the flow, can only be set if Resource is not set
    """

    jsonSchemaSpec: Annotated[
        Optional[str],
        Field(
            description="A string containing the JSON schema the workflow accepts as input.",
            title="JSON Schema (Spec)",
        ),
    ] = None
    jsonSchemaStatus: Annotated[
        Optional[str],
        Field(
            description="A string containing the JSON schema the workflow will populate as output.",
            title="JSON Schema (Status)",
        ),
    ] = None


class WorkflowDefinitionSpec(BaseModel):
    """
    WorkflowDefinitionSpec defines the desired state of FlowDefinition
    """

    flowDefinitionResource: Annotated[
        Optional[WorkflowDefinitionSpecFlowDefinitionResource],
        Field(
            description="the resource type to be used for this flow, can only be set if Schema is not set"
        ),
    ] = None
    flowDefinitionSchema: Annotated[
        Optional[WorkflowDefinitionSpecFlowDefinitionSchema],
        Field(
            description="the schema for the flow, can only be set if Resource is not set"
        ),
    ] = None
    image: Annotated[
        str,
        Field(
            description='Container image containing the flow. For example "ghcr.io/nokia-eda/apps/operatingsystem:v1.0.0".',
            title="Image",
        ),
    ]
    imagePullSecrets: Annotated[
        Optional[List[str]],
        Field(
            description="Secrets to use to pull the image for this workflow.",
            title="Image Pull Secrets",
        ),
    ] = None
    namespaced: Annotated[
        Optional[bool],
        Field(
            description="If set, resources of this CRD are namespace scoped",
            title="Namespaced",
        ),
    ] = True


WorkflowDefinitionDeletedResourceEntry = ClusterRoleDeletedResourceEntry


class WorkflowDefinitionDeletedResources(
    RootModel[List[WorkflowDefinitionDeletedResourceEntry]]
):
    root: List[WorkflowDefinitionDeletedResourceEntry]


WorkflowDefinitionMetadata = ClusterRoleMetadata


WorkflowMetadata = DeviationActionMetadata


class AppGroup(BaseModel):
    apiVersion: Optional[str] = None
    kind: Optional[str] = None
    name: Optional[str] = None
    preferredVersion: Optional[AppGroupVersion] = None
    versions: Optional[List[AppGroupVersion]] = None


class ResourceHistory(RootModel[List[ResourceHistoryEntry]]):
    root: List[ResourceHistoryEntry]


class Status(BaseModel):
    apiVersion: Optional[str] = None
    details: Optional[StatusDetails] = None
    kind: Optional[str] = None
    string: Optional[str] = None


class TopoElemMetadata(BaseModel):
    attributes: Optional[Dict[str, TopoAttrMetadata]] = None
    schema_: Annotated[Optional[TopoSchema], Field(alias="schema")] = None
    subtitle: Optional[str] = None
    subtitle_key: Optional[str] = None


class TopoOverlayEndpoint(BaseModel):
    attributes: Optional[Dict[str, Dict[str, Any]]] = None
    cr_name: Optional[str] = None
    labels: Optional[Dict[str, str]] = None
    name: Optional[str] = None
    namespace: Optional[str] = None
    overlays: Optional[Dict[str, TopoOverlayEndpointState]] = None
    schema_: Annotated[Optional[TopoSchema], Field(alias="schema")] = None
    state: Optional[int] = None
    ui_name: Optional[str] = None


class TopoOverlayLink(BaseModel):
    attributes: Optional[Dict[str, Dict[str, Any]]] = None
    cr_name: Optional[str] = None
    endpoint_a: Optional[TopoLinkEndpoint] = None
    endpoint_a_details: Optional[TopoOverlayEndpoint] = None
    endpoint_b: Optional[TopoLinkEndpoint] = None
    endpoint_b_details: Optional[TopoOverlayEndpoint] = None
    key: Optional[str] = None
    labels: Optional[Dict[str, str]] = None
    name: Optional[str] = None
    namespace: Optional[str] = None
    overlays: Optional[Dict[str, TopoOverlayLinkState]] = None
    schema_: Annotated[Optional[TopoSchema], Field(alias="schema")] = None
    state: Optional[int] = None
    ui_name: Optional[str] = None


class TopoOverlayNode(BaseModel):
    attributes: Optional[Dict[str, Dict[str, Any]]] = None
    badges: Optional[List[int]] = None
    cr_name: Optional[str] = None
    grouping: Optional[TopoNodeGrouping] = None
    key: Optional[str] = None
    labels: Optional[Dict[str, str]] = None
    name: Optional[str] = None
    namespace: Optional[str] = None
    overlays: Optional[Dict[str, TopoOverlayNodeState]] = None
    schema_: Annotated[Optional[TopoSchema], Field(alias="schema")] = None
    state: Optional[int] = None
    ui_name: Optional[str] = None


class Topology(BaseModel):
    endpoints: Optional[TopoElemMetadata] = None
    group: Optional[str] = None
    grouping: Optional[TopoSchema] = None
    links: Optional[TopoElemMetadata] = None
    name: Optional[str] = None
    nodes: Optional[TopoElemMetadata] = None
    ui_description: Optional[str] = None
    ui_description_key: Optional[str] = None
    ui_name: Optional[str] = None
    ui_name_key: Optional[str] = None
    version: Optional[str] = None


class WorkflowInputData(RootModel[List[WorkflowInputDataElem]]):
    root: List[WorkflowInputDataElem]


class ClusterRole(BaseModel):
    """
    ClusterRole is the Schema for the clusterroles API
    """

    apiVersion: Annotated[str, Field(pattern="^core\\.eda\\.nokia\\.com/v1$")]
    kind: Annotated[str, Field(pattern="^ClusterRole$")]
    metadata: ClusterRoleMetadata
    spec: Annotated[
        ClusterRoleSpec,
        Field(
            description="ClusterRole defines a set of permissions to access EDA resources.\nClusterRoles and users are bound via groups, selecting a set of users and a set of ClusterRoles to bind.",
            title="Specification",
        ),
    ]
    status: Annotated[
        Optional[Dict[str, Any]],
        Field(
            description="RoleStatus defines the observed state of Role", title="Status"
        ),
    ] = None


class ClusterRoleList(BaseModel):
    """
    ClusterRoleList is a list of clusterroles
    """

    apiVersion: str
    items: Optional[List[ClusterRole]] = None
    kind: str


class Deviation(BaseModel):
    """
    Deviation is the Schema for the deviations API
    """

    apiVersion: Annotated[str, Field(pattern="^core\\.eda\\.nokia\\.com/v1$")]
    kind: Annotated[str, Field(pattern="^Deviation$")]
    metadata: DeviationMetadata
    spec: Annotated[
        DeviationSpec,
        Field(
            description="Deviations are used to represent differences between the intended and actual state of a target.\nThey indicate the intended state - or the computed configuration EDA expects, and compare this to the actual or running state, or the configuration retrieved from the target.\nDeviations are most often generated by out-of-band changes to a target by an external system or user, and\ncan be accepted or rejected. Rejecting a Deviation will result in the intended configuration being re-applied, undoing the out-of-band change.\nDeviations are raised per table, meaning a single change on a target may result in more than one Deviation.",
            title="Specification",
        ),
    ]
    status: Annotated[
        Optional[Dict[str, Any]],
        Field(
            description="DeviationStatus defines the observed state of Deviation",
            title="Status",
        ),
    ] = None


class DeviationAction(BaseModel):
    """
    DeviationAction is the Schema for the deviationactions API
    """

    apiVersion: Annotated[str, Field(pattern="^core\\.eda\\.nokia\\.com/v1$")]
    kind: Annotated[str, Field(pattern="^DeviationAction$")]
    metadata: DeviationActionMetadata
    spec: Annotated[
        DeviationActionSpec,
        Field(
            description="DeviationAction allows manual and API-driven actions to be performed on Deviation resources.\nThey are the only means to which and end user can accept or reject deviations, as Deviation resources themselves are read only.",
            title="Specification",
        ),
    ]
    status: Annotated[
        Optional[DeviationActionStatus],
        Field(
            description="DeviationActionStatus defines the observed state of DeviationAction",
            title="Status",
        ),
    ] = None


class DeviationActionList(BaseModel):
    """
    DeviationActionList is a list of deviationactions
    """

    apiVersion: str
    items: Optional[List[DeviationAction]] = None
    kind: str


class DeviationList(BaseModel):
    """
    DeviationList is a list of deviations
    """

    apiVersion: str
    items: Optional[List[Deviation]] = None
    kind: str


class EdgeInterface(BaseModel):
    """
    EdgeInterface is the Schema for the edgeinterfaces API
    """

    apiVersion: Annotated[str, Field(pattern="^core\\.eda\\.nokia\\.com/v1$")]
    kind: Annotated[str, Field(pattern="^EdgeInterface$")]
    metadata: EdgeInterfaceMetadata
    spec: Annotated[
        EdgeInterfaceSpec,
        Field(
            description="EdgeInterfaceSpec defines the desired state of EdgeInterface",
            title="Specification",
        ),
    ]
    status: Annotated[
        Optional[Dict[str, Any]],
        Field(
            description="EdgeInterfaceStatus defines the observed state of EdgeInterface",
            title="Status",
        ),
    ] = None


class EdgeInterfaceList(BaseModel):
    """
    EdgeInterfaceList is a list of edgeinterfaces
    """

    apiVersion: str
    items: Optional[List[EdgeInterface]] = None
    kind: str


class HttpProxy(BaseModel):
    """
    HttpProxy is the Schema for the httpproxies API
    """

    apiVersion: Annotated[str, Field(pattern="^core\\.eda\\.nokia\\.com/v1$")]
    kind: Annotated[str, Field(pattern="^HttpProxy$")]
    metadata: HttpProxyMetadata
    spec: Annotated[
        HttpProxySpec,
        Field(
            description="HttpProxySpec defines the desired state of HttpProxy",
            title="Specification",
        ),
    ]
    status: Annotated[
        Optional[Dict[str, Any]],
        Field(
            description="HttpProxyStatus defines the observed state of HttpProxy",
            title="Status",
        ),
    ] = None


class HttpProxyList(BaseModel):
    """
    HttpProxyList is a list of httpproxies
    """

    apiVersion: str
    items: Optional[List[HttpProxy]] = None
    kind: str


class IPAllocationPool(BaseModel):
    """
    IPAllocationPool is the Schema for the ipallocationpools API
    """

    apiVersion: Annotated[str, Field(pattern="^core\\.eda\\.nokia\\.com/v1$")]
    kind: Annotated[str, Field(pattern="^IPAllocationPool$")]
    metadata: IPAllocationPoolMetadata
    spec: Annotated[
        IPAllocationPoolSpec,
        Field(
            description="IPAllocationPool is a generic IP allocation pool supporting allocation of IPv4 and/or IPv6 addresses from a set of segments.\nIt is different from IPInSubnetAllocationPool in that it returns a single unzoned IP address, i.e. an IP address without a subnet. For example a 10.1.1.0/24 segment could return 10.1.1.1.\nConsult application documentation to know which pool type to use for a given use case.",
            title="Specification",
        ),
    ]
    status: Annotated[
        Optional[Dict[str, Any]],
        Field(
            description="IPAllocationPoolStatus defines the observed state of IPAllocationPool",
            title="Status",
        ),
    ] = None


class IPAllocationPoolList(BaseModel):
    """
    IPAllocationPoolList is a list of ipallocationpools
    """

    apiVersion: str
    items: Optional[List[IPAllocationPool]] = None
    kind: str


class IPInSubnetAllocationPool(BaseModel):
    """
    IPInSubnetAllocationPool is the Schema for the ipinsubnetallocationpools API
    """

    apiVersion: Annotated[str, Field(pattern="^core\\.eda\\.nokia\\.com/v1$")]
    kind: Annotated[str, Field(pattern="^IPInSubnetAllocationPool$")]
    metadata: IPInSubnetAllocationPoolMetadata
    spec: Annotated[
        IPInSubnetAllocationPoolSpec,
        Field(
            description="IPInSubnetAllocationPool is a generic IP allocation pool supporting allocation of IPv4 and/or IPv6 addresses from a set of segments.\nIt is different from IPAllocationPool in that it returns a single zoned IP address, i.e. an IP address with a subnet. For example a 10.1.1.0/24 segment could return 10.1.1.1/24.\nConsult application documentation to know which pool type to use for a given use case.",
            title="Specification",
        ),
    ]
    status: Annotated[
        Optional[Dict[str, Any]],
        Field(
            description="IPInSubnetAllocationPoolStatus defines the observed state of IPInSubnetAllocationPool",
            title="Status",
        ),
    ] = None


class IPInSubnetAllocationPoolList(BaseModel):
    """
    IPInSubnetAllocationPoolList is a list of ipinsubnetallocationpools
    """

    apiVersion: str
    items: Optional[List[IPInSubnetAllocationPool]] = None
    kind: str


class IndexAllocationPool(BaseModel):
    """
    IndexAllocationPool is the Schema for the indexallocationpools API
    """

    apiVersion: Annotated[str, Field(pattern="^core\\.eda\\.nokia\\.com/v1$")]
    kind: Annotated[str, Field(pattern="^IndexAllocationPool$")]
    metadata: IndexAllocationPoolMetadata
    spec: Annotated[
        IndexAllocationPoolSpec,
        Field(
            description="IndexAllocationPool is a generic allocation pool supporting allocation of indexes from a set of segments.\nIt supports allocating things like VLANs, subinterface indexes, autonomous system numbers, or any other integer-based index.",
            title="Specification",
        ),
    ]
    status: Annotated[
        Optional[Dict[str, Any]],
        Field(
            description="IndexAllocationPoolStatus defines the observed state of IndexAllocationPool",
            title="Status",
        ),
    ] = None


class IndexAllocationPoolList(BaseModel):
    """
    IndexAllocationPoolList is a list of indexallocationpools
    """

    apiVersion: str
    items: Optional[List[IndexAllocationPool]] = None
    kind: str


class License(BaseModel):
    """
    License is the Schema for the licenses API
    """

    apiVersion: Annotated[str, Field(pattern="^core\\.eda\\.nokia\\.com/v1$")]
    kind: Annotated[str, Field(pattern="^License$")]
    metadata: LicenseMetadata
    spec: Annotated[
        LicenseSpec,
        Field(
            description='A License represents an application license providing functionality within EDA. A license providing the "base" feature must be provided/valid for transactions to be processed.',
            title="Specification",
        ),
    ]
    status: Annotated[
        Optional[LicenseStatus],
        Field(description="Status information for this license.", title="Status"),
    ] = None


class LicenseList(BaseModel):
    """
    LicenseList is a list of licenses
    """

    apiVersion: str
    items: Optional[List[License]] = None
    kind: str


class Namespace(BaseModel):
    """
    Namespace is the Schema for the namespaces API
    """

    apiVersion: Annotated[str, Field(pattern="^core\\.eda\\.nokia\\.com/v1$")]
    kind: Annotated[str, Field(pattern="^Namespace$")]
    metadata: NamespaceMetadata
    spec: Annotated[
        NamespaceSpec,
        Field(
            description="A Namespace is a logical partition within the cluster that provides a mechanism for isolating resources.\nNamespaces allow for resource segmentation, enabling multiple teams or applications to share the same cluster without conflict.",
            title="Specification",
        ),
    ]
    status: Annotated[
        Optional[Dict[str, Any]],
        Field(
            description="NamespaceStatus defines the observed state of Namespace",
            title="Status",
        ),
    ] = None


class NamespaceList(BaseModel):
    """
    NamespaceList is a list of namespaces
    """

    apiVersion: str
    items: Optional[List[Namespace]] = None
    kind: str


class NodeProfile(BaseModel):
    """
    NodeProfile is the Schema for the nodeprofiles API
    """

    apiVersion: Annotated[str, Field(pattern="^core\\.eda\\.nokia\\.com/v1$")]
    kind: Annotated[str, Field(pattern="^NodeProfile$")]
    metadata: NodeProfileMetadata
    spec: Annotated[
        NodeProfileSpec,
        Field(
            description="NodeProfileSpec defines the desired state of NodeProfile",
            title="Specification",
        ),
    ]
    status: Annotated[Optional[Dict[str, Any]], Field(title="Status")] = None


class NodeProfileList(BaseModel):
    """
    NodeProfileList is a list of nodeprofiles
    """

    apiVersion: str
    items: Optional[List[NodeProfile]] = None
    kind: str


class NodeUser(BaseModel):
    """
    NodeUser is the Schema for the nodeusers API
    """

    apiVersion: Annotated[str, Field(pattern="^core\\.eda\\.nokia\\.com/v1$")]
    kind: Annotated[str, Field(pattern="^NodeUser$")]
    metadata: NodeUserMetadata
    spec: Annotated[
        NodeUserSpec,
        Field(
            description="The NodeUser resource represents a user that can be deployed to a set of TopoNodes. It supports managing the user's password, SSH keys, and group bindings.\nAdditionally a NodeUser is referenced by a NodeProfile to indicate how NPP should connect to TopoNodes.",
            title="Specification",
        ),
    ]
    status: Annotated[
        Optional[NodeUserStatus],
        Field(description="Deployment status of this NodeUser.", title="Status"),
    ] = None


class NodeUserList(BaseModel):
    """
    NodeUserList is a list of nodeusers
    """

    apiVersion: str
    items: Optional[List[NodeUser]] = None
    kind: str


class Role(BaseModel):
    """
    Role is the Schema for the roles API
    """

    apiVersion: Annotated[str, Field(pattern="^core\\.eda\\.nokia\\.com/v1$")]
    kind: Annotated[str, Field(pattern="^Role$")]
    metadata: RoleMetadata
    spec: Annotated[
        RoleSpec,
        Field(
            description="RoleSpec defines the desired state of Role",
            title="Specification",
        ),
    ]
    status: Annotated[
        Optional[Dict[str, Any]],
        Field(
            description="RoleStatus defines the observed state of Role", title="Status"
        ),
    ] = None


class RoleList(BaseModel):
    """
    RoleList is a list of roles
    """

    apiVersion: str
    items: Optional[List[Role]] = None
    kind: str


class SubnetAllocationPool(BaseModel):
    """
    SubnetAllocationPool is the Schema for the subnetallocationpools API
    """

    apiVersion: Annotated[str, Field(pattern="^core\\.eda\\.nokia\\.com/v1$")]
    kind: Annotated[str, Field(pattern="^SubnetAllocationPool$")]
    metadata: SubnetAllocationPoolMetadata
    spec: Annotated[
        SubnetAllocationPoolSpec,
        Field(
            description="SubnetAllocationPool is a generic subnet allocation pool supporting allocation of IPv4 and/or IPv6 child subnets from a list of parent subnet segments.\nIt allocates a subnet of the configured length from the provided parent subnet.\nFor example a pool could return 10.1.0.8/29 when a segment is defined as subnet 10.1.0.0/16 with subnet length 29.\nConsult application documentation to know which pool type to use for a given use case.",
            title="Specification",
        ),
    ]
    status: Annotated[
        Optional[Dict[str, Any]],
        Field(
            description="SubnetAllocationPoolStatus defines the observed state of SubnetAllocationPool",
            title="Status",
        ),
    ] = None


class SubnetAllocationPoolList(BaseModel):
    """
    SubnetAllocationPoolList is a list of subnetallocationpools
    """

    apiVersion: str
    items: Optional[List[SubnetAllocationPool]] = None
    kind: str


class TopoBreakout(BaseModel):
    """
    TopoBreakout is the Schema for the topobreakouts API
    """

    apiVersion: Annotated[str, Field(pattern="^core\\.eda\\.nokia\\.com/v1$")]
    kind: Annotated[str, Field(pattern="^TopoBreakout$")]
    metadata: TopoBreakoutMetadata
    spec: Annotated[
        TopoBreakoutSpec,
        Field(
            description="TopoBreakoutSpec defines the desired state of TopoBreakout",
            title="Specification",
        ),
    ]
    status: Annotated[
        Optional[Dict[str, Any]],
        Field(
            description="TopoBreakoutStatus defines the observed state of TopoBreakout",
            title="Status",
        ),
    ] = None


class TopoBreakoutList(BaseModel):
    """
    TopoBreakoutList is a list of topobreakouts
    """

    apiVersion: str
    items: Optional[List[TopoBreakout]] = None
    kind: str


class TopoLink(BaseModel):
    """
    TopoLink is the Schema for the topolinks API
    """

    apiVersion: Annotated[str, Field(pattern="^core\\.eda\\.nokia\\.com/v1$")]
    kind: Annotated[str, Field(pattern="^TopoLink$")]
    metadata: TopoLinkMetadata
    spec: Annotated[
        TopoLinkSpec,
        Field(
            description="TopoLink represents a logical link between two TopoNodes. It may include more than one physical link, being used to represent a LAG or multihomed link.\nTo create a point to point link with a single interface on both sides use a single link property.\nTo create a point to point link with a LAG configured on both side, use two links with matching nodes.\nA multihomed LAG is created by using two or more links where the A side and/or B side can be different.\nCreating a link with only A specified will create an edge interface.",
            title="Specification",
        ),
    ]
    status: Annotated[
        Optional[TopoLinkStatus],
        Field(
            description="TopoLinkStatus defines the observed state of TopoLink",
            title="Status",
        ),
    ] = None


class TopoLinkList(BaseModel):
    """
    TopoLinkList is a list of topolinks
    """

    apiVersion: str
    items: Optional[List[TopoLink]] = None
    kind: str


class TopoNode(BaseModel):
    """
    TopoNode is the Schema for the toponodes API
    """

    apiVersion: Annotated[str, Field(pattern="^core\\.eda\\.nokia\\.com/v1$")]
    kind: Annotated[str, Field(pattern="^TopoNode$")]
    metadata: TopoNodeMetadata
    spec: Annotated[
        TopoNodeSpec,
        Field(
            description="A managed network element is represented via a TopoNode resource, describing characteristics of a specific element in the topology.",
            title="Specification",
        ),
    ]
    status: Annotated[
        Optional[TopoNodeStatus],
        Field(
            description="TopoNodeStatus defines the observed state of TopoNode",
            title="Status",
        ),
    ] = None


class TopoNodeList(BaseModel):
    """
    TopoNodeList is a list of toponodes
    """

    apiVersion: str
    items: Optional[List[TopoNode]] = None
    kind: str


class UdpProxy(BaseModel):
    """
    UdpProxy is the Schema for the udpproxies API
    """

    apiVersion: Annotated[str, Field(pattern="^core\\.eda\\.nokia\\.com/v1$")]
    kind: Annotated[str, Field(pattern="^UdpProxy$")]
    metadata: UdpProxyMetadata
    spec: Annotated[
        UdpProxySpec,
        Field(
            description="UdpProxySpec defines the desired state of UdpProxy",
            title="Specification",
        ),
    ]
    status: Annotated[
        Optional[Dict[str, Any]],
        Field(
            description="UdpProxyStatus defines the observed state of UdpProxy",
            title="Status",
        ),
    ] = None


class UdpProxyList(BaseModel):
    """
    UdpProxyList is a list of udpproxies
    """

    apiVersion: str
    items: Optional[List[UdpProxy]] = None
    kind: str


class Workflow(BaseModel):
    """
    Workflow is the Schema for the workflows API
    """

    apiVersion: Annotated[str, Field(pattern="^core\\.eda\\.nokia\\.com/v1$")]
    kind: Annotated[str, Field(pattern="^Workflow$")]
    metadata: WorkflowMetadata
    spec: Annotated[
        WorkflowSpec,
        Field(
            description="WorkflowSpec defines the desired state of Flow",
            title="Specification",
        ),
    ]
    status: Annotated[
        Optional[WorkflowStatus],
        Field(
            description="WorkflowStatus defines the observed state of Flow",
            title="Status",
        ),
    ] = None


class WorkflowDefinition(BaseModel):
    """
    WorkflowDefinition is the Schema for the workflowdefinitions API
    """

    apiVersion: Annotated[str, Field(pattern="^core\\.eda\\.nokia\\.com/v1$")]
    kind: Annotated[str, Field(pattern="^WorkflowDefinition$")]
    metadata: WorkflowDefinitionMetadata
    spec: Annotated[
        WorkflowDefinitionSpec,
        Field(
            description="WorkflowDefinitionSpec defines the desired state of FlowDefinition",
            title="Specification",
        ),
    ]
    status: Annotated[
        Optional[Dict[str, Any]],
        Field(
            description="WorkflowDefinitionStatus defines the observed state of FlowDefinition",
            title="Status",
        ),
    ] = None


class WorkflowDefinitionList(BaseModel):
    """
    WorkflowDefinitionList is a list of workflowdefinitions
    """

    apiVersion: str
    items: Optional[List[WorkflowDefinition]] = None
    kind: str


class WorkflowList(BaseModel):
    """
    WorkflowList is a list of workflows
    """

    apiVersion: str
    items: Optional[List[Workflow]] = None
    kind: str


class OverlayState(BaseModel):
    links: Optional[Dict[str, TopoOverlayLink]] = None
    nodes: Optional[Dict[str, TopoOverlayNode]] = None


class ResourceTopology(BaseModel):
    topology: Optional[OverlayState] = None
    topologyMetadata: Optional[Topology] = None
