# generated by datamodel-codegen:
#   filename:  fabrics.json

from __future__ import annotations

from typing import Annotated, Any, Dict, List, Literal, Optional

from pydantic import AwareDatetime, BaseModel, Field, RootModel


class AppGroupVersion(BaseModel):
    groupVersion: Optional[str] = None
    version: Optional[str] = None


class ErrorIndex(BaseModel):
    index: Optional[int] = None


class ErrorItem(BaseModel):
    error: Optional[Dict[str, Any]] = None
    type: Optional[str] = None


class ErrorResponse(BaseModel):
    """
    Generic error response for REST APIs
    """

    code: Annotated[
        int, Field(description="the numeric HTTP error code for the response.")
    ]
    details: Annotated[
        Optional[str], Field(description="The optional details of the error response.")
    ] = None
    dictionary: Annotated[
        Optional[Dict[str, Any]],
        Field(
            description='Dictionary/map of associated data/information relevant to the error.\nThe error "message" may contain {{name}} escapes that should be substituted\nwith information from this dictionary.'
        ),
    ] = None
    domain: Annotated[
        Optional[str],
        Field(
            description='The "domain" for the error.  If empty, it is an EDA\ncore error.  Alternatively it can be an EDA application\n"apiVersion" value (e.g. interfaces.eda.nokia.com/v1alpha1)\nindicating that the error is specific to that application.\nThe domain gives the receiver information that they can use\nto help them interpret the "internal" error code value, or\nto find an internationalization translation for the message.'
        ),
    ] = None
    errors: Annotated[
        Optional[List[ErrorItem]],
        Field(
            description="Collection of errors in cases where more than one exists. This needs to be\nflexible so we can support multiple formats"
        ),
    ] = None
    index: Optional[ErrorIndex] = None
    internal: Annotated[
        Optional[int],
        Field(
            description="Internal error code in cases where we don't have an array of errors"
        ),
    ] = None
    message: Annotated[
        str, Field(description="The basic text error message for the error response.")
    ]
    ref: Annotated[
        Optional[str],
        Field(
            description="Reference to the error source. Should typically be the URI of the request"
        ),
    ] = None
    type: Annotated[
        Optional[str],
        Field(
            description="URI pointing at a document that describes the error and mitigation steps\nIf there is no document, point to the RFC for the HTTP error code"
        ),
    ] = None


class K8SPatchOp(BaseModel):
    from_: Annotated[Optional[str], Field(alias="from")] = None
    op: str
    path: str
    value: Optional[Dict[str, Any]] = None
    x_permissive: Annotated[Optional[bool], Field(alias="x-permissive")] = None


class Patch(RootModel[List[K8SPatchOp]]):
    root: List[K8SPatchOp]


class Resource(BaseModel):
    kind: Optional[str] = None
    name: Optional[str] = None
    namespaced: Optional[bool] = None
    readOnly: Optional[bool] = None
    singularName: Optional[str] = None
    uiCategory: Optional[str] = None


class ResourceHistoryEntry(BaseModel):
    author: Optional[str] = None
    changeType: Optional[str] = None
    commitTime: Optional[AwareDatetime] = None
    hash: Optional[str] = None
    message: Optional[str] = None
    transactionId: Optional[int] = None


class ResourceList(BaseModel):
    apiVersion: Optional[str] = None
    groupVersion: Optional[str] = None
    kind: Optional[str] = None
    resources: Optional[List[Resource]] = None


class StatusDetails(BaseModel):
    group: Optional[str] = None
    kind: Optional[str] = None
    name: Optional[str] = None


class TopoAttrMetadata(BaseModel):
    type: Optional[str] = None
    ui_description: Optional[str] = None
    ui_description_key: Optional[str] = None
    ui_name: Optional[str] = None
    ui_name_key: Optional[str] = None


class TopoLinkEndpoint(BaseModel):
    endpoint: Optional[str] = None
    node: Optional[str] = None
    node_key: Optional[str] = None


class TopoNodeGrouping(BaseModel):
    group: Optional[str] = None
    tier: Optional[int] = None


class TopoOverlayEndpointState(BaseModel):
    state: Optional[int] = None


TopoOverlayLinkState = TopoOverlayEndpointState


class TopoOverlayNodeState(BaseModel):
    badges: Optional[List[int]] = None
    state: Optional[int] = None


class TopoSchema(BaseModel):
    group: Optional[str] = None
    kind: Optional[str] = None
    version: Optional[str] = None


class UIResult(RootModel[str]):
    root: str


class WorkflowGetInputsRespElem(BaseModel):
    ackPrompt: Optional[str] = None
    group: str
    kind: str
    name: str
    namespace: Optional[str] = None
    schemaPrompt: Optional[Dict[str, Any]] = None
    version: str


class WorkflowId(BaseModel):
    id: Annotated[
        Optional[int],
        Field(
            description="A workflow identifier; these are assigned by the system to a posted workflow."
        ),
    ] = None


class WorkflowIdentifier(BaseModel):
    group: str
    kind: str
    name: str
    namespace: Optional[str] = None
    version: str


class WorkflowInputDataElem(BaseModel):
    ack: Annotated[
        Optional[bool], Field(description="acknowledge or reject the input request")
    ] = None
    input: Annotated[
        Optional[Dict[str, Any]],
        Field(description="provide a json blob to the workflow"),
    ] = None
    subflow: Optional[WorkflowIdentifier] = None


class FabricSpecBorderLeafsRouteLeaking(BaseModel):
    """
    Route leaking controlled by routing policies in and out of the DefaultRouters on each node.  If specifided under the Leafs, Spines, SuperSpines, or BorderLeafs those will take precedence.
    """

    exportPolicy: Annotated[
        str,
        Field(
            description="Reference to a Policy resource to use when evaluating route exports from the DefaultRouter.",
            title="Export Policy",
        ),
    ]
    importPolicy: Annotated[
        str,
        Field(
            description="Reference to a Policy resource to use when evaluating route imports into the DefaultRouter.",
            title="Import Policy",
        ),
    ]


class FabricSpecBorderLeafs(BaseModel):
    asnPool: Annotated[
        Optional[str],
        Field(
            description="Reference to an IndexAllocationPool pool to use for Autonomous System Number allocations.  Used when eBGP is configured as an underlay protocol. This reference will take precedence over the spec.underlayProtocol.asnPool.",
            title="Autonomous System Pool",
        ),
    ] = None
    borderLeafNodeSelector: Annotated[
        Optional[List[str]],
        Field(
            description="Label selector used to select Toponodes to configure as Borderleaf nodes.",
            title="Borderleaf Node Selector",
        ),
    ] = None
    routeLeaking: Annotated[
        Optional[FabricSpecBorderLeafsRouteLeaking],
        Field(
            description="Route leaking controlled by routing policies in and out of the DefaultRouters on each node.  If specifided under the Leafs, Spines, SuperSpines, or BorderLeafs those will take precedence.",
            title="Route Leaking",
        ),
    ] = None
    systemPoolIPV4: Annotated[
        Optional[str],
        Field(
            description="Reference to an IPAllocationPool used to dynamically allocate an IPv4 address to system/lo0 interfaces.  This reference will take precedence over the spec.systemPoolIPV4.  Both IPv4 and IPv6 pools can be configured simultaneously for dual-stack system/lo0 interfaces.",
            title="IPv4 Pool - System IP",
        ),
    ] = None
    systemPoolIPV6: Annotated[
        Optional[str],
        Field(
            description="Reference to an IPAllocationPool used to dynamically allocate an IPv6 address to system/lo0 interfaces.  This reference will take precedence over the spec.systemPoolIPV6.  Both IPv4 and IPv6 pools can be configured simultaneously for dual-stack system/lo0 interfaces.",
            title="IPv6 Pool - System IP",
        ),
    ] = None


class FabricSpecInterSwitchLinksQos(BaseModel):
    egressPolicy: Annotated[Optional[str], Field(title="Egress Policy")] = None
    ingressPolicy: Annotated[Optional[str], Field(title="Ingress Policy")] = None


class FabricSpecInterSwitchLinks(BaseModel):
    ipMTU: Annotated[
        Optional[int],
        Field(
            description="Sets the IP MTU for the DefaultInterface.",
            ge=1280,
            le=9486,
            title="IP MTU",
        ),
    ] = None
    linkSelector: Annotated[
        Optional[List[str]],
        Field(
            description="Selects TopoLinks to include in this Fabric, creating an ISL resource if both Nodes in the TopoLink are part of this Fabric or a selected Fabric.",
            title="Link Selector",
        ),
    ] = None
    poolIPV4: Annotated[
        Optional[str],
        Field(
            description="Reference to an IPAllocationPool used to dynamically allocate an IPv4 address to DefaultInterfaces which are members of the ISLs.  Both IPv4 and IPv6 pools can be configured simultaneously for dual-stack DefaultInterfaces.",
            title="IPv4 Pool - InterSwitch Link IP",
        ),
    ] = None
    poolIPV6: Annotated[
        Optional[str],
        Field(
            description="Reference to an IPAllocationPool used to dynamically allocate an IPv6 address to DefaultInterfaces which are members of the ISLs.  Both IPv4 and IPv6 pools can be configured simultaneously for dual-stack DefaultInterfaces.",
            title="IPv6 Pool - InterSwitch Link IP",
        ),
    ] = None
    qos: Annotated[Optional[FabricSpecInterSwitchLinksQos], Field(title="QoS")] = None
    unnumbered: Annotated[
        Optional[Literal["IPV6"]],
        Field(
            description="Enables unnumbered interfaces on the ISL; for IPv6, only link-local addresses are used unless a PoolIPV6 is also specified.  DefaultInterfaces in the ISL are added to the DefaultBGPPeer dynamic neighbor list when using an eBGP underlay.",
            title="Unnumbered",
        ),
    ] = None
    vlanID: Annotated[
        Optional[int],
        Field(
            description="Configures the provided VLAN on the DefaultInterfaces which are members of the ISLs.",
            ge=1,
            le=4094,
            title="VLAN ID - InterSwitch Link",
        ),
    ] = None


FabricSpecLeafsRouteLeaking = FabricSpecBorderLeafsRouteLeaking


class FabricSpecLeafs(BaseModel):
    asnPool: Annotated[
        Optional[str],
        Field(
            description="Reference to an IndexAllocationPool pool to use for Autonomous System Number allocations.  Used when eBGP is configured as an underlay protocol. This reference will take precedence over the spec.underlayProtocol.asnPool.",
            title="Autonomous System Pool",
        ),
    ] = None
    leafNodeSelector: Annotated[
        Optional[List[str]],
        Field(
            description="Label selector used to select Toponodes to configure as Leaf nodes.",
            title="Leaf Node Selector",
        ),
    ] = None
    routeLeaking: Annotated[
        Optional[FabricSpecLeafsRouteLeaking],
        Field(
            description="Route leaking controlled by routing policies in and out of the DefaultRouters on each node.  If specifided under the Leafs, Spines, SuperSpines, or BorderLeafs those will take precedence.",
            title="Route Leaking",
        ),
    ] = None
    systemPoolIPV4: Annotated[
        Optional[str],
        Field(
            description="Reference to an IPAllocationPool used to dynamically allocate an IPv4 address to system/lo0 interfaces.  This reference will take precedence over the spec.systemPoolIPV4.  Both IPv4 and IPv6 pools can be configured simultaneously for dual-stack system/lo0 interfaces.",
            title="IPv4 Pool - System IP",
        ),
    ] = None
    systemPoolIPV6: Annotated[
        Optional[str],
        Field(
            description="Reference to an IPAllocationPool used to dynamically allocate an IPv6 address to system/lo0 interfaces.  This reference will take precedence over the spec.systemPoolIPV6.  Both IPv4 and IPv6 pools can be configured simultaneously for dual-stack system/lo0 interfaces.",
            title="IPv6 Pool - System IP",
        ),
    ] = None


class FabricSpecOverlayProtocolBfd(BaseModel):
    """
    Enable BFD on overlay protocol
    """

    desiredMinTransmitInt: Annotated[
        Optional[int],
        Field(
            description="The minimum interval in microseconds between transmission of BFD control packets.",
            ge=10000,
            le=100000000,
            title="Transmit Interval",
        ),
    ] = 1000000
    detectionMultiplier: Annotated[
        Optional[int],
        Field(
            description="The number of packets that must be missed to declare this session as down.",
            ge=3,
            le=20,
            title="Multiplier",
        ),
    ] = 3
    enabled: Annotated[
        Optional[bool],
        Field(description="Enable Biforward Detection.", title="Enabled"),
    ] = False
    minEchoReceiveInterval: Annotated[
        Optional[int],
        Field(
            description="The minimum interval between echo packets the local node can receive in microseconds.",
            ge=0,
            le=100000000,
            title="Minimum Echo Receive Interval",
        ),
    ] = 1000000
    requiredMinReceive: Annotated[
        Optional[int],
        Field(
            description="The minimum interval in microseconds between received BFD control packets that this system should support.",
            ge=10000,
            le=100000000,
            title="Receive Interval",
        ),
    ] = 1000000
    ttl: Annotated[
        Optional[int],
        Field(
            description="Sets custom IP TTL or Hop Limit for multi-hop BFD sessions packets. Not appllicable to single-hop BFD sessions.",
            ge=2,
            le=255,
            title="IP TTL/Hop Limit",
        ),
    ] = None


class FabricSpecOverlayProtocolBgpTimers(BaseModel):
    """
    Timer configurations
    """

    connectRetry: Annotated[
        Optional[int],
        Field(
            description="The time interval in seconds between successive attempts to establish a session with a peer.",
            ge=1,
            le=65535,
            title="Connect Retry",
        ),
    ] = None
    holdTime: Annotated[
        Optional[int],
        Field(
            description="The hold-time interval in seconds that the router proposes to the peer in its OPEN message.",
            ge=0,
            le=65535,
            title="Hold Time",
        ),
    ] = None
    keepAlive: Annotated[
        Optional[int],
        Field(
            description="The interval in seconds between successive keepalive messages sent to the peer.",
            ge=0,
            le=21845,
            title="Keep Alive",
        ),
    ] = None
    minimumAdvertisementInterval: Annotated[
        Optional[int],
        Field(
            description="The value assigned to the MinRouteAdvertisementIntervalTimer of RFC 4271, for both EBGP and IBGP sessions.",
            ge=1,
            le=255,
            title="Minimum Advertisement Interval",
        ),
    ] = None


class FabricSpecOverlayProtocolBgp(BaseModel):
    """
    Overlay specific BGP properties.
    """

    autonomousSystem: Annotated[
        Optional[int],
        Field(
            description="Autonomous System used for iBGP peering session, when protocol is set to IBGP providing an autonomousSystem is required.",
            title="Autonomous System",
        ),
    ] = None
    clusterID: Annotated[
        Optional[str],
        Field(
            description="Sets the cluster ID used by DefaultRouteReflectors, when protocol is set to IBGP providing a clusterID is required.",
            title="Cluster ID",
        ),
    ] = None
    exportPolicy: Annotated[
        Optional[List[str]],
        Field(
            description="Reference to a Policy, when left empty or not specified the Fabric will automatically generate a policy for the specified protocols.",
            title="Export Policy",
        ),
    ] = None
    importPolicy: Annotated[
        Optional[List[str]],
        Field(
            description="Reference to a Policy, when left empty or not specified the Fabric will automatically generate a policy for the specified protocols.",
            title="Import Policy",
        ),
    ] = None
    keychain: Annotated[
        Optional[str],
        Field(
            description="Keychain to be used for authentication when overlay protocol is IBGP, ignored otherwise",
            title="Keychain",
        ),
    ] = None
    rrClientNodeSelector: Annotated[
        Optional[List[str]],
        Field(
            description="Label selector used to select Toponodes to configure as DefaultRouteReflectorClients, these are typically Leaf or Borderleaf nodes.  Used on conjunction with rrNodeSelector in order to configure the DefaultBGPPeers for both the DefaultRouteReflectors and DefaultRouteReflectorClients.",
            title="Route Reflector Client Node Selector",
        ),
    ] = None
    rrIPAddresses: Annotated[
        Optional[List[str]],
        Field(
            description="List of route reflector IP addresses not provisioned by this instance of a Fabric resource.  Used with rrClientNodeSelector to configure the DefaultBGPPeers on the selected nodes to peer the list of external route reflector IPs.",
            title="Route Reflector IP Addresses",
        ),
    ] = None
    rrNodeSelector: Annotated[
        Optional[List[str]],
        Field(
            description="Label selector used to select Toponodes to configure as DefaultRouteReflectors, these are typically Spine, Superspine or Borderleaf nodes. Used on conjunction with rrClientNodeSelector in order to configure the DefaultBGPPeers for both the DefaultRouteReflectors and DefaultRouteReflectorClients.",
            title="Route Reflector Node Selector",
        ),
    ] = None
    timers: Annotated[
        Optional[FabricSpecOverlayProtocolBgpTimers],
        Field(description="Timer configurations", title="Timers"),
    ] = None


class FabricSpecOverlayProtocol(BaseModel):
    """
    Set the overlay protocol used
    """

    bfd: Annotated[
        Optional[FabricSpecOverlayProtocolBfd],
        Field(
            description="Enable BFD on overlay protocol", title="Overlay Protocol BFD"
        ),
    ] = None
    bgp: Annotated[
        Optional[FabricSpecOverlayProtocolBgp],
        Field(description="Overlay specific BGP properties.", title="BGP"),
    ] = None
    protocol: Annotated[
        Literal["IBGP", "EBGP"],
        Field(
            description="List of routing protocols to used to advertise EVPN routes for overlay services.  When EBGP is used, the BGP properties configured under the spec.underlayProtocol will be used.",
            title="Protocol",
        ),
    ]


class FabricSpecRouteLeaking(BaseModel):
    """
    Route leaking controlled by routing policies in and out of the DefaulRouters on each node.  If specifided under the Leafs, Spines, SuperSpines, or BorderLeafs those will take precedence.
    """

    exportPolicy: Annotated[
        str,
        Field(
            description="Reference to a Policy resource to use when evaluating route exports from the DefaultRouter.",
            title="Export Policy",
        ),
    ]
    importPolicy: Annotated[
        str,
        Field(
            description="Reference to a Policy resource to use when evaluating route imports into the DefaultRouter.",
            title="Import Policy",
        ),
    ]


FabricSpecSpinesRouteLeaking = FabricSpecBorderLeafsRouteLeaking


class FabricSpecSpines(BaseModel):
    asnPool: Annotated[
        Optional[str],
        Field(
            description="Reference to an IndexAllocationPool pool to use for Autonomous System Number allocations.  Used when eBGP is configured as an underlay protocol. This reference will take precedence over the spec.underlayProtocol.asnPool.",
            title="Autonomous System Pool",
        ),
    ] = None
    routeLeaking: Annotated[
        Optional[FabricSpecSpinesRouteLeaking],
        Field(
            description="Route leaking controlled by routing policies in and out of the DefaultRouters on each node.  If specifided under the Leafs, Spines, SuperSpines, or BorderLeafs those will take precedence.",
            title="Route Leaking",
        ),
    ] = None
    spineNodeSelector: Annotated[
        Optional[List[str]],
        Field(
            description="Label selector used to select Toponodes to configure as Spine nodes.",
            title="Spine Node Selector",
        ),
    ] = None
    systemPoolIPV4: Annotated[
        Optional[str],
        Field(
            description="Reference to an IPAllocationPool used to dynamically allocate an IPv4 address to system/lo0 interfaces.  This reference will take precedence over the spec.systemPoolIPV4.  Both IPv4 and IPv6 pools can be configured simultaneously for dual-stack system/lo0 interfaces.",
            title="IPv4 Pool - System IP",
        ),
    ] = None
    systemPoolIPV6: Annotated[
        Optional[str],
        Field(
            description="Reference to an IPAllocationPool used to dynamically allocate an IPv6 address to system/lo0 interfaces.  This reference will take precedence over the spec.systemPoolIPV6.  Both IPv4 and IPv6 pools can be configured simultaneously for dual-stack system/lo0 interfaces.",
            title="IPv6 Pool - System IP",
        ),
    ] = None


FabricSpecSuperSpinesRouteLeaking = FabricSpecBorderLeafsRouteLeaking


class FabricSpecSuperSpines(BaseModel):
    asnPool: Annotated[
        Optional[str],
        Field(
            description="Reference to an IndexAllocationPool pool to use for Autonomous System Number allocations.  Used when eBGP is configured as an underlay protocol. This reference will take precedence over the spec.underlayProtocol.asnPool.",
            title="Autonomous System Pool",
        ),
    ] = None
    routeLeaking: Annotated[
        Optional[FabricSpecSuperSpinesRouteLeaking],
        Field(
            description="Route leaking controlled by routing policies in and out of the DefaultRouters on each node.  If specifided under the Leafs, Spines, SuperSpines, or BorderLeafs those will take precedence.",
            title="Route Leaking",
        ),
    ] = None
    superSpineNodeSelector: Annotated[
        Optional[List[str]],
        Field(
            description="Label selector used to select Toponodes to configure as Superspine nodes.",
            title="Superspine Node Selector",
        ),
    ] = None
    systemPoolIPV4: Annotated[
        Optional[str],
        Field(
            description="Reference to an IPAllocationPool used to dynamically allocate an IPv4 address to system/lo0 interfaces.  This reference will take precedence over the spec.systemPoolIPV4.  Both IPv4 and IPv6 pools can be configured simultaneously for dual-stack system/lo0 interfaces.",
            title="IPv4 Pool - System IP",
        ),
    ] = None
    systemPoolIPV6: Annotated[
        Optional[str],
        Field(
            description="Reference to an IPAllocationPool used to dynamically allocate an IPv6 address to system/lo0 interfaces.  This reference will take precedence over the spec.systemPoolIPV6.  Both IPv4 and IPv6 pools can be configured simultaneously for dual-stack system/lo0 interfaces.",
            title="IPv6 Pool - System IP",
        ),
    ] = None


class FabricSpecUnderlayProtocolBfd(BaseModel):
    """
    Enable BFD on underlay protocol
    """

    desiredMinTransmitInt: Annotated[
        Optional[int],
        Field(
            description="The minimum interval in microseconds between transmission of BFD control packets.",
            ge=10000,
            le=100000000,
            title="Transmit Interval",
        ),
    ] = 1000000
    detectionMultiplier: Annotated[
        Optional[int],
        Field(
            description="The number of packets that must be missed to declare this session as down.",
            ge=3,
            le=20,
            title="Multiplier",
        ),
    ] = 3
    enabled: Annotated[
        Optional[bool],
        Field(description="Enable Biforward Detection.", title="Enabled"),
    ] = False
    minEchoReceiveInterval: Annotated[
        Optional[int],
        Field(
            description="The minimum interval between echo packets the local node can receive in microseconds.",
            ge=0,
            le=100000000,
            title="Minimum Echo Receive Interval",
        ),
    ] = 1000000
    requiredMinReceive: Annotated[
        Optional[int],
        Field(
            description="The minimum interval in microseconds between received BFD control packets that this system should support.",
            ge=10000,
            le=100000000,
            title="Receive Interval",
        ),
    ] = 1000000
    ttl: Annotated[
        Optional[int],
        Field(
            description="Sets custom IP TTL or Hop Limit for multi-hop BFD sessions packets. Not appllicable to single-hop BFD sessions.",
            ge=2,
            le=255,
            title="IP TTL/Hop Limit",
        ),
    ] = None


FabricSpecUnderlayProtocolBgpTimers = FabricSpecOverlayProtocolBgpTimers


class FabricSpecUnderlayProtocolBgp(BaseModel):
    """
    Underlay specific BGP properties.
    """

    asnPool: Annotated[
        Optional[str],
        Field(
            description="Reference to an IndexAllocationPool pool to use for Autonomous System Number allocations.  Used when eBGP is configured as an underlay protocol. If specified under the Leaf/Spine/Superspine/Borderleaf those will take precedence.",
            title="Autonomous System Pool",
        ),
    ] = None
    exportPolicy: Annotated[
        Optional[List[str]],
        Field(
            description="Reference to a Policy, when left empty or not specified the Fabric will automatically generate a policy for the specified protocols.",
            title="Export Policy",
        ),
    ] = None
    importPolicy: Annotated[
        Optional[List[str]],
        Field(
            description="Reference to a Policy, when left empty or not specified the Fabric will automatically generate a policy for the specified protocols.",
            title="Import Policy",
        ),
    ] = None
    keychain: Annotated[
        Optional[str],
        Field(description="Keychain to be used for authentication", title="Keychain"),
    ] = None
    timers: Annotated[
        Optional[FabricSpecUnderlayProtocolBgpTimers],
        Field(description="Timer configurations", title="Timers"),
    ] = None


class FabricSpecUnderlayProtocol(BaseModel):
    """
    Set the underlay protocol used
    """

    bfd: Annotated[
        Optional[FabricSpecUnderlayProtocolBfd],
        Field(
            description="Enable BFD on underlay protocol", title="Underlay Protocol BFD"
        ),
    ] = None
    bgp: Annotated[
        FabricSpecUnderlayProtocolBgp,
        Field(description="Underlay specific BGP properties.", title="BGP"),
    ]
    protocol: Annotated[
        List[Literal["EBGP"]],
        Field(
            description="List of routing protocols to used between peers of an ISL.  Multiple protocols may be listed, if so multiple protocols will be used.",
            title="Protocol",
        ),
    ]


class FabricSpec(BaseModel):
    """
    The Fabric defines the desired state of a Fabric resource, enabling the automation and management of data center network fabrics. It includes configurations for IP address allocation pools, network topology roles (Leafs, Spines, SuperSpines, BorderLeafs), inter-switch links, and network protocols (underlay and overlay). The specification allows for detailed control over routing strategies, including ASN allocations for BGP-based protocols, and supports advanced features like BFD.
    """

    borderLeafs: Annotated[
        Optional[FabricSpecBorderLeafs], Field(title="Borderleafs")
    ] = None
    fabricSelector: Annotated[
        Optional[List[str]],
        Field(
            description="Selects Fabric resources when connecting multiple Fabrics together. Only one Fabric needs the selector, typically the upper layer (e.g., Superspine) selecting the lower layer (e.g., a pod fabric of leafs and spines). This helps build complete Fabrics in smaller instances of the Fabric resource. This instance selecting other fabrics must also select the InterSwitchLinks connecting itself to the selected Fabrics.",
            title="Fabric Selector",
        ),
    ] = None
    interSwitchLinks: Annotated[
        Optional[FabricSpecInterSwitchLinks], Field(title="InterSwitchLinks")
    ] = None
    leafs: Annotated[Optional[FabricSpecLeafs], Field(title="Leafs")] = None
    overlayProtocol: Annotated[
        Optional[FabricSpecOverlayProtocol],
        Field(description="Set the overlay protocol used", title="Overlay Protocol"),
    ] = None
    routeLeaking: Annotated[
        Optional[FabricSpecRouteLeaking],
        Field(
            description="Route leaking controlled by routing policies in and out of the DefaulRouters on each node.  If specifided under the Leafs, Spines, SuperSpines, or BorderLeafs those will take precedence.",
            title="Route Leaking",
        ),
    ] = None
    spines: Annotated[Optional[FabricSpecSpines], Field(title="Spines")] = None
    superSpines: Annotated[
        Optional[FabricSpecSuperSpines], Field(title="Superspines")
    ] = None
    systemPoolIPV4: Annotated[
        Optional[str],
        Field(
            description="Reference to an IPAllocationPool used to dynamically allocate an IPv4 address to system/lo0 interfaces.  If specified under the Leaf/Spine/Superspine/Borderleaf those will take precedence.  Both IPv4 and IPv6 pools can be configured simultaneously for dual-stack system/lo0 interfaces.",
            title="IPv4 Pool - System IP",
        ),
    ] = None
    systemPoolIPV6: Annotated[
        Optional[str],
        Field(
            description="Reference to an IPAllocationPool used to dynamically allocate an IPv6 address to system/lo0 interfaces.  If specified under the Leaf/Spine/Superspine/Borderleaf those will take precedence.  Both IPv4 and IPv6 pools can be configured simultaneously for dual-stack system/lo0 interfaces.",
            title="IPv6 Pool - System IP",
        ),
    ] = None
    underlayProtocol: Annotated[
        Optional[FabricSpecUnderlayProtocol],
        Field(description="Set the underlay protocol used", title="Underlay Protocol"),
    ] = None


class FabricStatusBorderLeafNode(BaseModel):
    node: Annotated[
        Optional[str], Field(description="Name of the TopoNode.", title="Node")
    ] = None
    operatingSystem: Annotated[
        Optional[str],
        Field(
            description="Operating system running on the node.",
            title="Operating System",
        ),
    ] = None
    operatingSystemVersion: Annotated[
        Optional[str],
        Field(
            description="Operating system version running on the node.",
            title="Operating System Version",
        ),
    ] = None
    underlayAutonomousSystem: Annotated[
        Optional[int],
        Field(
            description="Underlay Autonomous System used for eBGP peering session, when protocol is set to eBGP this is required.",
            title="Underlay Autonomous System",
        ),
    ] = None


FabricStatusLeafNode = FabricStatusBorderLeafNode


FabricStatusSpineNode = FabricStatusBorderLeafNode


FabricStatusSuperSpineNode = FabricStatusBorderLeafNode


class FabricStatus(BaseModel):
    """
    FabricStatus defines the observed state of Fabric
    """

    borderLeafNodes: Annotated[
        Optional[List[FabricStatusBorderLeafNode]],
        Field(
            description="List of border leaf nodes in the Fabric.",
            title="Border Leaf Nodes",
        ),
    ] = None
    health: Annotated[
        Optional[int],
        Field(
            description="Indicates the health score of the Fabric.  The health score of the Fabric is determined by the aggregate health score of the resources emited by the Fabric such as ISL, DefaultRouteReflectors etc.",
            title="Health",
        ),
    ] = None
    healthScoreReason: Annotated[
        Optional[str],
        Field(
            description="Indicates the reason for the health score.",
            title="Health Score Reason",
        ),
    ] = None
    lastChange: Annotated[
        Optional[AwareDatetime],
        Field(
            description="The time when the state of the resource last changed.",
            title="Last Change",
        ),
    ] = None
    leafNodes: Annotated[
        Optional[List[FabricStatusLeafNode]],
        Field(description="List of leaf nodes in the Fabric.", title="Leaf Nodes"),
    ] = None
    operationalState: Annotated[
        Optional[str],
        Field(
            description="Operational state of the Fabric.  The operational state of the fabric is determined by monitoring the operational state of the following resources (if applicable): DefaultRouters, ISLs.",
            title="Operational State",
        ),
    ] = None
    spineNodes: Annotated[
        Optional[List[FabricStatusSpineNode]],
        Field(description="List of spine nodes in the Fabric.", title="Spine Nodes"),
    ] = None
    superSpineNodes: Annotated[
        Optional[List[FabricStatusSuperSpineNode]],
        Field(
            description="List of super spine nodes in the Fabric.",
            title="Superspine Nodes",
        ),
    ] = None


class FabricDeletedResourceEntry(BaseModel):
    commitTime: Optional[AwareDatetime] = None
    hash: Optional[str] = None
    name: Optional[str] = None
    namespace: Optional[str] = None
    transactionId: Optional[int] = None


class FabricDeletedResources(RootModel[List[FabricDeletedResourceEntry]]):
    root: List[FabricDeletedResourceEntry]


class FabricMetadata(BaseModel):
    annotations: Optional[Dict[str, str]] = None
    labels: Optional[Dict[str, str]] = None
    name: Annotated[
        str,
        Field(
            max_length=253,
            pattern="^[a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*$",
        ),
    ]
    namespace: str


class ISLSpecBfd(BaseModel):
    """
    Enable or disable BFD on the ISL. [default=false]
    """

    desiredMinTransmitInt: Annotated[
        Optional[int],
        Field(
            description="The minimum interval in microseconds between transmission of BFD control packets.",
            ge=10000,
            le=100000000,
            title="Transmit Interval",
        ),
    ] = 1000000
    detectionMultiplier: Annotated[
        Optional[int],
        Field(
            description="The number of packets that must be missed to declare this session as down.",
            ge=3,
            le=20,
            title="Multiplier",
        ),
    ] = 3
    enabled: Annotated[
        Optional[bool],
        Field(description="Enable Biforward Detection.", title="Enabled"),
    ] = False
    minEchoReceiveInterval: Annotated[
        Optional[int],
        Field(
            description="The minimum interval between echo packets the local node can receive in microseconds.",
            ge=0,
            le=100000000,
            title="Minimum Echo Receive Interval",
        ),
    ] = 1000000
    requiredMinReceive: Annotated[
        Optional[int],
        Field(
            description="The minimum interval in microseconds between received BFD control packets that this system should support.",
            ge=10000,
            le=100000000,
            title="Receive Interval",
        ),
    ] = 1000000
    ttl: Annotated[
        Optional[int],
        Field(
            description="Sets custom IP TTL or Hop Limit for multi-hop BFD sessions packets. Not appllicable to single-hop BFD sessions.",
            ge=2,
            le=255,
            title="IP TTL/Hop Limit",
        ),
    ] = None


class ISLSpecBgp(BaseModel):
    afiSAFI: Annotated[
        Optional[List[str]],
        Field(
            description="Which AFI and SAFI to advertise on the BGP peering session. Options: ipv4unicast, ipv6unicast, l2vpnevpn",
            title="AFI SAFI",
        ),
    ] = None
    bgpGroup: Annotated[
        Optional[str],
        Field(description="Reference to a DefaultBgpGroup.", title="BGP Group"),
    ] = None
    enabled: Annotated[
        bool,
        Field(
            description="Enable or disable BGP peering between the two endpoints of the ISL. [default=false]",
            title="Enabled",
        ),
    ]
    exportPolicy: Annotated[
        Optional[List[str]],
        Field(
            description="Reference to a RoutingPolicy to use when evaluating route exports from the DefaultRouter.",
            title="Export Policy",
        ),
    ] = None
    importPolicy: Annotated[
        Optional[List[str]],
        Field(
            description="Reference to a RoutingPolicy to use when evaluating route imports into the DefaultRouter.",
            title="Import Policy",
        ),
    ] = None
    keychain: Annotated[
        Optional[str],
        Field(description="Keychain to be used for authentication", title="Keychain"),
    ] = None
    localInterfaceAS: Annotated[
        int,
        Field(
            description="The Autonomous System to configure on the Local Interface.",
            ge=0,
            le=4294967295,
            title="Local Interface AS",
        ),
    ]
    remoteInterfaceAS: Annotated[
        int,
        Field(
            description="The Autonomous System to configure on the Remote Interface.",
            ge=0,
            le=4294967295,
            title="Remote Interface AS",
        ),
    ]


ISLSpecQos = FabricSpecInterSwitchLinksQos


class ISLSpec(BaseModel):
    """
    The ISL enables the configuration and management of direct links between Nodes. This resource allows for specifying IPv4 and IPv6 allocation pools, enabling BFD for fast failure detection, and configuring VLAN IDs for the ISL. It also supports BGP peering between the endpoints, with options for setting autonomous systems, AFI/SAFI configurations, and import/export routing policies.
    """

    bfd: Annotated[
        Optional[ISLSpecBfd],
        Field(
            description="Enable or disable BFD on the ISL. [default=false]", title="BFD"
        ),
    ] = None
    bgp: Annotated[Optional[ISLSpecBgp], Field(title="BGP")] = None
    ipMTU: Annotated[
        Optional[int],
        Field(
            description="Sets the IP MTU for the local and remote Interfaces",
            ge=1280,
            le=9486,
            title="IP MTU",
        ),
    ] = None
    localDefaultRouter: Annotated[
        str,
        Field(
            description="Reference to the DefautlRouter associated with the local Interface in which the ISL will be provisioned.",
            title="Local Default Router",
        ),
    ]
    localInterface: Annotated[
        str, Field(description="Reference to an Interface.", title="Local Interface")
    ]
    poolIPV4: Annotated[
        Optional[str],
        Field(
            description="Reference to an IPv4 allocation pool to use for ISL subnet allocations.",
            title="IPv4 Allocation Pool",
        ),
    ] = None
    poolIPV6: Annotated[
        Optional[str],
        Field(
            description="Reference to an IPv6 allocation pool to use for ISL subnet allocations.",
            title="IPv6 Allocation Pool",
        ),
    ] = None
    qos: Annotated[Optional[ISLSpecQos], Field(title="QoS")] = None
    remoteDefaultRouter: Annotated[
        str,
        Field(
            description="Reference to the DefautlRouter associated with the remote Interface in which the ISL will be provisioned.",
            title="Remote Default Router",
        ),
    ]
    remoteInterface: Annotated[
        str, Field(description="Reference to an Interface", title="Remote Interface")
    ]
    unnumbered: Annotated[
        Optional[Literal["IPV6"]],
        Field(
            description="Enables the use of unnumbered interfaces on the ISL. For IPv6, no IP address are configured on the sub-interface and only the link local address will be used. If any allocation pool is specified for IPv6 that will take precedence and IPs will be assigned to the interfaces.  When using eBGP for an underlay protocol, the DefaultInterfaces which are a part of the ISL will be added to the BGP dynamic neighbor list.",
            title="Unnumbered",
        ),
    ] = None
    vlanID: Annotated[
        Optional[int],
        Field(
            description="Single VLAN tag value between 1-4094.",
            ge=1,
            le=4094,
            title="VLAN ID",
        ),
    ] = None


class ISLStatusLocalInterface(BaseModel):
    """
    Local Interface
    """

    IPv4Address: Annotated[
        Optional[str],
        Field(description="Local Interface IPv4 address", title="IPv4 Address"),
    ] = None
    IPv6Address: Annotated[
        Optional[str],
        Field(description="Local Interface IPv4 address", title="IPv6 Address"),
    ] = None
    defaultInterface: Annotated[
        Optional[str],
        Field(
            description="Reference to the DefaulInterface assocaited with the local interface",
            title="Default Interface",
        ),
    ] = None
    node: Annotated[
        Optional[str],
        Field(
            description="Reference to the TopoNode on which the local interface is configured",
            title="Node",
        ),
    ] = None


class ISLStatusRemoteInterface(BaseModel):
    """
    Remote Interface
    """

    IPv4Address: Annotated[
        Optional[str],
        Field(description="Remote Interface IPv4 address", title="IPv4 Address"),
    ] = None
    IPv6Address: Annotated[
        Optional[str],
        Field(description="Remote Interface IPv6 address", title="IPv6 Address"),
    ] = None
    defaultInterface: Annotated[
        Optional[str],
        Field(
            description="Reference to the DefaulInterface assocaited with the remote interface",
            title="Default Interface",
        ),
    ] = None
    node: Annotated[
        Optional[str],
        Field(
            description="Reference to the TopoNode on which the remote interface is configured",
            title="Node",
        ),
    ] = None


class ISLStatus(BaseModel):
    """
    ISLStatus defines the observed state of ISL
    """

    health: Annotated[
        Optional[int],
        Field(description="Indicates the health score of the ISL", title="Health"),
    ] = None
    healthScoreReason: Annotated[
        Optional[str],
        Field(
            description="Indicates the reason for the health score",
            title="Health Score Reason",
        ),
    ] = None
    lastChange: Annotated[
        Optional[AwareDatetime],
        Field(
            description="The time when the state of the resource last changed",
            title="Last Change",
        ),
    ] = None
    localInterface: Annotated[
        Optional[ISLStatusLocalInterface],
        Field(description="Local Interface", title="Local Interface"),
    ] = None
    operationalState: Annotated[
        Optional[str],
        Field(description="Operational state of the ISL", title="Operational State"),
    ] = None
    remoteInterface: Annotated[
        Optional[ISLStatusRemoteInterface],
        Field(description="Remote Interface", title="Remote Interface"),
    ] = None


ISLDeletedResourceEntry = FabricDeletedResourceEntry


class ISLDeletedResources(RootModel[List[ISLDeletedResourceEntry]]):
    root: List[ISLDeletedResourceEntry]


ISLMetadata = FabricMetadata


class IslPingSpec(BaseModel):
    """
    This workflow is used to ping ISLs (Inter-Switch Links) to verify connectivity within a Fabric.
    It accepts a list of fabrics, ISLs, or selectors for both to match ISLs,
    and returns the results of the pings, including the status of each ISL.
    """

    count: Annotated[
        Optional[int],
        Field(description="Count is the number of pings to send.", title="Count"),
    ] = 1
    fabricSelectors: Annotated[
        Optional[List[str]],
        Field(
            description='Fabric Selectors is a list of fabric selectors to execute ISL pings for.\nThis is a list of label expressions, e.g. ["eda.nokia.com/role=leaf", "eda.nokia.com/region=us-west"].',
            title="Fabric Selectors",
        ),
    ] = None
    fabrics: Annotated[
        Optional[List[str]],
        Field(
            description="Fabrics is a list of fabrics to execute ISL pings for.",
            title="Fabrics",
        ),
    ] = None
    islSelectors: Annotated[
        Optional[List[str]],
        Field(
            description='Inter-Switch Link Selectors is a list of selectors to execute ISL pings for.\nThis is a list of label expressions, e.g. ["eda.nokia.com/role=leaf", "eda.nokia.com/region=us-west"].',
            title="Inter-Switch Link Selectors",
        ),
    ] = None
    isls: Annotated[
        Optional[List[str]],
        Field(
            description="Inter-Switch Links is a list of named ISL resources to execute ISL pings for.",
            title="Inter-Switch Links",
        ),
    ] = None
    timeoutSeconds: Annotated[
        Optional[int],
        Field(
            description="TimeoutSeconds is the timeout for the ping in seconds.",
            title="Timeout Seconds",
        ),
    ] = 5


class IslPingStatusDetailDetails(BaseModel):
    averageTimeNanoseconds: Annotated[
        Optional[int],
        Field(
            description="A Duration represents the elapsed time between two instants\nas an int64 nanosecond count. The representation limits the\nlargest representable duration to approximately 290 years."
        ),
    ] = None
    maxTimeNanoseconds: Annotated[
        Optional[int],
        Field(
            description="A Duration represents the elapsed time between two instants\nas an int64 nanosecond count. The representation limits the\nlargest representable duration to approximately 290 years."
        ),
    ] = None
    minTimeNanoseconds: Annotated[
        Optional[int],
        Field(
            description="A Duration represents the elapsed time between two instants\nas an int64 nanosecond count. The representation limits the\nlargest representable duration to approximately 290 years."
        ),
    ] = None
    received: Optional[int] = None
    sent: Optional[int] = None
    stdDevNanoseconds: Annotated[
        Optional[int],
        Field(
            description="A Duration represents the elapsed time between two instants\nas an int64 nanosecond count. The representation limits the\nlargest representable duration to approximately 290 years."
        ),
    ] = None
    totalTimeNanoseconds: Annotated[
        Optional[int],
        Field(
            description="A Duration represents the elapsed time between two instants\nas an int64 nanosecond count. The representation limits the\nlargest representable duration to approximately 290 years."
        ),
    ] = None


class IslPingStatusDetail(BaseModel):
    details: Optional[IslPingStatusDetailDetails] = None
    error: Optional[str] = None
    name: Optional[str] = None
    success: Optional[bool] = None


class IslPingStatus(BaseModel):
    """
    IslPingStatus defines the observed state of IslPing
    """

    details: Annotated[
        Optional[List[IslPingStatusDetail]],
        Field(
            description="Details contains the results of the pings performed for each ISL.\nEach entry in the list corresponds to an ISL that was pinged."
        ),
    ] = None
    result: Annotated[
        Optional[Literal["Success", "Failed", "PartialSuccess"]],
        Field(
            description='Result is the overall result of the ping operation.\nIt can be one of the following values:\n- "Success": All pings were successful.\n- "Failed": No pings were successful.\n- "PartialSuccess": Some pings were successful, but not all.',
            title="Result",
        ),
    ] = None


IslPingMetadata = FabricMetadata


class AppGroup(BaseModel):
    apiVersion: Optional[str] = None
    kind: Optional[str] = None
    name: Optional[str] = None
    preferredVersion: Optional[AppGroupVersion] = None
    versions: Optional[List[AppGroupVersion]] = None


class ResourceHistory(RootModel[List[ResourceHistoryEntry]]):
    root: List[ResourceHistoryEntry]


class Status(BaseModel):
    apiVersion: Optional[str] = None
    details: Optional[StatusDetails] = None
    kind: Optional[str] = None
    string: Optional[str] = None


class TopoElemMetadata(BaseModel):
    attributes: Optional[Dict[str, TopoAttrMetadata]] = None
    schema_: Annotated[Optional[TopoSchema], Field(alias="schema")] = None
    subtitle: Optional[str] = None
    subtitle_key: Optional[str] = None


class TopoOverlayEndpoint(BaseModel):
    attributes: Optional[Dict[str, Dict[str, Any]]] = None
    cr_name: Optional[str] = None
    labels: Optional[Dict[str, str]] = None
    name: Optional[str] = None
    namespace: Optional[str] = None
    overlays: Optional[Dict[str, TopoOverlayEndpointState]] = None
    schema_: Annotated[Optional[TopoSchema], Field(alias="schema")] = None
    state: Optional[int] = None
    ui_name: Optional[str] = None


class TopoOverlayLink(BaseModel):
    attributes: Optional[Dict[str, Dict[str, Any]]] = None
    cr_name: Optional[str] = None
    endpoint_a: Optional[TopoLinkEndpoint] = None
    endpoint_a_details: Optional[TopoOverlayEndpoint] = None
    endpoint_b: Optional[TopoLinkEndpoint] = None
    endpoint_b_details: Optional[TopoOverlayEndpoint] = None
    key: Optional[str] = None
    labels: Optional[Dict[str, str]] = None
    name: Optional[str] = None
    namespace: Optional[str] = None
    overlays: Optional[Dict[str, TopoOverlayLinkState]] = None
    schema_: Annotated[Optional[TopoSchema], Field(alias="schema")] = None
    state: Optional[int] = None
    ui_name: Optional[str] = None


class TopoOverlayNode(BaseModel):
    attributes: Optional[Dict[str, Dict[str, Any]]] = None
    badges: Optional[List[int]] = None
    cr_name: Optional[str] = None
    grouping: Optional[TopoNodeGrouping] = None
    key: Optional[str] = None
    labels: Optional[Dict[str, str]] = None
    name: Optional[str] = None
    namespace: Optional[str] = None
    overlays: Optional[Dict[str, TopoOverlayNodeState]] = None
    schema_: Annotated[Optional[TopoSchema], Field(alias="schema")] = None
    state: Optional[int] = None
    ui_name: Optional[str] = None


class Topology(BaseModel):
    endpoints: Optional[TopoElemMetadata] = None
    group: Optional[str] = None
    grouping: Optional[TopoSchema] = None
    links: Optional[TopoElemMetadata] = None
    name: Optional[str] = None
    nodes: Optional[TopoElemMetadata] = None
    ui_description: Optional[str] = None
    ui_description_key: Optional[str] = None
    ui_name: Optional[str] = None
    ui_name_key: Optional[str] = None
    version: Optional[str] = None


class WorkflowInputData(RootModel[List[WorkflowInputDataElem]]):
    root: List[WorkflowInputDataElem]


class Fabric(BaseModel):
    """
    Fabric is the Schema for the fabrics API
    """

    apiVersion: str
    kind: str
    metadata: FabricMetadata
    spec: Annotated[
        FabricSpec,
        Field(
            description="The Fabric defines the desired state of a Fabric resource, enabling the automation and management of data center network fabrics. It includes configurations for IP address allocation pools, network topology roles (Leafs, Spines, SuperSpines, BorderLeafs), inter-switch links, and network protocols (underlay and overlay). The specification allows for detailed control over routing strategies, including ASN allocations for BGP-based protocols, and supports advanced features like BFD.",
            title="Specification",
        ),
    ]
    status: Annotated[
        Optional[FabricStatus],
        Field(
            description="FabricStatus defines the observed state of Fabric",
            title="Status",
        ),
    ] = None


class FabricList(BaseModel):
    """
    FabricList is a list of fabrics
    """

    apiVersion: str
    items: Optional[List[Fabric]] = None
    kind: str


class ISL(BaseModel):
    """
    ISL is the Schema for the isls API
    """

    apiVersion: str
    kind: str
    metadata: ISLMetadata
    spec: Annotated[
        ISLSpec,
        Field(
            description="The ISL enables the configuration and management of direct links between Nodes. This resource allows for specifying IPv4 and IPv6 allocation pools, enabling BFD for fast failure detection, and configuring VLAN IDs for the ISL. It also supports BGP peering between the endpoints, with options for setting autonomous systems, AFI/SAFI configurations, and import/export routing policies.",
            title="Specification",
        ),
    ]
    status: Annotated[
        Optional[ISLStatus],
        Field(
            description="ISLStatus defines the observed state of ISL", title="Status"
        ),
    ] = None


class ISLList(BaseModel):
    """
    ISLList is a list of isls
    """

    apiVersion: str
    items: Optional[List[ISL]] = None
    kind: str


class IslPing(BaseModel):
    """
    IslPing is the Schema for the islpings API
    """

    apiVersion: str
    kind: str
    metadata: IslPingMetadata
    spec: Annotated[
        IslPingSpec,
        Field(
            description="This workflow is used to ping ISLs (Inter-Switch Links) to verify connectivity within a Fabric.\nIt accepts a list of fabrics, ISLs, or selectors for both to match ISLs,\nand returns the results of the pings, including the status of each ISL.",
            title="Specification",
        ),
    ]
    status: Annotated[
        Optional[IslPingStatus],
        Field(
            description="IslPingStatus defines the observed state of IslPing",
            title="Status",
        ),
    ] = None


class IslPingList(BaseModel):
    """
    IslPingList is a list of islpings
    """

    apiVersion: str
    items: Optional[List[IslPing]] = None
    kind: str


class OverlayState(BaseModel):
    links: Optional[Dict[str, TopoOverlayLink]] = None
    nodes: Optional[Dict[str, TopoOverlayNode]] = None


class ResourceTopology(BaseModel):
    topology: Optional[OverlayState] = None
    topologyMetadata: Optional[Topology] = None
