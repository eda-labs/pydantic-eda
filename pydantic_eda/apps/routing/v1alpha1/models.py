# generated by datamodel-codegen:
#   filename:  routing.json

from __future__ import annotations

from typing import Annotated, Any, Dict, List, Literal, Optional

from pydantic import AwareDatetime, BaseModel, Field, RootModel


class AppGroupVersion(BaseModel):
    groupVersion: Optional[str] = None
    version: Optional[str] = None


class ErrorIndex(BaseModel):
    index: Optional[int] = None


class ErrorItem(BaseModel):
    error: Optional[Dict[str, Any]] = None
    type: Optional[str] = None


class ErrorResponse(BaseModel):
    """
    Generic error response for REST APIs
    """

    code: Annotated[
        int, Field(description="the numeric HTTP error code for the response.")
    ]
    details: Annotated[
        Optional[str], Field(description="The optional details of the error response.")
    ] = None
    dictionary: Annotated[
        Optional[Dict[str, Any]],
        Field(
            description='Dictionary/map of associated data/information relevant to the error.\nThe error "message" may contain {{name}} escapes that should be substituted\nwith information from this dictionary.'
        ),
    ] = None
    domain: Annotated[
        Optional[str],
        Field(
            description='The "domain" for the error.  If empty, it is an EDA\ncore error.  Alternatively it can be an EDA application\n"apiVersion" value (e.g. interfaces.eda.nokia.com/v1alpha1)\nindicating that the error is specific to that application.\nThe domain gives the receiver information that they can use\nto help them interpret the "internal" error code value, or\nto find an internationalization translation for the message.'
        ),
    ] = None
    errors: Annotated[
        Optional[List[ErrorItem]],
        Field(
            description="Collection of errors in cases where more than one exists. This needs to be\nflexible so we can support multiple formats"
        ),
    ] = None
    index: Optional[ErrorIndex] = None
    internal: Annotated[
        Optional[int],
        Field(
            description="Internal error code in cases where we don't have an array of errors"
        ),
    ] = None
    message: Annotated[
        str, Field(description="The basic text error message for the error response.")
    ]
    ref: Annotated[
        Optional[str],
        Field(
            description="Reference to the error source. Should typically be the URI of the request"
        ),
    ] = None
    type: Annotated[
        Optional[str],
        Field(
            description="URI pointing at a document that describes the error and mitigation steps\nIf there is no document, point to the RFC for the HTTP error code"
        ),
    ] = None


class K8SPatchOp(BaseModel):
    from_: Annotated[Optional[str], Field(alias="from")] = None
    op: str
    path: str
    value: Optional[Dict[str, Any]] = None
    x_permissive: Annotated[Optional[bool], Field(alias="x-permissive")] = None


class Patch(RootModel[List[K8SPatchOp]]):
    root: List[K8SPatchOp]


class Resource(BaseModel):
    kind: Optional[str] = None
    name: Optional[str] = None
    namespaced: Optional[bool] = None
    readOnly: Optional[bool] = None
    singularName: Optional[str] = None
    uiCategory: Optional[str] = None


class ResourceHistoryEntry(BaseModel):
    author: Optional[str] = None
    changeType: Optional[str] = None
    commitTime: Optional[AwareDatetime] = None
    hash: Optional[str] = None
    message: Optional[str] = None
    transactionId: Optional[int] = None


class ResourceList(BaseModel):
    apiVersion: Optional[str] = None
    groupVersion: Optional[str] = None
    kind: Optional[str] = None
    resources: Optional[List[Resource]] = None


class StatusDetails(BaseModel):
    group: Optional[str] = None
    kind: Optional[str] = None
    name: Optional[str] = None


class TopoAttrMetadata(BaseModel):
    type: Optional[str] = None
    ui_description: Optional[str] = None
    ui_description_key: Optional[str] = None
    ui_name: Optional[str] = None
    ui_name_key: Optional[str] = None


class TopoLinkEndpoint(BaseModel):
    endpoint: Optional[str] = None
    node: Optional[str] = None
    node_key: Optional[str] = None


class TopoNodeGrouping(BaseModel):
    group: Optional[str] = None
    tier: Optional[int] = None


class TopoOverlayEndpointState(BaseModel):
    state: Optional[int] = None


TopoOverlayLinkState = TopoOverlayEndpointState


class TopoOverlayNodeState(BaseModel):
    badges: Optional[List[int]] = None
    state: Optional[int] = None


class TopoSchema(BaseModel):
    group: Optional[str] = None
    kind: Optional[str] = None
    version: Optional[str] = None


class UIResult(RootModel[str]):
    root: str


class WorkflowGetInputsRespElem(BaseModel):
    ackPrompt: Optional[str] = None
    group: str
    kind: str
    name: str
    namespace: Optional[str] = None
    schemaPrompt: Optional[Dict[str, Any]] = None
    version: str


class WorkflowId(BaseModel):
    id: Annotated[
        Optional[int],
        Field(
            description="A workflow identifier; these are assigned by the system to a posted workflow."
        ),
    ] = None


class WorkflowIdentifier(BaseModel):
    group: str
    kind: str
    name: str
    namespace: Optional[str] = None
    version: str


class WorkflowInputDataElem(BaseModel):
    ack: Annotated[
        Optional[bool], Field(description="acknowledge or reject the input request")
    ] = None
    input: Annotated[
        Optional[Dict[str, Any]],
        Field(description="provide a json blob to the workflow"),
    ] = None
    subflow: Optional[WorkflowIdentifier] = None


class AttachmentLookupSpec(BaseModel):
    """
    This workflow is used to look up attachments (where an address is attached in the network) on a set of nodes.
    It takes an address, and an optional list of nodes (or node selectors - a list of label expressions) to perform the lookup on,
    and returns the matching attachments, including the node,
    network instance, prefix, interface, and next hop group ID.
    """

    address: Annotated[
        str,
        Field(
            description="Address to perform a lookup for.\nThis is a standard IPv4 or IPv6 address, excluding mask or prefix length, e.g. 12.0.0.1.",
            title="Address",
        ),
    ]
    networkInstance: Annotated[
        Optional[str],
        Field(
            description="Network Instance is the locally named network instance to use for the lookup.\nCan be omitted if the default network instance is to be used.",
            title="Network Instance",
        ),
    ] = None
    nodeSelectors: Annotated[
        Optional[List[str]],
        Field(
            description='NodeSelectors is a list of node selectors to execute lookups on.\nThis is a list of label expressions, e.g. ["eda.nokia.com/role=leaf", "eda.nokia.com/region=us-west"].',
            title="Node Selectors",
        ),
    ] = None
    nodes: Annotated[
        Optional[List[str]],
        Field(
            description="Nodes is a list of node names to execute lookups on.",
            title="Nodes",
        ),
    ] = None


class AttachmentLookupStatusResult(BaseModel):
    interface: Optional[str] = None
    networkInstance: Optional[str] = None
    nextHopGroupId: Optional[int] = None
    node: Optional[str] = None
    prefix: Optional[str] = None


class AttachmentLookupStatus(BaseModel):
    """
    AttachmentLookupStatus defines the observed state of AttachmentLookup
    """

    found: bool
    results: Optional[List[AttachmentLookupStatusResult]] = None


class AttachmentLookupMetadata(BaseModel):
    annotations: Optional[Dict[str, str]] = None
    labels: Optional[Dict[str, str]] = None
    name: Annotated[
        str,
        Field(
            max_length=253,
            pattern="^[a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*$",
        ),
    ]
    namespace: str


class DefaultInterfaceSpecBfd(BaseModel):
    """
    Enable or disable BFD on this DefaultInterface.
    """

    desiredMinTransmitInt: Annotated[
        int,
        Field(
            description="The minimum interval in microseconds between transmission of BFD control packets[default=1000000].",
            ge=10000,
            le=100000000,
            title="Transmit Interval",
        ),
    ]
    detectionMultiplier: Annotated[
        int,
        Field(
            description="The number of packets that must be missed to declare this session as down. [default=3]",
            ge=3,
            le=20,
            title="Multiplier",
        ),
    ]
    enabled: Annotated[
        bool,
        Field(
            description="Enable Biforward Detection[default=false].", title="Enabled"
        ),
    ]
    minEchoReceiveInterval: Annotated[
        int,
        Field(
            description="The minimum interval between echo packets the local node can receive in microseconds",
            ge=0,
            le=100000000,
            title="Minimum Echo Receive Interval",
        ),
    ]
    requiredMinReceive: Annotated[
        int,
        Field(
            description="The minimum interval in microseconds between received BFD control packets that this system should support.[default=1000000].",
            ge=10000,
            le=100000000,
            title="Receive Interval",
        ),
    ]
    ttl: Annotated[
        Optional[int],
        Field(
            description="Sets custom IP TTL or Hop Limit for multi-hop BFD sessions packets. Not appllicable to single-hop BFD sessions.",
            ge=2,
            le=255,
            title="IP TTL/Hop Limit",
        ),
    ] = None


class DefaultInterfaceSpecIpv4Address(BaseModel):
    ipPrefix: Annotated[
        str, Field(description="Address and mask to use", title="IP Prefix")
    ]
    primary: Annotated[
        Optional[bool],
        Field(
            description="Indicates which address to use as primary for broadcast",
            title="Primary",
        ),
    ] = None


DefaultInterfaceSpecIpv6Address = DefaultInterfaceSpecIpv4Address


class DefaultInterfaceSpec(BaseModel):
    """
    DefaultInterface enables the configuration of default interfaces, including Interface references, DefaultRouter, VLAN IDs, IP MTU settings, and options for IPv4 and IPv6 addresses. It also supports unnumbered interfaces and BFD (Bidirectional Forwarding Detection) configuration.
    """

    bfd: Annotated[
        Optional[DefaultInterfaceSpecBfd],
        Field(
            description="Enable or disable BFD on this DefaultInterface.",
            title="BFD Configuration",
        ),
    ] = None
    defaultRouter: Annotated[
        str, Field(description="Reference to a DefaultRouter.", title="Default Router")
    ]
    description: Annotated[
        Optional[str],
        Field(
            description="The description of the DefaultInterface.", title="Description"
        ),
    ] = None
    interface: Annotated[
        str,
        Field(
            description="Reference to an Interface to use for attachment.",
            title="Interface Reference",
        ),
    ]
    ipMTU: Annotated[
        Optional[int],
        Field(
            description="Set the IP MTU for the DefaultInterface.",
            ge=1280,
            le=9486,
            title="IP MTU",
        ),
    ] = None
    ipv4Addresses: Annotated[
        Optional[List[DefaultInterfaceSpecIpv4Address]],
        Field(
            description="List of IPv4 addresses in ip/mask form, e.g., 192.168.0.1/24.",
            title="IPv4 Addresses",
        ),
    ] = None
    ipv6Addresses: Annotated[
        Optional[List[DefaultInterfaceSpecIpv6Address]],
        Field(
            description="List of IPv6 addresses in ip/mask form, e.g., fc00::1/120.",
            title="IPv6 Addresses",
        ),
    ] = None
    unnumbered: Annotated[
        Optional[Literal["IPV6"]],
        Field(
            description="Enables the use of unnumbered interfaces on the ISL. For IPv6, no IP address are configured on the sub-interface and only the link local address will be used. If any allocation pool is specified for IPv6 that will take precedence and IPs will be assigned to the interfaces.  When using eBGP for an underlay protocol, the DefaultInterfaces which are a part of the ISL will be added to the BGP dynamic neighbor list.",
            title="Unnumbered",
        ),
    ] = None
    vlanID: Annotated[
        Optional[int],
        Field(
            description="VLAN to use with this DefaultInterface.",
            ge=1,
            le=4094,
            title="VLAN ID",
        ),
    ] = None


class DefaultInterfaceStatus(BaseModel):
    """
    DefaultInterfaceStatus defines the observed state of DefaultInterface
    """

    health: Annotated[
        Optional[int],
        Field(
            description="Indicates the health score of the DefaultInterface.",
            title="Health",
        ),
    ] = None
    healthScoreReason: Annotated[
        Optional[str],
        Field(
            description="Indicates the reason for the health score.",
            title="Health Score Reason",
        ),
    ] = None
    lastChange: Annotated[
        Optional[AwareDatetime],
        Field(
            description="Indicates when this Interface last changed state.",
            title="Last Change",
        ),
    ] = None
    operationalState: Annotated[
        Optional[str],
        Field(
            description="Indicates the current operational state of the DefaultInterface.",
            title="Operational State",
        ),
    ] = None


class DefaultInterfaceDeletedResourceEntry(BaseModel):
    commitTime: Optional[AwareDatetime] = None
    hash: Optional[str] = None
    name: Optional[str] = None
    namespace: Optional[str] = None
    transactionId: Optional[int] = None


class DefaultInterfaceDeletedResources(
    RootModel[List[DefaultInterfaceDeletedResourceEntry]]
):
    root: List[DefaultInterfaceDeletedResourceEntry]


DefaultInterfaceMetadata = AttachmentLookupMetadata


class DefaultRouterSpecBgpIpv4UnicastMultipath(BaseModel):
    """
    Enable multipath.
    """

    allowMultipleAS: Annotated[
        bool,
        Field(
            description="When set to true, BGP is allowed to build a multipath set using BGP routes with different neighbor AS (most recent AS in the AS_PATH), When set to false, BGP is only allowed to use non-best paths for ECMP if they meet the multipath criteria and they have the same neighbor AS as the best path.",
            title="Allow Multiple Autonomous Systems Per Path",
        ),
    ]
    maxAllowedPaths: Annotated[
        int,
        Field(
            description="The maximum number of BGP ECMP next-hops for BGP routes with an NLRI belonging to the address family of this configuration context.",
            ge=1,
            le=256,
            title="Maximum Number of Paths",
        ),
    ]


class DefaultRouterSpecBgpIpv4Unicast(BaseModel):
    """
    Parameters relating to the IPv4 unicast AFI/SAFI.
    """

    advertiseIPV6NextHops: Annotated[
        Optional[bool],
        Field(
            description="Enables advertisement of IPv4 Unicast routes with IPv6 next-hops to peers.",
            title="Advertise IPv6 Next Hops",
        ),
    ] = None
    enabled: Annotated[
        Optional[bool],
        Field(description="Enables the IPv4 unicast AFISAFI.", title="Enabled"),
    ] = None
    multipath: Annotated[
        Optional[DefaultRouterSpecBgpIpv4UnicastMultipath],
        Field(description="Enable multipath.", title="Multipath"),
    ] = None
    rapidUpdate: Annotated[
        Optional[bool], Field(description="Enables rapid update.", title="Rapid Update")
    ] = None
    receiveIPV6NextHops: Annotated[
        Optional[bool],
        Field(
            description="Enables the advertisement of the RFC 5549 capability to receive IPv4 routes with IPv6 next-hops.",
            title="Receive IPv6 Next Hops",
        ),
    ] = None


class DefaultRouterSpecBgpIpv6UnicastMultipath(BaseModel):
    """
    Enable multipath
    """

    allowMultipleAS: Annotated[
        bool,
        Field(
            description="When set to true, BGP is allowed to build a multipath set using BGP routes with different neighbor AS (most recent AS in the AS_PATH), When set to false, BGP is only allowed to use non-best paths for ECMP if they meet the multipath criteria and they have the same neighbor AS as the best path.",
            title="Allow Multiple Autonomous Systems Per Path",
        ),
    ]
    maxAllowedPaths: Annotated[
        int,
        Field(
            description="The maximum number of BGP ECMP next-hops for BGP routes with an NLRI belonging to the address family of this configuration context.",
            ge=1,
            le=256,
            title="Maximum Number of Paths",
        ),
    ]


class DefaultRouterSpecBgpIpv6Unicast(BaseModel):
    """
    Parameters relating to the IPv6 unicast AFI/SAFI.
    """

    enabled: Annotated[
        Optional[bool],
        Field(description="Enables the IPv6 unicast AFISAFI", title="Enabled"),
    ] = None
    multipath: Annotated[
        Optional[DefaultRouterSpecBgpIpv6UnicastMultipath],
        Field(description="Enable multipath", title="Multipath"),
    ] = None
    rapidUpdate: Annotated[
        Optional[bool], Field(description="Enables rapid update.", title="Rapid Update")
    ] = None


DefaultRouterSpecBgpL2VPNEVPNMultipath = DefaultRouterSpecBgpIpv6UnicastMultipath


class DefaultRouterSpecBgpL2VPNEVPN(BaseModel):
    """
    Parameters relating to the EVPN AFI/SAFI.
    """

    advertiseIPV6NextHops: Annotated[
        Optional[bool],
        Field(
            description="Enables advertisement of EVPN routes with IPv6 next-hops to peers.",
            title="Advertise IPv6 Next Hops",
        ),
    ] = None
    enabled: Annotated[
        Optional[bool],
        Field(description="Enables the L2VPN EVPN AFISAFI.", title="Enabled"),
    ] = None
    interASVPN: Annotated[
        Optional[bool],
        Field(description="Enable inter-AS VPN for EVPN.", title="EVPN InterAS VPN"),
    ] = False
    multipath: Annotated[
        Optional[DefaultRouterSpecBgpL2VPNEVPNMultipath],
        Field(description="Enable multipath", title="Multipath"),
    ] = None
    rapidUpdate: Annotated[
        Optional[bool], Field(description="Enables rapid update.", title="Rapid Update")
    ] = None


class DefaultRouterSpecBgp(BaseModel):
    """
    BGP configuration.
    """

    autonomousSystem: Annotated[
        Optional[int],
        Field(
            description="Autonomous System number for BGP.",
            ge=1,
            le=4294967295,
            title="Autonomous System",
        ),
    ] = None
    ebgpPreference: Annotated[
        Optional[int],
        Field(
            description="Preference to be set for eBGP.",
            ge=1,
            le=255,
            title="eBGP Preference",
        ),
    ] = 170
    enabled: Annotated[
        Optional[bool],
        Field(description="Enables BGP in the default VRF.", title="Enable BGP"),
    ] = False
    ibgpPreference: Annotated[
        Optional[int],
        Field(
            description="Preference to be set for iBGP.",
            ge=1,
            le=255,
            title="iBGP Preference",
        ),
    ] = 170
    ipv4Unicast: Annotated[
        Optional[DefaultRouterSpecBgpIpv4Unicast],
        Field(
            description="Parameters relating to the IPv4 unicast AFI/SAFI.",
            title="IPv4 Unicast",
        ),
    ] = None
    ipv6Unicast: Annotated[
        Optional[DefaultRouterSpecBgpIpv6Unicast],
        Field(
            description="Parameters relating to the IPv6 unicast AFI/SAFI.",
            title="IPv6 Unicast",
        ),
    ] = None
    keychain: Annotated[
        Optional[str],
        Field(description="Keychain to be used for authentication", title="Keychain"),
    ] = None
    l2VPNEVPN: Annotated[
        Optional[DefaultRouterSpecBgpL2VPNEVPN],
        Field(
            description="Parameters relating to the EVPN AFI/SAFI.", title="L2VPN EVPN"
        ),
    ] = None
    minWaitToAdvertise: Annotated[
        Optional[int],
        Field(
            description="Minimum wait time before advertising routes post BGP restart.",
            ge=0,
            le=3600,
            title="Min Wait To Advertise Time",
        ),
    ] = 0
    rapidWithdrawl: Annotated[
        Optional[bool],
        Field(
            description="Enable rapid withdrawal in BGP.",
            title="Enable Rapid Withdrawal",
        ),
    ] = False
    sendCommunityLarge: Annotated[
        Optional[bool],
        Field(
            description="When false, all large (12 byte) BGP communities from all outbound routes advertised to the peer are stripped.",
            title="Send Community Large",
        ),
    ] = None
    sendCommunityStandard: Annotated[
        Optional[bool],
        Field(
            description="When false, all standard (4 byte) communities from all outbound routes advertised to the peer are stripped.",
            title="Send Community Standard",
        ),
    ] = None
    waitForFibInstall: Annotated[
        Optional[bool],
        Field(
            description="Wait for FIB installation before advertising routes.",
            title="Wait for FIB Installation",
        ),
    ] = False


class DefaultRouterSpecRouteLeaking(BaseModel):
    """
    Route leaking controlled by routing policies in and out of the DefaultRouter.
    """

    exportPolicy: Annotated[
        str,
        Field(
            description="Reference to a Policy resource to use when evaluating route exports from the DefaultRouter.",
            title="Export Policy",
        ),
    ]
    importPolicy: Annotated[
        str,
        Field(
            description="Reference to a Policy resource to use when evaluating route imports into the DefaultRouter.",
            title="Import Policy",
        ),
    ]


class DefaultRouterSpec(BaseModel):
    """
    DefaultRouter enables the configuration of default routing instances on a specified Node, including options for BGP configuration, import and export policies, and router IDs.
    """

    bgp: Annotated[
        Optional[DefaultRouterSpecBgp],
        Field(description="BGP configuration.", title="BGP Configuration"),
    ] = None
    description: Annotated[
        Optional[str],
        Field(
            description="Sets the description on the Default router.",
            title="Description",
        ),
    ] = None
    exportPolicy: Annotated[
        Optional[List[str]],
        Field(
            description="Reference to a Policy resource to use when evaluating route exports from the DefaultRouter.",
            title="Export Policy",
        ),
    ] = None
    importPolicy: Annotated[
        Optional[List[str]],
        Field(
            description="Reference to a Policy resource to use when evaluating route imports into the DefaultRouter.",
            title="Import Policy",
        ),
    ] = None
    node: Annotated[
        str,
        Field(
            description="Reference to a TopoNode on which to configure the default routing instance.",
            title="Node",
        ),
    ]
    routeLeaking: Annotated[
        Optional[DefaultRouterSpecRouteLeaking],
        Field(
            description="Route leaking controlled by routing policies in and out of the DefaultRouter.",
            title="Route Leaking",
        ),
    ] = None
    routerID: Annotated[
        str, Field(description="Router ID in dotted quad notation.", title="Router ID")
    ]


class DefaultRouterStatus(BaseModel):
    """
    DefaultRouterStatus defines the observed state of DefaultRouter
    """

    health: Annotated[
        Optional[int],
        Field(description="Indicates the health score of the Router.", title="Health"),
    ] = None
    healthScoreReason: Annotated[
        Optional[str],
        Field(
            description="Indicates the reason for the health score.",
            title="Health Score Reason",
        ),
    ] = None
    lastChange: Annotated[
        Optional[AwareDatetime],
        Field(
            description="The time when the state of the resource last changed.",
            title="Last Change",
        ),
    ] = None
    operationalState: Annotated[
        Optional[str],
        Field(
            description="Operational state of the Router.", title="Operational State"
        ),
    ] = None


DefaultRouterDeletedResourceEntry = DefaultInterfaceDeletedResourceEntry


class DefaultRouterDeletedResources(RootModel[List[DefaultRouterDeletedResourceEntry]]):
    root: List[DefaultRouterDeletedResourceEntry]


DefaultRouterMetadata = AttachmentLookupMetadata


class DrainSpec(BaseModel):
    """
    Drain allows for the controlled disabling or draining of specific DefaultRouters, either by selecting them through labels or directly referencing them, ensuring traffic is safely rerouted or dropped before the routers are decommissioned.
    """

    defaultRouterSelector: Annotated[
        Optional[List[str]],
        Field(
            description="Selector to use when selecting DefaultRouters to drain.",
            title="Default Router Selector",
        ),
    ] = None
    defaultRouters: Annotated[
        Optional[List[str]],
        Field(
            description="Reference to DefaultRouters to drain.", title="Default Routers"
        ),
    ] = None
    enabled: Annotated[
        Optional[bool], Field(description="Enable this Drain.", title="Enabled")
    ] = True


class DrainStatus(BaseModel):
    """
    DrainStatus defines the observed state of Drain.
    """

    defaultRouters: Annotated[
        Optional[List[str]],
        Field(
            description="List of DefaultRouters this Drain has been applied to",
            title="Default Routers",
        ),
    ] = None


DrainDeletedResourceEntry = DefaultInterfaceDeletedResourceEntry


class DrainDeletedResources(RootModel[List[DrainDeletedResourceEntry]]):
    root: List[DrainDeletedResourceEntry]


DrainMetadata = AttachmentLookupMetadata


class RouteLookupSpec(BaseModel):
    """
    This workflow is used to look up routes on a set of nodes.
    It takes an address, and an optional list of nodes (or node selectors - a list of label expressions) to perform the lookup on,
    and returns the matching route, and the set of egress interfaces that would be used to reach it.
    """

    address: Annotated[
        str,
        Field(
            description="Address to perform a lookup for.\nThis is a standard IPv4 or IPv6 address, excluding mask or prefix length, e.g. 12.0.0.1.",
            title="Address",
        ),
    ]
    networkInstance: Annotated[
        Optional[str],
        Field(
            description="Network Instance is the locally named network instance to use for the lookup.\nCan be omitted if the default network instance is to be used.",
            title="Network Instance",
        ),
    ] = None
    nodeSelectors: Annotated[
        Optional[List[str]],
        Field(
            description='Node Selectors is a list of node label selectors to execute lookups on.\nThis is a list of label expressions, e.g. ["eda.nokia.com/role=leaf", "eda.nokia.com/region=us-west"].',
            title="Node Selectors",
        ),
    ] = None
    nodes: Annotated[
        Optional[List[str]],
        Field(
            description="Nodes is a list of node names to execute lookups on.",
            title="Nodes",
        ),
    ] = None
    resolve: Annotated[
        bool,
        Field(
            description="Resolve indicates whether indirect next hops should be resolved.",
            title="Resolve",
        ),
    ]


class RouteLookupStatusResultNextHopIndirect(BaseModel):
    ipPrefix: Optional[str] = None
    nextHopGroupId: Optional[int] = None
    resolved: Optional[bool] = None
    type: Optional[str] = None


class RouteLookupStatusResultNextHopInterface(BaseModel):
    name: Annotated[str, Field(description="Name of the egress interface.")]
    peerNode: Annotated[
        Optional[str], Field(description="The node this interface is connected to.")
    ] = None


class RouteLookupStatusResultNextHop(BaseModel):
    indirect: Optional[RouteLookupStatusResultNextHopIndirect] = None
    interfaces: Optional[List[RouteLookupStatusResultNextHopInterface]] = None
    ipAddress: Optional[str] = None
    nextHopId: Optional[int] = None
    type: Optional[str] = None


class RouteLookupStatusResult(BaseModel):
    error: Optional[str] = None
    found: bool
    networkInstance: Optional[str] = None
    nextHopGroupId: Optional[int] = None
    nextHops: Optional[List[RouteLookupStatusResultNextHop]] = None
    node: Optional[str] = None
    rawOutput: Optional[str] = None
    route: Optional[str] = None


class RouteLookupStatus(BaseModel):
    """
    RouteLookupStatus defines the observed state of RouteLookup
    """

    found: bool
    nodesWithRoute: Optional[int] = None
    results: Optional[List[RouteLookupStatusResult]] = None
    totalNodes: Optional[int] = None


RouteLookupMetadata = AttachmentLookupMetadata


class SystemInterfaceSpecBfd(BaseModel):
    """
    Enable or disable BFD on this SystemInterface.
    """

    desiredMinTransmitInt: Annotated[
        int,
        Field(
            description="The minimum interval in microseconds between transmission of BFD control packets[default=1000000].",
            ge=10000,
            le=100000000,
            title="Transmit Interval",
        ),
    ]
    detectionMultiplier: Annotated[
        int,
        Field(
            description="The number of packets that must be missed to declare this session as down. [default=3]",
            ge=3,
            le=20,
            title="Multiplier",
        ),
    ]
    enabled: Annotated[
        bool,
        Field(
            description="Enable Biforward Detection[default=false].", title="Enabled"
        ),
    ]
    minEchoReceiveInterval: Annotated[
        int,
        Field(
            description="The minimum interval between echo packets the local node can receive in microseconds",
            ge=0,
            le=100000000,
            title="Minimum Echo Receive Interval",
        ),
    ]
    requiredMinReceive: Annotated[
        int,
        Field(
            description="The minimum interval in microseconds between received BFD control packets that this system should support.[default=1000000].",
            ge=10000,
            le=100000000,
            title="Receive Interval",
        ),
    ]
    ttl: Annotated[
        Optional[int],
        Field(
            description="Sets custom IP TTL or Hop Limit for multi-hop BFD sessions packets. Not appllicable to single-hop BFD sessions.",
            ge=2,
            le=255,
            title="IP TTL/Hop Limit",
        ),
    ] = None


class SystemInterfaceSpec(BaseModel):
    """
    SystemInterfaceSpec defines the desired state of SystemInterface
    """

    bfd: Annotated[
        Optional[SystemInterfaceSpecBfd],
        Field(
            description="Enable or disable BFD on this SystemInterface.",
            title="BFD Configuration",
        ),
    ] = None
    defaultRouter: Annotated[
        str, Field(description="Reference to a DefaultRouter.", title="Default Router")
    ]
    description: Annotated[
        Optional[str],
        Field(
            description="The description of the SystemInterface.", title="Description"
        ),
    ] = None
    ipv4Address: Annotated[
        Optional[str],
        Field(
            description="IPv4 address in ip/mask form, e.g., 192.168.0.1/32.",
            title="IPv4 Address",
        ),
    ] = None
    ipv6Address: Annotated[
        Optional[str],
        Field(
            description="IPv6 address in ip/mask form, e.g., fc00::1/128.",
            title="IPv6 Address",
        ),
    ] = None


class SystemInterfaceStatus(BaseModel):
    """
    SystemInterfaceStatus defines the observed state of SystemInterface
    """

    health: Annotated[
        Optional[int],
        Field(
            description="Indicates the health score of the SystemInterface.",
            title="Health",
        ),
    ] = None
    healthScoreReason: Annotated[
        Optional[str],
        Field(
            description="Indicates the reason for the health score.",
            title="Health Score Reason",
        ),
    ] = None
    lastChange: Annotated[
        Optional[AwareDatetime],
        Field(
            description="Indicates when this Interface last changed state.",
            title="Last Change",
        ),
    ] = None
    operationalState: Annotated[
        Optional[str],
        Field(
            description="Indicates the current operational state of the SystemInterface.",
            title="Operational State",
        ),
    ] = None


SystemInterfaceDeletedResourceEntry = DefaultInterfaceDeletedResourceEntry


class SystemInterfaceDeletedResources(
    RootModel[List[SystemInterfaceDeletedResourceEntry]]
):
    root: List[SystemInterfaceDeletedResourceEntry]


SystemInterfaceMetadata = AttachmentLookupMetadata


class AppGroup(BaseModel):
    apiVersion: Optional[str] = None
    kind: Optional[str] = None
    name: Optional[str] = None
    preferredVersion: Optional[AppGroupVersion] = None
    versions: Optional[List[AppGroupVersion]] = None


class ResourceHistory(RootModel[List[ResourceHistoryEntry]]):
    root: List[ResourceHistoryEntry]


class Status(BaseModel):
    apiVersion: Optional[str] = None
    details: Optional[StatusDetails] = None
    kind: Optional[str] = None
    string: Optional[str] = None


class TopoElemMetadata(BaseModel):
    attributes: Optional[Dict[str, TopoAttrMetadata]] = None
    schema_: Annotated[Optional[TopoSchema], Field(alias="schema")] = None
    subtitle: Optional[str] = None
    subtitle_key: Optional[str] = None


class TopoOverlayEndpoint(BaseModel):
    attributes: Optional[Dict[str, Dict[str, Any]]] = None
    cr_name: Optional[str] = None
    labels: Optional[Dict[str, str]] = None
    name: Optional[str] = None
    namespace: Optional[str] = None
    overlays: Optional[Dict[str, TopoOverlayEndpointState]] = None
    schema_: Annotated[Optional[TopoSchema], Field(alias="schema")] = None
    state: Optional[int] = None
    ui_name: Optional[str] = None


class TopoOverlayLink(BaseModel):
    attributes: Optional[Dict[str, Dict[str, Any]]] = None
    cr_name: Optional[str] = None
    endpoint_a: Optional[TopoLinkEndpoint] = None
    endpoint_a_details: Optional[TopoOverlayEndpoint] = None
    endpoint_b: Optional[TopoLinkEndpoint] = None
    endpoint_b_details: Optional[TopoOverlayEndpoint] = None
    key: Optional[str] = None
    labels: Optional[Dict[str, str]] = None
    name: Optional[str] = None
    namespace: Optional[str] = None
    overlays: Optional[Dict[str, TopoOverlayLinkState]] = None
    schema_: Annotated[Optional[TopoSchema], Field(alias="schema")] = None
    state: Optional[int] = None
    ui_name: Optional[str] = None


class TopoOverlayNode(BaseModel):
    attributes: Optional[Dict[str, Dict[str, Any]]] = None
    badges: Optional[List[int]] = None
    cr_name: Optional[str] = None
    grouping: Optional[TopoNodeGrouping] = None
    key: Optional[str] = None
    labels: Optional[Dict[str, str]] = None
    name: Optional[str] = None
    namespace: Optional[str] = None
    overlays: Optional[Dict[str, TopoOverlayNodeState]] = None
    schema_: Annotated[Optional[TopoSchema], Field(alias="schema")] = None
    state: Optional[int] = None
    ui_name: Optional[str] = None


class Topology(BaseModel):
    endpoints: Optional[TopoElemMetadata] = None
    group: Optional[str] = None
    grouping: Optional[TopoSchema] = None
    links: Optional[TopoElemMetadata] = None
    name: Optional[str] = None
    nodes: Optional[TopoElemMetadata] = None
    ui_description: Optional[str] = None
    ui_description_key: Optional[str] = None
    ui_name: Optional[str] = None
    ui_name_key: Optional[str] = None
    version: Optional[str] = None


class WorkflowInputData(RootModel[List[WorkflowInputDataElem]]):
    root: List[WorkflowInputDataElem]


class AttachmentLookup(BaseModel):
    """
    AttachmentLookup is the Schema for the attachmentlookups API
    """

    apiVersion: str
    kind: str
    metadata: AttachmentLookupMetadata
    spec: Annotated[
        AttachmentLookupSpec,
        Field(
            description="This workflow is used to look up attachments (where an address is attached in the network) on a set of nodes.\nIt takes an address, and an optional list of nodes (or node selectors - a list of label expressions) to perform the lookup on,\nand returns the matching attachments, including the node,\nnetwork instance, prefix, interface, and next hop group ID.",
            title="Specification",
        ),
    ]
    status: Annotated[
        Optional[AttachmentLookupStatus],
        Field(
            description="AttachmentLookupStatus defines the observed state of AttachmentLookup",
            title="Status",
        ),
    ] = None


class AttachmentLookupList(BaseModel):
    """
    AttachmentLookupList is a list of attachmentlookups
    """

    apiVersion: str
    items: Optional[List[AttachmentLookup]] = None
    kind: str


class DefaultInterface(BaseModel):
    """
    DefaultInterface is the Schema for the defaultinterfaces API
    """

    apiVersion: str
    kind: str
    metadata: DefaultInterfaceMetadata
    spec: Annotated[
        DefaultInterfaceSpec,
        Field(
            description="DefaultInterface enables the configuration of default interfaces, including Interface references, DefaultRouter, VLAN IDs, IP MTU settings, and options for IPv4 and IPv6 addresses. It also supports unnumbered interfaces and BFD (Bidirectional Forwarding Detection) configuration.",
            title="Specification",
        ),
    ]
    status: Annotated[
        Optional[DefaultInterfaceStatus],
        Field(
            description="DefaultInterfaceStatus defines the observed state of DefaultInterface",
            title="Status",
        ),
    ] = None


class DefaultInterfaceList(BaseModel):
    """
    DefaultInterfaceList is a list of defaultinterfaces
    """

    apiVersion: str
    items: Optional[List[DefaultInterface]] = None
    kind: str


class DefaultRouter(BaseModel):
    """
    DefaultRouter is the Schema for the defaultrouters API
    """

    apiVersion: str
    kind: str
    metadata: DefaultRouterMetadata
    spec: Annotated[
        DefaultRouterSpec,
        Field(
            description="DefaultRouter enables the configuration of default routing instances on a specified Node, including options for BGP configuration, import and export policies, and router IDs.",
            title="Specification",
        ),
    ]
    status: Annotated[
        Optional[DefaultRouterStatus],
        Field(
            description="DefaultRouterStatus defines the observed state of DefaultRouter",
            title="Status",
        ),
    ] = None


class DefaultRouterList(BaseModel):
    """
    DefaultRouterList is a list of defaultrouters
    """

    apiVersion: str
    items: Optional[List[DefaultRouter]] = None
    kind: str


class Drain(BaseModel):
    """
    Drain is the Schema for the drains API
    """

    apiVersion: str
    kind: str
    metadata: DrainMetadata
    spec: Annotated[
        DrainSpec,
        Field(
            description="Drain allows for the controlled disabling or draining of specific DefaultRouters, either by selecting them through labels or directly referencing them, ensuring traffic is safely rerouted or dropped before the routers are decommissioned.",
            title="Specification",
        ),
    ]
    status: Annotated[
        Optional[DrainStatus],
        Field(
            description="DrainStatus defines the observed state of Drain.",
            title="Status",
        ),
    ] = None


class DrainList(BaseModel):
    """
    DrainList is a list of drains
    """

    apiVersion: str
    items: Optional[List[Drain]] = None
    kind: str


class RouteLookup(BaseModel):
    """
    RouteLookup is the Schema for the routelookups API
    """

    apiVersion: str
    kind: str
    metadata: RouteLookupMetadata
    spec: Annotated[
        RouteLookupSpec,
        Field(
            description="This workflow is used to look up routes on a set of nodes.\nIt takes an address, and an optional list of nodes (or node selectors - a list of label expressions) to perform the lookup on,\nand returns the matching route, and the set of egress interfaces that would be used to reach it.",
            title="Specification",
        ),
    ]
    status: Annotated[
        Optional[RouteLookupStatus],
        Field(
            description="RouteLookupStatus defines the observed state of RouteLookup",
            title="Status",
        ),
    ] = None


class RouteLookupList(BaseModel):
    """
    RouteLookupList is a list of routelookups
    """

    apiVersion: str
    items: Optional[List[RouteLookup]] = None
    kind: str


class SystemInterface(BaseModel):
    """
    SystemInterface is the Schema for the systeminterfaces API
    """

    apiVersion: str
    kind: str
    metadata: SystemInterfaceMetadata
    spec: Annotated[
        SystemInterfaceSpec,
        Field(
            description="SystemInterfaceSpec defines the desired state of SystemInterface",
            title="Specification",
        ),
    ]
    status: Annotated[
        Optional[SystemInterfaceStatus],
        Field(
            description="SystemInterfaceStatus defines the observed state of SystemInterface",
            title="Status",
        ),
    ] = None


class SystemInterfaceList(BaseModel):
    """
    SystemInterfaceList is a list of systeminterfaces
    """

    apiVersion: str
    items: Optional[List[SystemInterface]] = None
    kind: str


class OverlayState(BaseModel):
    links: Optional[Dict[str, TopoOverlayLink]] = None
    nodes: Optional[Dict[str, TopoOverlayNode]] = None


class ResourceTopology(BaseModel):
    topology: Optional[OverlayState] = None
    topologyMetadata: Optional[Topology] = None
