# generated by datamodel-codegen:
#   filename:  oam.json

from __future__ import annotations

from typing import Annotated, Any, Dict, List, Literal, Optional

from pydantic import AwareDatetime, BaseModel, Field, RootModel


class AppGroupVersion(BaseModel):
    groupVersion: Optional[str] = None
    version: Optional[str] = None


class ErrorIndex(BaseModel):
    index: Optional[int] = None


class ErrorItem(BaseModel):
    error: Optional[Dict[str, Any]] = None
    type: Optional[str] = None


class ErrorResponse(BaseModel):
    """
    Generic error response for REST APIs
    """

    code: Annotated[
        int, Field(description="the numeric HTTP error code for the response.")
    ]
    details: Annotated[
        Optional[str], Field(description="The optional details of the error response.")
    ] = None
    dictionary: Annotated[
        Optional[Dict[str, Any]],
        Field(
            description='Dictionary/map of associated data/information relevant to the error.\nThe error "message" may contain {{name}} escapes that should be substituted\nwith information from this dictionary.'
        ),
    ] = None
    domain: Annotated[
        Optional[str],
        Field(
            description='The "domain" for the error.  If empty, it is an EDA\ncore error.  Alternatively it can be an EDA application\n"apiVersion" value (e.g. interfaces.eda.nokia.com/v1alpha1)\nindicating that the error is specific to that application.\nThe domain gives the receiver information that they can use\nto help them interpret the "internal" error code value, or\nto find an internationalization translation for the message.'
        ),
    ] = None
    errors: Annotated[
        Optional[List[ErrorItem]],
        Field(
            description="Collection of errors in cases where more than one exists. This needs to be\nflexible so we can support multiple formats"
        ),
    ] = None
    index: Optional[ErrorIndex] = None
    internal: Annotated[
        Optional[int],
        Field(
            description="Internal error code in cases where we don't have an array of errors"
        ),
    ] = None
    message: Annotated[
        str, Field(description="The basic text error message for the error response.")
    ]
    ref: Annotated[
        Optional[str],
        Field(
            description="Reference to the error source. Should typically be the URI of the request"
        ),
    ] = None
    type: Annotated[
        Optional[str],
        Field(
            description="URI pointing at a document that describes the error and mitigation steps\nIf there is no document, point to the RFC for the HTTP error code"
        ),
    ] = None


class K8SPatchOp(BaseModel):
    from_: Annotated[Optional[str], Field(alias="from")] = None
    op: str
    path: str
    value: Optional[Dict[str, Any]] = None
    x_permissive: Annotated[Optional[bool], Field(alias="x-permissive")] = None


class Patch(RootModel[List[K8SPatchOp]]):
    root: List[K8SPatchOp]


class Resource(BaseModel):
    kind: Optional[str] = None
    name: Optional[str] = None
    namespaced: Optional[bool] = None
    readOnly: Optional[bool] = None
    singularName: Optional[str] = None
    uiCategory: Optional[str] = None


class ResourceHistoryEntry(BaseModel):
    author: Optional[str] = None
    changeType: Optional[str] = None
    commitTime: Optional[AwareDatetime] = None
    hash: Optional[str] = None
    message: Optional[str] = None
    transactionId: Optional[int] = None


class ResourceList(BaseModel):
    apiVersion: Optional[str] = None
    groupVersion: Optional[str] = None
    kind: Optional[str] = None
    resources: Optional[List[Resource]] = None


class StatusDetails(BaseModel):
    group: Optional[str] = None
    kind: Optional[str] = None
    name: Optional[str] = None


class TopoAttrMetadata(BaseModel):
    type: Optional[str] = None
    ui_description: Optional[str] = None
    ui_description_key: Optional[str] = None
    ui_name: Optional[str] = None
    ui_name_key: Optional[str] = None


class TopoLinkEndpoint(BaseModel):
    endpoint: Optional[str] = None
    node: Optional[str] = None
    node_key: Optional[str] = None


class TopoNodeGrouping(BaseModel):
    group: Optional[str] = None
    tier: Optional[int] = None


class TopoOverlayEndpointState(BaseModel):
    state: Optional[int] = None


TopoOverlayLinkState = TopoOverlayEndpointState


class TopoOverlayNodeState(BaseModel):
    badges: Optional[List[int]] = None
    state: Optional[int] = None


class TopoSchema(BaseModel):
    group: Optional[str] = None
    kind: Optional[str] = None
    version: Optional[str] = None


class UIResult(RootModel[str]):
    root: str


class WorkflowGetInputsRespElem(BaseModel):
    ackPrompt: Optional[str] = None
    group: str
    kind: str
    name: str
    namespace: Optional[str] = None
    schemaPrompt: Optional[Dict[str, Any]] = None
    version: str


class WorkflowId(BaseModel):
    id: Annotated[
        Optional[int],
        Field(
            description="A workflow identifier; these are assigned by the system to a posted workflow."
        ),
    ] = None


class WorkflowIdentifier(BaseModel):
    group: str
    kind: str
    name: str
    namespace: Optional[str] = None
    version: str


class WorkflowInputDataElem(BaseModel):
    ack: Annotated[
        Optional[bool], Field(description="acknowledge or reject the input request")
    ] = None
    input: Annotated[
        Optional[Dict[str, Any]],
        Field(description="provide a json blob to the workflow"),
    ] = None
    subflow: Optional[WorkflowIdentifier] = None


class MirrorSpecLocalDestination(BaseModel):
    """
    Local destination for the mirror, there can only be either a remote destination or local destination provisioned for a Mirror.
    """

    interface: Annotated[
        Optional[str],
        Field(
            description="Reference to an Interface resource to send the mirrored traffic to.  This must be on the same Node as the source.",
            title="Local Interface",
        ),
    ] = None
    vlanID: Annotated[
        Optional[str],
        Field(
            description="Single value between 0-4094 support, or the special keyword untagged.",
            title="VLAN ID",
        ),
    ] = None


class MirrorSpecRemoteDestination(BaseModel):
    """
    Remote destination for the mirror, there can only be either a remote destination or local destination provisioned for a Mirror.
    """

    defaultRouter: Annotated[
        Optional[str],
        Field(
            description="Specifies the DefaultRouter to reach the remote destination of the mirror, a Router and DefaultRouter reference cannot be set at the same time.",
            title="Default Router",
        ),
    ] = None
    destinationIP: Annotated[
        Optional[str],
        Field(
            description="Remote destination IP address.  When a remote destination is used for the mirror, the destinationIP is mandatory.",
            title="Destination IP",
        ),
    ] = None
    encapsulation: Annotated[
        Optional[Literal["L2OGRE", "L3OGRE"]], Field(title="Encapsulation")
    ] = None
    router: Annotated[
        Optional[str],
        Field(
            description="Specifies the Router to reach the remote destination of the mirror, a Router and DefaultRouter reference cannot be set at the same time.",
            title="Router",
        ),
    ] = None
    sourceIP: Annotated[
        Optional[str],
        Field(
            description="Source IP to use when sending a mirror to a remote destination.  When a remote destination us used for the mirror, the sourceIP is mandatory.",
            title="Source IP",
        ),
    ] = None


class MirrorSpecSourcesFilterFilterEntryIpEntryRateLimit(BaseModel):
    """
    Rate limit to apply when the action is 'RateLimit'.
    """

    burstSize: Annotated[
        Optional[int],
        Field(description="The maximum burst size in bytes.", title="Burst Size"),
    ] = None
    entrySpecificPolicer: Annotated[
        Optional[bool],
        Field(
            description="Controls policer instantiation: false for shared instance, true for per-entry instances",
            title="Entry Specific Policer",
        ),
    ] = False
    peakRate: Annotated[
        Optional[int],
        Field(description="The peak rate in kilobytes per second.", title="Peak Rate"),
    ] = None
    scope: Annotated[
        Optional[Literal["Global", "Subinterface"]],
        Field(
            description="Determines how the policer is applied across subinterfaces. Global applies the policer across all subinterfaces, while Subinterface applies it individually to each subinterface.",
            title="Scope",
        ),
    ] = "Global"


class MirrorSpecSourcesFilterFilterEntryIpEntry(BaseModel):
    action: Annotated[
        Optional[Literal["Drop", "Accept", "RateLimit"]],
        Field(
            description="An action to take, either 'Accept','Drop', or 'RateLimit'.",
            title="Action",
        ),
    ] = None
    destinationPortName: Annotated[
        Optional[
            Literal[
                "ACAP",
                "AFP-TCP",
                "ARNS",
                "ASF-RMCP",
                "ASHARE",
                "ATALK-RM",
                "AURP",
                "AUTH",
                "BFD",
                "BFD-ECHO",
                "BFTP",
                "BGMP",
                "BGP",
                "BOOTPC",
                "BOOTPS",
                "CCSO-NS",
                "CHARGEN",
                "CISCO-TDP",
                "CITADEL",
                "CLEARCASE",
                "COMMERCE",
                "COURIER",
                "DAYTIME",
                "DHCP-FAILOVER",
                "DHCPV6-CLIENT",
                "DHCPV6-SERVER",
                "DICOM",
                "DISCARD",
                "DNSIX",
                "DOMAIN",
                "DSP",
                "ECHO",
                "EPP",
                "ESRO",
                "EXEC",
                "FINGER",
                "FTP",
                "FTP-DATA",
                "FTPS",
                "FTPS-DATA",
                "GODI",
                "GOPHER",
                "GTP-C",
                "GTP-PRIME",
                "GTP-U",
                "HA-CLUSTER",
                "HOSTNAME",
                "HP-ALARM-MGR",
                "HTTP",
                "HTTP-ALT",
                "HTTP-MGMT",
                "HTTP-RPC",
                "HTTPS",
                "IEEE-MMS-SSL",
                "IMAP",
                "IMAP3",
                "IMAPS",
                "IPP",
                "IPSEC",
                "IPX",
                "IRC",
                "IRIS-BEEP",
                "ISAKMP",
                "ISAKMP-NAT",
                "ISCSI",
                "ISO-TSAP",
                "KERBEROS",
                "KERBEROS-ADM",
                "KLOGIN",
                "KPASSWD",
                "KSHELL",
                "L2TP",
                "LDAP",
                "LDAPS",
                "LDP",
                "LMP",
                "LOGIN",
                "LPD",
                "LSP-PING",
                "MAC-SERVER-ADM",
                "MATIP-A",
                "MATIP-B",
                "MICRO-BFD",
                "MICROSOFT-DS",
                "MOBILE-IP",
                "MONITOR",
                "MPP",
                "MS-EXCHANGE",
                "MSDP",
                "MSP",
                "MSSQL-M",
                "MSSQL-S",
                "MULTIHOP-BFD",
                "NAS",
                "NCP",
                "NETBIOS-DATA",
                "NETBIOS-NS",
                "NETBIOS-SS",
                "NETNEWS",
                "NETRJS-1",
                "NETRJS-2",
                "NETRJS-3",
                "NETRJS-4",
                "NETWALL",
                "NEW-RWHO",
                "NFS",
                "NNTP",
                "NNTPS",
                "NTP",
                "ODMR",
                "OLSR",
                "OPENVPN",
                "PIM-AUTO-RP",
                "PKIX-TIMESTAMP",
                "POP2",
                "POP3",
                "POP3S",
                "PPTP",
                "PRINT-SRV",
                "PTP-EVENT",
                "PTP-GENERAL",
                "QMTP",
                "QOTD",
                "RADIUS",
                "RADIUS-ACCT",
                "REMOTE-MAIL",
                "REMOTEFS",
                "REMOTECMD",
                "RIP",
                "RJE",
                "RLP",
                "RLZDB",
                "RMC",
                "RMONITOR",
                "RPC2PORTMAP",
                "RSYNC",
                "RTELNET",
                "RTSP",
                "SGMP",
                "SILC",
                "SMUX",
                "SNA-GW",
                "SNMP",
                "SNMP-TRAP",
                "SNPP",
                "SMTP",
                "SQL-SVCS",
                "SQL",
                "SSH",
                "SUBMISSION",
                "SUNRPC",
                "SVCLOC",
                "SYSLOG",
                "SYSTAT",
                "TACACS",
                "TALK",
                "TCPMUX",
                "TCPNETHASPSRV",
                "TFTP",
                "TIME",
                "TIMED",
                "UPS",
                "XDMCP",
                "XNS-CH",
                "XNS-MAIL",
                "XNS-TIME",
                "Z3950",
            ]
        ],
        Field(
            description="Destination port to match by name.",
            title="Destination Port Name",
        ),
    ] = None
    destinationPortNumber: Annotated[
        Optional[int],
        Field(
            description="Destination port to match by numerical value.",
            ge=0,
            le=65535,
            title="Destination Port Number",
        ),
    ] = None
    destinationPortOperator: Annotated[
        Optional[Literal["Equals", "GreaterOrEquals", "LessOrEquals"]],
        Field(
            description="Operator to use when matching destinationPort, either Equals, GreaterOrEquals, or LessOrEquals.",
            title="Destination Port Operator",
        ),
    ] = None
    destinationPortRange: Annotated[
        Optional[str],
        Field(
            description="Range of destination ports to match, in the format n-m, e.g. 100-200,  The start and end of the range must be port numbers.",
            title="Destination Port Range",
        ),
    ] = None
    destinationPrefix: Annotated[
        Optional[str],
        Field(description="Destination prefix to match.", title="Destination Prefix"),
    ] = None
    firstFragment: Annotated[
        Optional[bool],
        Field(description="Match the first fragment only.", title="First Fragment"),
    ] = None
    fragment: Annotated[
        Optional[bool], Field(description="Match any fragment.", title="Fragment")
    ] = None
    icmpCode: Annotated[
        Optional[List[int]],
        Field(
            description="Match a specific ICMP code, as a number between 0-255, e.g. 0.",
            max_length=255,
            min_length=0,
            title="ICMP Code",
        ),
    ] = None
    icmpTypeName: Annotated[
        Optional[
            Literal[
                "DestUnreachable",
                "Echo",
                "EchoReply",
                "EchoRequest",
                "McastRtrAdv",
                "McastRtrSolicit",
                "McastRtrTerm",
                "MldDone",
                "MldQuery",
                "MldReport",
                "MldV2",
                "NeighborAdvertise",
                "NeighborSolicit",
                "NodeInfoQuery",
                "NodeInfoResponse",
                "PacketTooBig",
                "ParamProblem",
                "Redirect",
                "RouterAdvertise",
                "RouterRenumber",
                "RouterSolicit",
                "SourceQuench",
                "TimeExceeded",
                "Timestamp",
                "TimestampReply",
            ]
        ],
        Field(
            description="Match a specific ICMP type by name, e.g. dest-unreachable.",
            title="ICMP Type Name",
        ),
    ] = None
    icmpTypeNumber: Annotated[
        Optional[int],
        Field(
            description="Match a specific ICMP type by number.",
            ge=0,
            le=255,
            title="ICMP Type Number",
        ),
    ] = None
    log: Annotated[
        Optional[bool],
        Field(description="Log the matches for this entry.", title="Log"),
    ] = None
    protocolName: Annotated[
        Optional[
            Literal[
                "AH",
                "EGP",
                "EIGRP",
                "ESP",
                "GGP",
                "GRE",
                "ICMP",
                "ICMP6",
                "IDRP",
                "IGMP",
                "IGP",
                "IPV4",
                "IPV6",
                "IPV6-DEST-OPTS",
                "IPV6-HOP",
                "L2TP",
                "MPLS-IN-IP",
                "NO-NEXT-HDR",
                "OSPF",
                "PIM",
                "ROHC",
                "RSVP",
                "SCTP",
                "ST",
                "TCP",
                "UDP",
                "VRRP",
            ]
        ],
        Field(
            description="Match a specific IP protocol name (specified in the type field of the IP header).",
            title="Protocol Name",
        ),
    ] = None
    protocolNumber: Annotated[
        Optional[int],
        Field(
            description="Match a specific IP protocol number (specified in the type field of the IP header).",
            ge=0,
            le=255,
            title="Protocol Number",
        ),
    ] = None
    rateLimit: Annotated[
        Optional[MirrorSpecSourcesFilterFilterEntryIpEntryRateLimit],
        Field(
            description="Rate limit to apply when the action is 'RateLimit'.",
            title="Rate Limit",
        ),
    ] = None
    sourcePortName: Annotated[
        Optional[
            Literal[
                "ACAP",
                "AFP-TCP",
                "ARNS",
                "ASF-RMCP",
                "ASHARE",
                "ATALK-RM",
                "AURP",
                "AUTH",
                "BFD",
                "BFD-ECHO",
                "BFTP",
                "BGMP",
                "BGP",
                "BOOTPC",
                "BOOTPS",
                "CCSO-NS",
                "CHARGEN",
                "CISCO-TDP",
                "CITADEL",
                "CLEARCASE",
                "COMMERCE",
                "COURIER",
                "DAYTIME",
                "DHCP-FAILOVER",
                "DHCPV6-CLIENT",
                "DHCPV6-SERVER",
                "DICOM",
                "DISCARD",
                "DNSIX",
                "DOMAIN",
                "DSP",
                "ECHO",
                "EPP",
                "ESRO",
                "EXEC",
                "FINGER",
                "FTP",
                "FTP-DATA",
                "FTPS",
                "FTPS-DATA",
                "GODI",
                "GOPHER",
                "GTP-C",
                "GTP-PRIME",
                "GTP-U",
                "HA-CLUSTER",
                "HOSTNAME",
                "HP-ALARM-MGR",
                "HTTP",
                "HTTP-ALT",
                "HTTP-MGMT",
                "HTTP-RPC",
                "HTTPS",
                "IEEE-MMS-SSL",
                "IMAP",
                "IMAP3",
                "IMAPS",
                "IPP",
                "IPSEC",
                "IPX",
                "IRC",
                "IRIS-BEEP",
                "ISAKMP",
                "ISAKMP-NAT",
                "ISCSI",
                "ISO-TSAP",
                "KERBEROS",
                "KERBEROS-ADM",
                "KLOGIN",
                "KPASSWD",
                "KSHELL",
                "L2TP",
                "LDAP",
                "LDAPS",
                "LDP",
                "LMP",
                "LOGIN",
                "LPD",
                "LSP-PING",
                "MAC-SERVER-ADM",
                "MATIP-A",
                "MATIP-B",
                "MICRO-BFD",
                "MICROSOFT-DS",
                "MOBILE-IP",
                "MONITOR",
                "MPP",
                "MS-EXCHANGE",
                "MSDP",
                "MSP",
                "MSSQL-M",
                "MSSQL-S",
                "MULTIHOP-BFD",
                "NAS",
                "NCP",
                "NETBIOS-DATA",
                "NETBIOS-NS",
                "NETBIOS-SS",
                "NETNEWS",
                "NETRJS-1",
                "NETRJS-2",
                "NETRJS-3",
                "NETRJS-4",
                "NETWALL",
                "NEW-RWHO",
                "NFS",
                "NNTP",
                "NNTPS",
                "NTP",
                "ODMR",
                "OLSR",
                "OPENVPN",
                "PIM-AUTO-RP",
                "PKIX-TIMESTAMP",
                "POP2",
                "POP3",
                "POP3S",
                "PPTP",
                "PRINT-SRV",
                "PTP-EVENT",
                "PTP-GENERAL",
                "QMTP",
                "QOTD",
                "RADIUS",
                "RADIUS-ACCT",
                "REMOTE-MAIL",
                "REMOTEFS",
                "REMOTECMD",
                "RIP",
                "RJE",
                "RLP",
                "RLZDB",
                "RMC",
                "RMONITOR",
                "RPC2PORTMAP",
                "RSYNC",
                "RTELNET",
                "RTSP",
                "SGMP",
                "SILC",
                "SMUX",
                "SNA-GW",
                "SNMP",
                "SNMP-TRAP",
                "SNPP",
                "SMTP",
                "SQL-SVCS",
                "SQL",
                "SSH",
                "SUBMISSION",
                "SUNRPC",
                "SVCLOC",
                "SYSLOG",
                "SYSTAT",
                "TACACS",
                "TALK",
                "TCPMUX",
                "TCPNETHASPSRV",
                "TFTP",
                "TIME",
                "TIMED",
                "UPS",
                "XDMCP",
                "XNS-CH",
                "XNS-MAIL",
                "XNS-TIME",
                "Z3950",
            ]
        ],
        Field(description="Source port to match by name.", title="Source Port Name"),
    ] = None
    sourcePortNumber: Annotated[
        Optional[int],
        Field(
            description="Source port to match by numerical value.",
            ge=0,
            le=65535,
            title="Source Port Number",
        ),
    ] = None
    sourcePortOperator: Annotated[
        Optional[Literal["Equals", "GreaterOrEquals", "LessOrEquals"]],
        Field(
            description="Operator to use when matching sourcePort, either Equals, GreaterOrEquals, or LessOrEquals.",
            title="Source Port Operator",
        ),
    ] = None
    sourcePortRange: Annotated[
        Optional[str],
        Field(
            description="Range of source ports to match, in the format n-m, e.g. 100-200.  The start and end of the range must be port numbers.",
            title="Source Port Range",
        ),
    ] = None
    sourcePrefix: Annotated[
        Optional[str],
        Field(description="Source prefix to match.", title="Source Prefix"),
    ] = None
    tcpFlags: Annotated[
        Optional[str],
        Field(
            description="Match TCP flags, usable with !, &, | and the flags RST, SYN, and ACK.",
            title="TCP Flags",
        ),
    ] = None


class MirrorSpecSourcesFilterFilterEntry(BaseModel):
    description: Annotated[
        Optional[str],
        Field(description="Description of the FilterEntry.", title="Description"),
    ] = None
    ipEntry: Annotated[
        Optional[MirrorSpecSourcesFilterFilterEntryIpEntry], Field(title="IP Entry")
    ] = None
    type: Annotated[
        Literal["IPV4", "IPV6", "Auto"],
        Field(
            description="Type of the entry which can be IPV4, IPV6 or Auto.",
            title="Type",
        ),
    ]


class MirrorSpecSourcesFilterFilter(BaseModel):
    """
    Emittes an MirrorFilter and uses the filter as a source for the Mirror.
    """

    entries: Annotated[
        List[MirrorSpecSourcesFilterFilterEntry],
        Field(
            description="Specifies the list of filter entries, in order.",
            title="Entries",
        ),
    ]
    statisticsPerEntry: Annotated[
        Optional[bool],
        Field(
            description="Enable or disable per-entry counters.",
            title="Per-entry counters",
        ),
    ] = None


class MirrorSpecSourcesFilterSubinterfacesSubinterface(BaseModel):
    index: Annotated[
        Optional[int],
        Field(
            description="Index of the sub-interface. This is ignored on a node running SROS.",
            title="Subinterface Index",
        ),
    ] = None
    interfaceName: Annotated[
        str,
        Field(
            description="Reference to an Interface resource, the combination of the Interface and the specified subinterface index will build the subinterface to be used as a source of traffic to be mirrored. A combination of VLANs, BridgeInterfaces and subinterfaces can be configured as sources together.",
            title="Interface Name",
        ),
    ]
    vlan: Annotated[
        Optional[str],
        Field(
            description="Reference to the VLAN resource under which the sub-interface is configured. This is mandatory when the sub-interface is on a node running SROS and ignored for all other node operating systems.",
            title="VLAN",
        ),
    ] = None


class MirrorSpecSourcesFilterSubinterfaces(BaseModel):
    """
    Subinterfaces on which to deploy the IPFilter to use as a source for the Mirror.
    """

    bridgeInterfaces: Annotated[
        Optional[List[str]],
        Field(
            description="List of BridgeInterfaces, all traffic from all BridgeInterfaces in the list will be used as sources to be mirrored. A combination of VLANs, BridgeInterfaces and subinterfaces can be configured as sources together.",
            title="Bridge Interfaces",
        ),
    ] = None
    subinterfaces: Annotated[
        Optional[List[MirrorSpecSourcesFilterSubinterfacesSubinterface]],
        Field(
            description="List of Interfaces and subinterface indices",
            title="Subinterfaces",
        ),
    ] = None
    vlans: Annotated[
        Optional[List[str]],
        Field(
            description="List of VLAN resources, all subinterfaces attached to the VLAN will be used as sources to be mirrored.  A combination of VLANs, BridgeInterfaces and subinterfaces can be configured as sources together.",
            title="VLAN",
        ),
    ] = None


class MirrorSpecSourcesFilter(BaseModel):
    filter: Annotated[
        Optional[MirrorSpecSourcesFilterFilter],
        Field(
            description="Emittes an MirrorFilter and uses the filter as a source for the Mirror.",
            title="Filter",
        ),
    ] = None
    subinterfaces: Annotated[
        Optional[MirrorSpecSourcesFilterSubinterfaces],
        Field(
            description="Subinterfaces on which to deploy the IPFilter to use as a source for the Mirror.",
            title="Subinterfaces",
        ),
    ] = None


class MirrorSpecSourcesInterfaces(BaseModel):
    """
    Reference to an Interface resource to be mirrored.  Traffic from the entire Interface will be mirrored for any selected Interfaces.
    """

    interfaceSelector: Annotated[
        Optional[List[str]],
        Field(
            description="Select Interfaces using a label selector to be mirrored.  Traffic from the entire Interface will be mirrored for any selected Interfaces.  If both a label selector is used and a list of Interfaces is provided, a combination of all selected and provided interfaces will be mirrored.",
            title="Interface Selector",
        ),
    ] = None
    interfaces: Annotated[
        Optional[List[str]],
        Field(
            description="List of Interfaces to be mirrored.  Traffic from the entire Interface will be mirrored for any selected Interfaces.  If both a label selector is used and a list of Interfaces is provided, a combination of all selected and provided interfaces will be mirrored.",
            title="Interfaces",
        ),
    ] = None


MirrorSpecSourcesSubinterfacesSubinterface = (
    MirrorSpecSourcesFilterSubinterfacesSubinterface
)


class MirrorSpecSourcesSubinterfaces(BaseModel):
    bridgeInterfaces: Annotated[
        Optional[List[str]],
        Field(
            description="List of BridgeInterfaces, all traffic from all BridgeInterfaces in the list will be used as sources to be mirrored. A combination of VLANs, BridgeInterfaces and subinterfaces can be configured as sources together.",
            title="Bridge Interfaces",
        ),
    ] = None
    subinterfaces: Annotated[
        Optional[List[MirrorSpecSourcesSubinterfacesSubinterface]],
        Field(
            description="List of Interfaces and subinterface indices",
            title="Subinterfaces",
        ),
    ] = None
    vlans: Annotated[
        Optional[List[str]],
        Field(
            description="List of VLAN resources, all subinterfaces attached to the VLAN will be used as sources to be mirrored.  A combination of VLANs, BridgeInterfaces and subinterfaces can be configured as sources together.",
            title="VLAN",
        ),
    ] = None


class MirrorSpecSources(BaseModel):
    """
    Mirror sources.
    """

    direction: Annotated[
        Literal["Ingress", "Egress", "IngressEgress"],
        Field(
            description="The direction of the traffic being mirrored.",
            title="Direction",
        ),
    ]
    filters: Annotated[
        Optional[List[MirrorSpecSourcesFilter]], Field(title="Filters")
    ] = None
    interfaces: Annotated[
        Optional[MirrorSpecSourcesInterfaces],
        Field(
            description="Reference to an Interface resource to be mirrored.  Traffic from the entire Interface will be mirrored for any selected Interfaces.",
            title="Interfaces",
        ),
    ] = None
    subinterfaces: Annotated[
        Optional[MirrorSpecSourcesSubinterfaces], Field(title="Subinterfaces")
    ] = None


class MirrorSpec(BaseModel):
    """
    Mirror allows for the configuration of mirroring sources, including interfaces, subinterfaces, and filters, as well as the destination for the mirrored traffic, which can be either local or remote.
    """

    localDestination: Annotated[
        Optional[MirrorSpecLocalDestination],
        Field(
            description="Local destination for the mirror, there can only be either a remote destination or local destination provisioned for a Mirror.",
            title="Local Destination",
        ),
    ] = None
    remoteDestination: Annotated[
        Optional[MirrorSpecRemoteDestination],
        Field(
            description="Remote destination for the mirror, there can only be either a remote destination or local destination provisioned for a Mirror.",
            title="Remote Destination",
        ),
    ] = None
    sources: Annotated[
        MirrorSpecSources, Field(description="Mirror sources.", title="Sources")
    ]


class MirrorStatusSubinterface(BaseModel):
    configuredSource: Annotated[
        Literal[
            "VLAN",
            "BridgeInterface",
            "Subinterface",
            "Interface",
            "FilterV4",
            "FilterV6",
        ],
        Field(
            description="Indicates what is driving the particular subinterface to be selected as a mirror source.",
            title="Configured Source",
        ),
    ]
    interface: Annotated[
        str, Field(description="Node specific interface name.", title="Interface")
    ]
    node: Annotated[str, Field(description="Reference to Node object.", title="Node")]
    operatingSystem: Annotated[
        str,
        Field(description="Operating System of the Node.", title="Operating System"),
    ]
    subinterfaceIndex: Annotated[
        Optional[int],
        Field(
            description="Index allocated to the subinterface which is being mirrored. If an interface is used as a source, this will not be set.",
            title="Subinterface Index",
        ),
    ] = None
    vlanID: Annotated[
        Optional[str],
        Field(description="vlan assigned to this subinterface.", title="VLAN ID"),
    ] = None


class MirrorStatus(BaseModel):
    """
    MirrorStatus defines the observed state of Mirror
    """

    lastChange: Annotated[
        Optional[AwareDatetime],
        Field(
            description="Indicates when this SubInterface last changed state.",
            title="Last Change",
        ),
    ] = None
    mirrorID: Annotated[
        Optional[str],
        Field(
            description="Mirror Identifier used as the name of the mirror.",
            title="MirrorID",
        ),
    ] = None
    numActiveInterfaces: Annotated[
        Optional[int],
        Field(
            description="Total number of active Interfaces used as sources of the mirror.",
            title="Number of Active Interfaces",
        ),
    ] = None
    numActiveSubinterfaces: Annotated[
        Optional[int],
        Field(
            description="Total number of active subinterfaces used as sources of the mirror.",
            title="Number of Active Subinterfaces",
        ),
    ] = None
    numActiveV4FilterSubinterfaces: Annotated[
        Optional[int],
        Field(
            description="Total number of active subinterfaces used as sources of the mirror derived from IPV4Filter associations.",
            title="Number of Active V4 Filter Subinterfaces",
        ),
    ] = None
    numActiveV6FilterSubinterfaces: Annotated[
        Optional[int],
        Field(
            description="Total number of active subinterfaces used as sources of the mirror derived from IPV6Filter associations.",
            title="Number of Active V6 Filter Subinterfaces",
        ),
    ] = None
    numActiveVLANSubinterfaces: Annotated[
        Optional[int],
        Field(
            description="Total number of active subinterfaces used as sources of the mirror derived from VLAN resource references.",
            title="Number of Active VLAN Subinterfaces",
        ),
    ] = None
    numberActiveBridgeInterfaces: Annotated[
        Optional[int],
        Field(
            description="Total number of active subinterfaces used as sources of the mirror derived from BridgeInterface resource references.",
            title="Number of Active Bridge Interfaces",
        ),
    ] = None
    operationalState: Annotated[
        Optional[str],
        Field(
            description="Indicates the current operational state of the Mirror instance.",
            title="Operational State",
        ),
    ] = None
    subinterfaces: Annotated[
        Optional[List[MirrorStatusSubinterface]],
        Field(description="List of members in this Interface.", title="Subinterfaces"),
    ] = None


class MirrorDeletedResourceEntry(BaseModel):
    commitTime: Optional[AwareDatetime] = None
    hash: Optional[str] = None
    name: Optional[str] = None
    namespace: Optional[str] = None
    transactionId: Optional[int] = None


class MirrorDeletedResources(RootModel[List[MirrorDeletedResourceEntry]]):
    root: List[MirrorDeletedResourceEntry]


class MirrorMetadata(BaseModel):
    annotations: Optional[Dict[str, str]] = None
    labels: Optional[Dict[str, str]] = None
    name: Annotated[
        str,
        Field(
            max_length=253,
            pattern="^[a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*$",
        ),
    ]
    namespace: str


class NewPingSpec(BaseModel):
    """
    Ping allows a ping to be initiated to a specific address on node/set of nodes.
    """

    address: Annotated[
        str,
        Field(
            description="Address to ping.\nThis is a single IP address (IPv4 or IPv6) or a hostname that resolves to an IP address.",
            title="Target Address",
        ),
    ]
    count: Annotated[
        Optional[int],
        Field(description="Count is the number of pings to send.", title="Count"),
    ] = 1
    networkInstance: Annotated[
        Optional[str],
        Field(
            description='The network instance to use for the ping. This is the named network instance on the node, typically "default" or some other base name.\nIf not specified, the default network instance will be used, which is typically the main/default/global network interface on the node.',
            title="Network Instance",
        ),
    ] = None
    nodeSelectors: Annotated[
        Optional[List[str]],
        Field(
            description="NodeSelectors is a list of node selectors to select nodes to perform pings on.\nThis matches labels on TopoNode resources, including those TopoNodes in the list of nodes that pings will be performed on.\nIf no nodes are specified, and no node selectors are specified, all nodes in the given namespace will be selected.",
            title="Node Selectors",
        ),
    ] = None
    nodes: Annotated[
        Optional[List[str]],
        Field(
            description="Nodes is a list of nodes to perform pings on.\nItems in the list should be the names of the nodes, where each node will have a ping performed on it.\nIf no nodes are specified, and no node selectors are specified, all nodes in the given namespace will be selected.",
            title="Nodes",
        ),
    ] = None
    timeoutSeconds: Annotated[
        Optional[int],
        Field(
            description="TimeoutSeconds is the timeout for the ping in seconds.",
            title="Timeout Seconds",
        ),
    ] = 5


class NewPingStatusDetailDetails(BaseModel):
    averageTimeNanoseconds: Annotated[
        Optional[int],
        Field(
            description="A Duration represents the elapsed time between two instants\nas an int64 nanosecond count. The representation limits the\nlargest representable duration to approximately 290 years."
        ),
    ] = None
    maxTimeNanoseconds: Annotated[
        Optional[int],
        Field(
            description="A Duration represents the elapsed time between two instants\nas an int64 nanosecond count. The representation limits the\nlargest representable duration to approximately 290 years."
        ),
    ] = None
    minTimeNanoseconds: Annotated[
        Optional[int],
        Field(
            description="A Duration represents the elapsed time between two instants\nas an int64 nanosecond count. The representation limits the\nlargest representable duration to approximately 290 years."
        ),
    ] = None
    received: Optional[int] = None
    sent: Optional[int] = None
    stdDevNanoseconds: Annotated[
        Optional[int],
        Field(
            description="A Duration represents the elapsed time between two instants\nas an int64 nanosecond count. The representation limits the\nlargest representable duration to approximately 290 years."
        ),
    ] = None
    totalTimeNanoseconds: Annotated[
        Optional[int],
        Field(
            description="A Duration represents the elapsed time between two instants\nas an int64 nanosecond count. The representation limits the\nlargest representable duration to approximately 290 years."
        ),
    ] = None


class NewPingStatusDetail(BaseModel):
    details: Optional[NewPingStatusDetailDetails] = None
    error: Optional[str] = None
    networkInstance: Optional[str] = None
    node: Optional[str] = None
    success: Optional[bool] = None


class NewPingStatus(BaseModel):
    """
    NewPingStatus defines the observed state of NewPing
    """

    details: Annotated[
        Optional[List[NewPingStatusDetail]],
        Field(
            description="Details contains the results of the pings performed on each node.\nEach entry in the list corresponds to a node that was pinged."
        ),
    ] = None
    result: Annotated[
        Optional[Literal["Success", "Failed", "PartialSuccess"]],
        Field(
            description='Result is the overall result of the ping operation.\nIt can be one of the following values:\n- "Success": All pings were successful.\n- "Failed": No pings were successful.\n- "PartialSuccess": Some pings were successful, but not all.',
            title="Result",
        ),
    ] = "Success"


NewPingMetadata = MirrorMetadata


class TechSupportSpec(BaseModel):
    """
    Generate technical support packages for a node or set of nodes.
    """

    nodeSelectors: Annotated[
        Optional[List[str]],
        Field(
            description='List of node selectors to select nodes generate technical support packages for.\nThis matches labels on TopoNode resources.\nIf no nodes are specified, and no node selectors are specified, all nodes in the given namespace will be selected.\nThis is a list of label expressions, e.g. ["eda.nokia.com/role=leaf"].',
            title="Node Selectors",
        ),
    ] = None
    nodes: Annotated[
        Optional[List[str]],
        Field(
            description="List of nodes to generate and collect technical support packages for.",
            title="Nodes",
        ),
    ] = None


class TechSupportStatus(BaseModel):
    """
    Result of the technical support package generation.
    """

    id: Annotated[Optional[int], Field(description="Id", title="ID")] = None
    result: Annotated[Optional[str], Field(description="Result", title="Result")] = None


TechSupportMetadata = MirrorMetadata


class ThresholdSpecAlarm(BaseModel):
    """
    Alarm details for this threshold.
    """

    description: Annotated[
        Optional[str],
        Field(description="The description of the alarm.", title="Description"),
    ] = None
    probableCause: Annotated[
        Optional[str],
        Field(description="The probable cause of the alarm.", title="Probable Cause"),
    ] = None
    remedialAction: Annotated[
        Optional[str],
        Field(
            description="The remedial action for the alarm.", title="Remedial Action"
        ),
    ] = None


class ThresholdSpecResource(BaseModel):
    """
    Which resource to associate with this threshold. This overrides the destination resource in alarms raised as a result of threshold breaches.
    By default a resource will attempt to be derived based on the monitored path.
    """

    group: Annotated[
        str, Field(description="The group of the resource to monitor.", title="Group")
    ]
    kind: Annotated[
        str, Field(description="The kind of resource to monitor.", title="Kind")
    ]
    name: Annotated[
        str, Field(description="The name of the resource to monitor.", title="Name")
    ]


class ThresholdSpecThresholds(BaseModel):
    """
    Severities and their associated values.
    """

    criticalThreshold: Annotated[
        Optional[int],
        Field(
            description="The minimum average utilization over the last 1 minute to trigger a critical alarm.\nThis value must be greater than the majorThreshold.",
            title="Critical Threshold",
        ),
    ] = None
    delta: Annotated[
        Optional[int],
        Field(
            description="The delta value for clearing a threshold.\nFor example, with a critical threshold of 90, direction of Rising and a delta of 5, the critical alarm will clear when the utilization drops below 85.",
            title="Delta",
        ),
    ] = 5
    direction: Annotated[
        Literal["Rising", "Falling"],
        Field(
            description='Direction of the threshold: "Rising" or "Falling".',
            title="Threshold Direction",
        ),
    ]
    majorThreshold: Annotated[
        Optional[int],
        Field(
            description="The minimum average utilization over the last 1 minute to trigger a major alarm.\nThis value must be greater than the minorThreshold.",
            title="Major Threshold",
        ),
    ] = None
    minorThreshold: Annotated[
        Optional[int],
        Field(
            description="The minimum average utilization over the last 1 minute to trigger a minor alarm.",
            title="Minor Threshold",
        ),
    ] = None
    warningThreshold: Annotated[
        Optional[int],
        Field(
            description="The minimum average utilization over the last 1 minute to trigger a warning alarm.",
            title="Warning Threshold",
        ),
    ] = None


class ThresholdSpec(BaseModel):
    """
    A Threshold allows you to monitor a field in EDB and trigger severity-correct alarms based on the value of that field.
    By using EDB as a source you are able to trigger thresholds on any published field from a TopoNode, or any other EDB source.
    """

    alarm: Annotated[
        Optional[ThresholdSpecAlarm],
        Field(description="Alarm details for this threshold.", title="Thresholds"),
    ] = None
    enabled: Annotated[
        Optional[bool],
        Field(description="Enable or disable this threshold.", title="Enabled"),
    ] = True
    field: Annotated[
        str,
        Field(
            description="Field to monitor for this threshold, for example `utilization`.",
            title="Field",
        ),
    ]
    generateOverlay: Annotated[
        Optional[bool],
        Field(
            description="Enable or disable generation of a topology overlay for this threshold.",
            title="Generate Overlay",
        ),
    ] = False
    name: Annotated[
        str,
        Field(
            description="The name of this threshold. This name will be used to generate the alarm name, so should follow CamelCase conventions, e.g. VolumeUtilization.",
            title="Threshold Name",
        ),
    ]
    path: Annotated[
        str,
        Field(
            description="Path to monitor for this threshold. This should be the full EDB path to the table containing the field you wish to trigger a threshold on.\nFor example, to monitor the utilization field of the component volume table, you would use `.namespace.node.normal.components_eda_nokia_com.v1.controlmodule.volume`, and set field to `utilization`.",
            title="Path",
        ),
    ]
    resource: Annotated[
        Optional[ThresholdSpecResource],
        Field(
            description="Which resource to associate with this threshold. This overrides the destination resource in alarms raised as a result of threshold breaches.\nBy default a resource will attempt to be derived based on the monitored path.",
            title="Associated Resource",
        ),
    ] = None
    thresholds: Annotated[
        ThresholdSpecThresholds,
        Field(
            description="Severities and their associated values.", title="Thresholds"
        ),
    ]


ThresholdDeletedResourceEntry = MirrorDeletedResourceEntry


class ThresholdDeletedResources(RootModel[List[ThresholdDeletedResourceEntry]]):
    root: List[ThresholdDeletedResourceEntry]


ThresholdMetadata = MirrorMetadata


class AppGroup(BaseModel):
    apiVersion: Optional[str] = None
    kind: Optional[str] = None
    name: Optional[str] = None
    preferredVersion: Optional[AppGroupVersion] = None
    versions: Optional[List[AppGroupVersion]] = None


class ResourceHistory(RootModel[List[ResourceHistoryEntry]]):
    root: List[ResourceHistoryEntry]


class Status(BaseModel):
    apiVersion: Optional[str] = None
    details: Optional[StatusDetails] = None
    kind: Optional[str] = None
    string: Optional[str] = None


class TopoElemMetadata(BaseModel):
    attributes: Optional[Dict[str, TopoAttrMetadata]] = None
    schema_: Annotated[Optional[TopoSchema], Field(alias="schema")] = None
    subtitle: Optional[str] = None
    subtitle_key: Optional[str] = None


class TopoOverlayEndpoint(BaseModel):
    attributes: Optional[Dict[str, Dict[str, Any]]] = None
    cr_name: Optional[str] = None
    labels: Optional[Dict[str, str]] = None
    name: Optional[str] = None
    namespace: Optional[str] = None
    overlays: Optional[Dict[str, TopoOverlayEndpointState]] = None
    schema_: Annotated[Optional[TopoSchema], Field(alias="schema")] = None
    state: Optional[int] = None
    ui_name: Optional[str] = None


class TopoOverlayLink(BaseModel):
    attributes: Optional[Dict[str, Dict[str, Any]]] = None
    cr_name: Optional[str] = None
    endpoint_a: Optional[TopoLinkEndpoint] = None
    endpoint_a_details: Optional[TopoOverlayEndpoint] = None
    endpoint_b: Optional[TopoLinkEndpoint] = None
    endpoint_b_details: Optional[TopoOverlayEndpoint] = None
    key: Optional[str] = None
    labels: Optional[Dict[str, str]] = None
    name: Optional[str] = None
    namespace: Optional[str] = None
    overlays: Optional[Dict[str, TopoOverlayLinkState]] = None
    schema_: Annotated[Optional[TopoSchema], Field(alias="schema")] = None
    state: Optional[int] = None
    ui_name: Optional[str] = None


class TopoOverlayNode(BaseModel):
    attributes: Optional[Dict[str, Dict[str, Any]]] = None
    badges: Optional[List[int]] = None
    cr_name: Optional[str] = None
    grouping: Optional[TopoNodeGrouping] = None
    key: Optional[str] = None
    labels: Optional[Dict[str, str]] = None
    name: Optional[str] = None
    namespace: Optional[str] = None
    overlays: Optional[Dict[str, TopoOverlayNodeState]] = None
    schema_: Annotated[Optional[TopoSchema], Field(alias="schema")] = None
    state: Optional[int] = None
    ui_name: Optional[str] = None


class Topology(BaseModel):
    endpoints: Optional[TopoElemMetadata] = None
    group: Optional[str] = None
    grouping: Optional[TopoSchema] = None
    links: Optional[TopoElemMetadata] = None
    name: Optional[str] = None
    nodes: Optional[TopoElemMetadata] = None
    ui_description: Optional[str] = None
    ui_description_key: Optional[str] = None
    ui_name: Optional[str] = None
    ui_name_key: Optional[str] = None
    version: Optional[str] = None


class WorkflowInputData(RootModel[List[WorkflowInputDataElem]]):
    root: List[WorkflowInputDataElem]


class Mirror(BaseModel):
    """
    Mirror is the Schema for the mirrors API
    """

    apiVersion: str
    kind: str
    metadata: MirrorMetadata
    spec: Annotated[
        MirrorSpec,
        Field(
            description="Mirror allows for the configuration of mirroring sources, including interfaces, subinterfaces, and filters, as well as the destination for the mirrored traffic, which can be either local or remote.",
            title="Specification",
        ),
    ]
    status: Annotated[
        Optional[MirrorStatus],
        Field(
            description="MirrorStatus defines the observed state of Mirror",
            title="Status",
        ),
    ] = None


class MirrorList(BaseModel):
    """
    MirrorList is a list of mirrors
    """

    apiVersion: str
    items: Optional[List[Mirror]] = None
    kind: str


class NewPing(BaseModel):
    """
    NewPing is the Schema for the newpings API
    """

    apiVersion: str
    kind: str
    metadata: NewPingMetadata
    spec: Annotated[
        NewPingSpec,
        Field(
            description="Ping allows a ping to be initiated to a specific address on node/set of nodes.",
            title="Specification",
        ),
    ]
    status: Annotated[
        Optional[NewPingStatus],
        Field(
            description="NewPingStatus defines the observed state of NewPing",
            title="Status",
        ),
    ] = None


class NewPingList(BaseModel):
    """
    NewPingList is a list of newpings
    """

    apiVersion: str
    items: Optional[List[NewPing]] = None
    kind: str


class TechSupport(BaseModel):
    """
    TechSupport is the Schema for the techsupports API
    """

    apiVersion: str
    kind: str
    metadata: TechSupportMetadata
    spec: Annotated[
        TechSupportSpec,
        Field(
            description="Generate technical support packages for a node or set of nodes.",
            title="Specification",
        ),
    ]
    status: Annotated[
        Optional[TechSupportStatus],
        Field(
            description="Result of the technical support package generation.",
            title="Status",
        ),
    ] = None


class TechSupportList(BaseModel):
    """
    TechSupportList is a list of techsupports
    """

    apiVersion: str
    items: Optional[List[TechSupport]] = None
    kind: str


class Threshold(BaseModel):
    """
    Threshold is the Schema for the thresholds API
    """

    apiVersion: str
    kind: str
    metadata: ThresholdMetadata
    spec: Annotated[
        ThresholdSpec,
        Field(
            description="A Threshold allows you to monitor a field in EDB and trigger severity-correct alarms based on the value of that field.\nBy using EDB as a source you are able to trigger thresholds on any published field from a TopoNode, or any other EDB source.",
            title="Specification",
        ),
    ]
    status: Annotated[
        Optional[Dict[str, Any]],
        Field(
            description="ThresholdStatus defines the observed state of Threshold",
            title="Status",
        ),
    ] = None


class ThresholdList(BaseModel):
    """
    ThresholdList is a list of thresholds
    """

    apiVersion: str
    items: Optional[List[Threshold]] = None
    kind: str


class OverlayState(BaseModel):
    links: Optional[Dict[str, TopoOverlayLink]] = None
    nodes: Optional[Dict[str, TopoOverlayNode]] = None


class ResourceTopology(BaseModel):
    topology: Optional[OverlayState] = None
    topologyMetadata: Optional[Topology] = None
