# generated by datamodel-codegen:
#   filename:  oam.json

from __future__ import annotations
from typing import Annotated, Any, Dict, List, Literal, Optional
from pydantic import BaseModel, Field, RootModel
from datetime import date


class AppGroupVersion(BaseModel):
    groupVersion: Optional[str] = None
    version: Optional[str] = None


class ErrorIndex(BaseModel):
    index: Optional[int] = None


class ErrorItem(BaseModel):
    error: Optional[Dict[str, Any]] = None
    type: Optional[str] = None


class ErrorResponse(BaseModel):
    """
    Generic error response for REST APIs
    """

    code: Annotated[
        int, Field(description="the numeric HTTP error code for the response.")
    ]
    details: Annotated[
        Optional[str], Field(description="The optional details of the error response.")
    ] = None
    dictionary: Annotated[
        Optional[Dict[str, Any]],
        Field(
            description='Dictionary/map of associated data/information relevant to the error.\nThe error "message" may contain {{name}} escapes that should be substituted\nwith information from this dictionary.'
        ),
    ] = None
    errors: Annotated[
        Optional[List[ErrorItem]],
        Field(
            description="Collection of errors in cases where more than one exists. This needs to be\nflexible so we can support multiple formats"
        ),
    ] = None
    index: Optional[ErrorIndex] = None
    internal: Annotated[
        Optional[int],
        Field(
            description="Internal error code in cases where we don't have an array of errors"
        ),
    ] = None
    message: Annotated[
        str, Field(description="The basic text error message for the error response.")
    ]
    ref: Annotated[
        Optional[str],
        Field(
            description="Reference to the error source. Should typically be the URI of the request"
        ),
    ] = None
    type: Annotated[
        Optional[str],
        Field(
            description="URI pointing at a document that describes the error and mitigation steps\nIf there is no document, point to the RFC for the HTTP error code"
        ),
    ] = None


class K8SPatchOp(BaseModel):
    from_: Annotated[Optional[str], Field(alias="from")] = None
    op: str
    path: str
    value: Optional[Dict[str, Any]] = None
    x_permissive: Annotated[Optional[bool], Field(alias="x-permissive")] = None


class Patch(RootModel[List[K8SPatchOp]]):
    root: List[K8SPatchOp]


class Resource(BaseModel):
    kind: Optional[str] = None
    name: Optional[str] = None
    namespaced: Optional[bool] = None
    readOnly: Optional[bool] = None
    singularName: Optional[str] = None
    uiCategory: Optional[str] = None


class ResourceHistoryEntry(BaseModel):
    author: Optional[str] = None
    changeType: Optional[str] = None
    commitTime: Optional[str] = None
    hash: Optional[str] = None
    message: Optional[str] = None
    transactionId: Optional[int] = None


class ResourceList(BaseModel):
    apiVersion: Optional[str] = None
    groupVersion: Optional[str] = None
    kind: Optional[str] = None
    resources: Optional[List[Resource]] = None


class StatusDetails(BaseModel):
    group: Optional[str] = None
    kind: Optional[str] = None
    name: Optional[str] = None


class UIResult(RootModel[str]):
    root: str


class MirrorSpecLocalDestination(BaseModel):
    """
    Local destination for the mirror, there can only be either a remote destination or local destination provisioned for a Mirror.
    """

    interface: Annotated[
        Optional[str],
        Field(
            description="Reference to an Interface resource to send the mirrored traffic to.  This must be on the same Node as the source.",
            title="Local Interface",
        ),
    ] = None
    vlanID: Annotated[
        Optional[str],
        Field(
            description="Single value between 0-4094 support, or the special keyword untagged.",
            title="VLAN ID",
        ),
    ] = None


class MirrorSpecRemoteDestination(BaseModel):
    """
    Remote destination for the mirror, there can only be either a remote destination or local destination provisioned for a Mirror.
    """

    defaultRouter: Annotated[
        Optional[str],
        Field(
            description="Specifies the DefaultRouter to reach the remote destination of the mirror, a Router and DefaultRouter reference cannot be set at the same time.",
            title="Default Router",
        ),
    ] = None
    destinationIP: Annotated[
        Optional[str],
        Field(
            description="Remote destination IP address.  When a remote destination is used for the mirror, the destinationIP is mandatory.",
            title="Destination IP",
        ),
    ] = None
    encapsulation: Annotated[
        Optional[Literal["L2OGRE", "L3OGRE"]], Field(title="Encapsulation")
    ] = None
    router: Annotated[
        Optional[str],
        Field(
            description="Specifies the Router to reach the remote destination of the mirror, a Router and DefaultRouter reference cannot be set at the same time.",
            title="Router",
        ),
    ] = None
    sourceIP: Annotated[
        Optional[str],
        Field(
            description="Source IP to use when sending a mirror to a remote destination.  When a remote destination us used for the mirror, the sourceIP is mandatory.",
            title="Source IP",
        ),
    ] = None


class MirrorSpecSourcesFilterFilterEntryIpEntryRateLimit(BaseModel):
    """
    Rate limit to apply when the action is 'RateLimit'.
    """

    burstSize: Annotated[
        Optional[int],
        Field(description="The maximum burst size in bytes.", title="Burst Size"),
    ] = None
    entrySpecificPolicer: Annotated[
        Optional[bool],
        Field(
            description="Controls policer instantiation: false for shared instance, true for per-entry instances",
            title="Entry Specific Policer",
        ),
    ] = False
    peakRate: Annotated[
        Optional[int],
        Field(description="The peak rate in kilobytes per second.", title="Peak Rate"),
    ] = None
    scope: Annotated[
        Optional[Literal["Global", "Subinterface"]],
        Field(
            description="Determines how the policer is applied across subinterfaces. Global applies the policer across all subinterfaces, while Subinterface applies it individually to each subinterface.",
            title="Scope",
        ),
    ] = "Global"


class MirrorSpecSourcesFilterFilterEntryIpEntry(BaseModel):
    action: Annotated[
        Optional[Literal["Drop", "Accept", "RateLimit"]],
        Field(
            description="An action to take, either 'Accept','Drop', or 'RateLimit'.",
            title="Action",
        ),
    ] = None
    destinationPortName: Annotated[
        Optional[
            Literal[
                "ACAP",
                "AFP-TCP",
                "ARNS",
                "ASF-RMCP",
                "ASHARE",
                "ATALK-RM",
                "AURP",
                "AUTH",
                "BFD",
                "BFD-ECHO",
                "BFTP",
                "BGMP",
                "BGP",
                "BOOTPC",
                "BOOTPS",
                "CCSO-NS",
                "CHARGEN",
                "CISCO-TDP",
                "CITADEL",
                "CLEARCASE",
                "COMMERCE",
                "COURIER",
                "DAYTIME",
                "DHCP-FAILOVER",
                "DHCPV6-CLIENT",
                "DHCPV6-SERVER",
                "DICOM",
                "DISCARD",
                "DNSIX",
                "DOMAIN",
                "DSP",
                "ECHO",
                "EPP",
                "ESRO",
                "EXEC",
                "FINGER",
                "FTP",
                "FTP-DATA",
                "FTPS",
                "FTPS-DATA",
                "GODI",
                "GOPHER",
                "GTP-C",
                "GTP-PRIME",
                "GTP-U",
                "HA-CLUSTER",
                "HOSTNAME",
                "HP-ALARM-MGR",
                "HTTP",
                "HTTP-ALT",
                "HTTP-MGMT",
                "HTTP-RPC",
                "HTTPS",
                "IEEE-MMS-SSL",
                "IMAP",
                "IMAP3",
                "IMAPS",
                "IPP",
                "IPSEC",
                "IPX",
                "IRC",
                "IRIS-BEEP",
                "ISAKMP",
                "ISAKMP-NAT",
                "ISCSI",
                "ISO-TSAP",
                "KERBEROS",
                "KERBEROS-ADM",
                "KLOGIN",
                "KPASSWD",
                "KSHELL",
                "L2TP",
                "LDAP",
                "LDAPS",
                "LDP",
                "LMP",
                "LOGIN",
                "LPD",
                "LSP-PING",
                "MAC-SERVER-ADM",
                "MATIP-A",
                "MATIP-B",
                "MICRO-BFD",
                "MICROSOFT-DS",
                "MOBILE-IP",
                "MONITOR",
                "MPP",
                "MS-EXCHANGE",
                "MSDP",
                "MSP",
                "MSSQL-M",
                "MSSQL-S",
                "MULTIHOP-BFD",
                "NAS",
                "NCP",
                "NETBIOS-DATA",
                "NETBIOS-NS",
                "NETBIOS-SS",
                "NETNEWS",
                "NETRJS-1",
                "NETRJS-2",
                "NETRJS-3",
                "NETRJS-4",
                "NETWALL",
                "NEW-RWHO",
                "NFS",
                "NNTP",
                "NNTPS",
                "NTP",
                "ODMR",
                "OLSR",
                "OPENVPN",
                "PIM-AUTO-RP",
                "PKIX-TIMESTAMP",
                "POP2",
                "POP3",
                "POP3S",
                "PPTP",
                "PRINT-SRV",
                "PTP-EVENT",
                "PTP-GENERAL",
                "QMTP",
                "QOTD",
                "RADIUS",
                "RADIUS-ACCT",
                "REMOTE-MAIL",
                "REMOTEFS",
                "REMOTECMD",
                "RIP",
                "RJE",
                "RLP",
                "RLZDB",
                "RMC",
                "RMONITOR",
                "RPC2PORTMAP",
                "RSYNC",
                "RTELNET",
                "RTSP",
                "SGMP",
                "SILC",
                "SMUX",
                "SNA-GW",
                "SNMP",
                "SNMP-TRAP",
                "SNPP",
                "SMTP",
                "SQL-SVCS",
                "SQL",
                "SSH",
                "SUBMISSION",
                "SUNRPC",
                "SVCLOC",
                "SYSLOG",
                "SYSTAT",
                "TACACS",
                "TALK",
                "TCPMUX",
                "TCPNETHASPSRV",
                "TFTP",
                "TIME",
                "TIMED",
                "UPS",
                "XDMCP",
                "XNS-CH",
                "XNS-MAIL",
                "XNS-TIME",
                "Z3950",
            ]
        ],
        Field(
            description="Destination port to match by name.",
            title="Destination Port Name",
        ),
    ] = None
    destinationPortNumber: Annotated[
        Optional[int],
        Field(
            description="Destination port to match by numerical value.",
            ge=0,
            le=65535,
            title="Destination Port Number",
        ),
    ] = None
    destinationPortOperator: Annotated[
        Optional[Literal["Equals", "GreaterOrEquals", "LessOrEquals"]],
        Field(
            description="Operator to use when matching destinationPort, either Equals, GreaterOrEquals, or LessOrEquals.",
            title="Destination Port Operator",
        ),
    ] = None
    destinationPortRange: Annotated[
        Optional[str],
        Field(
            description="Range of destination ports to match, in the format n-m, e.g. 100-200,  The start and end of the range must be port numbers.",
            title="Destination Port Range",
        ),
    ] = None
    destinationPrefix: Annotated[
        Optional[str],
        Field(description="Destination prefix to match.", title="Destination Prefix"),
    ] = None
    firstFragment: Annotated[
        Optional[bool],
        Field(description="Match the first fragment only.", title="First Fragment"),
    ] = None
    fragment: Annotated[
        Optional[bool], Field(description="Match any fragment.", title="Fragment")
    ] = None
    icmpCode: Annotated[
        Optional[List[int]],
        Field(
            description="Match a specific ICMP code, as a number between 0-255, e.g. 0.",
            max_length=255,
            min_length=0,
            title="ICMP Code",
        ),
    ] = None
    icmpTypeName: Annotated[
        Optional[
            Literal[
                "DestUnreachable",
                "Echo",
                "EchoReply",
                "EchoRequest",
                "McastRtrAdv",
                "McastRtrSolicit",
                "McastRtrTerm",
                "MldDone",
                "MldQuery",
                "MldReport",
                "MldV2",
                "NeighborAdvertise",
                "NeighborSolicit",
                "NodeInfoQuery",
                "NodeInfoResponse",
                "PacketTooBig",
                "ParamProblem",
                "Redirect",
                "RouterAdvertise",
                "RouterRenumber",
                "RouterSolicit",
                "SourceQuench",
                "TimeExceeded",
                "Timestamp",
                "TimestampReply",
            ]
        ],
        Field(
            description="Match a specific ICMP type by name, e.g. dest-unreachable.",
            title="ICMP Type Name",
        ),
    ] = None
    icmpTypeNumber: Annotated[
        Optional[int],
        Field(
            description="Match a specific ICMP type by number.",
            ge=0,
            le=255,
            title="ICMP Type Number",
        ),
    ] = None
    protocolName: Annotated[
        Optional[
            Literal[
                "AH",
                "EGP",
                "EIGRP",
                "ESP",
                "GGP",
                "GRE",
                "ICMP",
                "ICMP6",
                "IDRP",
                "IGMP",
                "IGP",
                "IPV4",
                "IPV6",
                "IPV6-DEST-OPTS",
                "IPV6-HOP",
                "L2TP",
                "MPLS-IN-IP",
                "NO-NEXT-HDR",
                "OSPF",
                "PIM",
                "ROHC",
                "RSVP",
                "SCTP",
                "ST",
                "TCP",
                "UDP",
                "VRRP",
            ]
        ],
        Field(
            description="Match a specific IP protocol name (specified in the type field of the IP header).",
            title="Protocol Name",
        ),
    ] = None
    protocolNumber: Annotated[
        Optional[int],
        Field(
            description="Match a specific IP protocol number (specified in the type field of the IP header).",
            ge=0,
            le=255,
            title="Protocol Number",
        ),
    ] = None
    rateLimit: Annotated[
        Optional[MirrorSpecSourcesFilterFilterEntryIpEntryRateLimit],
        Field(
            description="Rate limit to apply when the action is 'RateLimit'.",
            title="Rate Limit",
        ),
    ] = None
    sourcePortName: Annotated[
        Optional[
            Literal[
                "ACAP",
                "AFP-TCP",
                "ARNS",
                "ASF-RMCP",
                "ASHARE",
                "ATALK-RM",
                "AURP",
                "AUTH",
                "BFD",
                "BFD-ECHO",
                "BFTP",
                "BGMP",
                "BGP",
                "BOOTPC",
                "BOOTPS",
                "CCSO-NS",
                "CHARGEN",
                "CISCO-TDP",
                "CITADEL",
                "CLEARCASE",
                "COMMERCE",
                "COURIER",
                "DAYTIME",
                "DHCP-FAILOVER",
                "DHCPV6-CLIENT",
                "DHCPV6-SERVER",
                "DICOM",
                "DISCARD",
                "DNSIX",
                "DOMAIN",
                "DSP",
                "ECHO",
                "EPP",
                "ESRO",
                "EXEC",
                "FINGER",
                "FTP",
                "FTP-DATA",
                "FTPS",
                "FTPS-DATA",
                "GODI",
                "GOPHER",
                "GTP-C",
                "GTP-PRIME",
                "GTP-U",
                "HA-CLUSTER",
                "HOSTNAME",
                "HP-ALARM-MGR",
                "HTTP",
                "HTTP-ALT",
                "HTTP-MGMT",
                "HTTP-RPC",
                "HTTPS",
                "IEEE-MMS-SSL",
                "IMAP",
                "IMAP3",
                "IMAPS",
                "IPP",
                "IPSEC",
                "IPX",
                "IRC",
                "IRIS-BEEP",
                "ISAKMP",
                "ISAKMP-NAT",
                "ISCSI",
                "ISO-TSAP",
                "KERBEROS",
                "KERBEROS-ADM",
                "KLOGIN",
                "KPASSWD",
                "KSHELL",
                "L2TP",
                "LDAP",
                "LDAPS",
                "LDP",
                "LMP",
                "LOGIN",
                "LPD",
                "LSP-PING",
                "MAC-SERVER-ADM",
                "MATIP-A",
                "MATIP-B",
                "MICRO-BFD",
                "MICROSOFT-DS",
                "MOBILE-IP",
                "MONITOR",
                "MPP",
                "MS-EXCHANGE",
                "MSDP",
                "MSP",
                "MSSQL-M",
                "MSSQL-S",
                "MULTIHOP-BFD",
                "NAS",
                "NCP",
                "NETBIOS-DATA",
                "NETBIOS-NS",
                "NETBIOS-SS",
                "NETNEWS",
                "NETRJS-1",
                "NETRJS-2",
                "NETRJS-3",
                "NETRJS-4",
                "NETWALL",
                "NEW-RWHO",
                "NFS",
                "NNTP",
                "NNTPS",
                "NTP",
                "ODMR",
                "OLSR",
                "OPENVPN",
                "PIM-AUTO-RP",
                "PKIX-TIMESTAMP",
                "POP2",
                "POP3",
                "POP3S",
                "PPTP",
                "PRINT-SRV",
                "PTP-EVENT",
                "PTP-GENERAL",
                "QMTP",
                "QOTD",
                "RADIUS",
                "RADIUS-ACCT",
                "REMOTE-MAIL",
                "REMOTEFS",
                "REMOTECMD",
                "RIP",
                "RJE",
                "RLP",
                "RLZDB",
                "RMC",
                "RMONITOR",
                "RPC2PORTMAP",
                "RSYNC",
                "RTELNET",
                "RTSP",
                "SGMP",
                "SILC",
                "SMUX",
                "SNA-GW",
                "SNMP",
                "SNMP-TRAP",
                "SNPP",
                "SMTP",
                "SQL-SVCS",
                "SQL",
                "SSH",
                "SUBMISSION",
                "SUNRPC",
                "SVCLOC",
                "SYSLOG",
                "SYSTAT",
                "TACACS",
                "TALK",
                "TCPMUX",
                "TCPNETHASPSRV",
                "TFTP",
                "TIME",
                "TIMED",
                "UPS",
                "XDMCP",
                "XNS-CH",
                "XNS-MAIL",
                "XNS-TIME",
                "Z3950",
            ]
        ],
        Field(description="Source port to match by name.", title="Source Port Name"),
    ] = None
    sourcePortNumber: Annotated[
        Optional[int],
        Field(
            description="Source port to match by numerical value.",
            ge=0,
            le=65535,
            title="Source Port Number",
        ),
    ] = None
    sourcePortOperator: Annotated[
        Optional[Literal["Equals", "GreaterOrEquals", "LessOrEquals"]],
        Field(
            description="Operator to use when matching sourcePort, either Equals, GreaterOrEquals, or LessOrEquals.",
            title="Source Port Operator",
        ),
    ] = None
    sourcePortRange: Annotated[
        Optional[str],
        Field(
            description="Range of source ports to match, in the format n-m, e.g. 100-200.  The start and end of the range must be port numbers.",
            title="Source Port Range",
        ),
    ] = None
    sourcePrefix: Annotated[
        Optional[str],
        Field(description="Source prefix to match.", title="Source Prefix"),
    ] = None
    tcpFlags: Annotated[
        Optional[str],
        Field(
            description="Match TCP flags, usable with !, &, | and the flags RST, SYN, and ACK.",
            title="TCP Flags",
        ),
    ] = None


class MirrorSpecSourcesFilterFilterEntry(BaseModel):
    ipEntry: Annotated[
        Optional[MirrorSpecSourcesFilterFilterEntryIpEntry], Field(title="IP Entry")
    ] = None
    type: Annotated[Literal["IPV4", "IPV6", "Auto"], Field(title="Type")]


class MirrorSpecSourcesFilterFilter(BaseModel):
    """
    Emittes an MirrorFilter and uses the filter as a source for the Mirror.
    """

    entries: Annotated[
        List[MirrorSpecSourcesFilterFilterEntry],
        Field(
            description="Specifies the list of filter entries, in order.",
            title="Entries",
        ),
    ]


class MirrorSpecSourcesFilterSubinterfacesSubinterface(BaseModel):
    index: Annotated[
        Optional[int],
        Field(
            description="Index of the sub-interface. This is ignored on a node running SROS.",
            title="Subinterface Index",
        ),
    ] = None
    interfaceName: Annotated[
        str,
        Field(
            description="Reference to an Interface resource, the combination of the Interface and the specified subinterface index will build the subinterface to be used as a source of traffic to be mirrored. A combination of VLANs, BridgeInterfaces and subinterfaces can be configured as sources together.",
            title="Interface Name",
        ),
    ]
    vlan: Annotated[
        Optional[str],
        Field(
            description="Reference to the VLAN resource under which the sub-interface is configured. This is mandatory when the sub-interface is on a node running SROS and ignored for all other node operating systems.",
            title="VLAN",
        ),
    ] = None


class MirrorSpecSourcesFilterSubinterfaces(BaseModel):
    """
    Subinterfaces on which to deploy the IPFilter to use as a source for the Mirror.
    """

    bridgeInterfaces: Annotated[
        Optional[List[str]],
        Field(
            description="List of BridgeInterfaces, all traffic from all BridgeInterfaces in the list will be used as sources to be mirrored. A combination of VLANs, BridgeInterfaces and subinterfaces can be configured as sources together.",
            title="Bridge Interfaces",
        ),
    ] = None
    subinterfaces: Annotated[
        Optional[List[MirrorSpecSourcesFilterSubinterfacesSubinterface]],
        Field(
            description="List of Interfaces and subinterface indices",
            title="Subinterfaces",
        ),
    ] = None
    vlans: Annotated[
        Optional[List[str]],
        Field(
            description="List of VLAN resources, all subinterfaces attached to the VLAN will be used as sources to be mirrored.  A combination of VLANs, BridgeInterfaces and subinterfaces can be configured as sources together.",
            title="VLAN",
        ),
    ] = None


class MirrorSpecSourcesFilter(BaseModel):
    filter: Annotated[
        Optional[MirrorSpecSourcesFilterFilter],
        Field(
            description="Emittes an MirrorFilter and uses the filter as a source for the Mirror.",
            title="Filter",
        ),
    ] = None
    subinterfaces: Annotated[
        Optional[MirrorSpecSourcesFilterSubinterfaces],
        Field(
            description="Subinterfaces on which to deploy the IPFilter to use as a source for the Mirror.",
            title="Subinterfaces",
        ),
    ] = None


class MirrorSpecSourcesInterfaces(BaseModel):
    """
    Reference to an Interface resource to be mirrored.  Traffic from the entire Interface will be mirrored for any selected Interfaces.
    """

    interfaceSelector: Annotated[
        Optional[List[str]],
        Field(
            description="Select Interfaces using a label selector to be mirrored.  Traffic from the entire Interface will be mirrored for any selected Interfaces.  If both a label selector is used and a list of Interfaces is provided, a combination of all selected and provided interfaces will be mirrored.",
            title="Interface Selector",
        ),
    ] = None
    interfaces: Annotated[
        Optional[List[str]],
        Field(
            description="List of Interfaces to be mirrored.  Traffic from the entire Interface will be mirrored for any selected Interfaces.  If both a label selector is used and a list of Interfaces is provided, a combination of all selected and provided interfaces will be mirrored.",
            title="Interfaces",
        ),
    ] = None


MirrorSpecSourcesSubinterfacesSubinterface = (
    MirrorSpecSourcesFilterSubinterfacesSubinterface
)


class MirrorSpecSourcesSubinterfaces(BaseModel):
    bridgeInterfaces: Annotated[
        Optional[List[str]],
        Field(
            description="List of BridgeInterfaces, all traffic from all BridgeInterfaces in the list will be used as sources to be mirrored. A combination of VLANs, BridgeInterfaces and subinterfaces can be configured as sources together.",
            title="Bridge Interfaces",
        ),
    ] = None
    subinterfaces: Annotated[
        Optional[List[MirrorSpecSourcesSubinterfacesSubinterface]],
        Field(
            description="List of Interfaces and subinterface indices",
            title="Subinterfaces",
        ),
    ] = None
    vlans: Annotated[
        Optional[List[str]],
        Field(
            description="List of VLAN resources, all subinterfaces attached to the VLAN will be used as sources to be mirrored.  A combination of VLANs, BridgeInterfaces and subinterfaces can be configured as sources together.",
            title="VLAN",
        ),
    ] = None


class MirrorSpecSources(BaseModel):
    """
    Mirror sources.
    """

    direction: Annotated[
        Literal["Ingress", "Egress", "IngressEgress"],
        Field(
            description="The direction of the traffic being mirrored.",
            title="Direction",
        ),
    ]
    filters: Annotated[
        Optional[List[MirrorSpecSourcesFilter]], Field(title="Filters")
    ] = None
    interfaces: Annotated[
        Optional[MirrorSpecSourcesInterfaces],
        Field(
            description="Reference to an Interface resource to be mirrored.  Traffic from the entire Interface will be mirrored for any selected Interfaces.",
            title="Interfaces",
        ),
    ] = None
    subinterfaces: Annotated[
        Optional[MirrorSpecSourcesSubinterfaces], Field(title="Subinterfaces")
    ] = None


class MirrorSpec(BaseModel):
    """
    Mirror allows for the configuration of mirroring sources, including interfaces, subinterfaces, and filters, as well as the destination for the mirrored traffic, which can be either local or remote.
    """

    localDestination: Annotated[
        Optional[MirrorSpecLocalDestination],
        Field(
            description="Local destination for the mirror, there can only be either a remote destination or local destination provisioned for a Mirror.",
            title="Local Destination",
        ),
    ] = None
    remoteDestination: Annotated[
        Optional[MirrorSpecRemoteDestination],
        Field(
            description="Remote destination for the mirror, there can only be either a remote destination or local destination provisioned for a Mirror.",
            title="Remote Destination",
        ),
    ] = None
    sources: Annotated[
        MirrorSpecSources, Field(description="Mirror sources.", title="Sources")
    ]


class MirrorStatusSubinterface(BaseModel):
    configuredSource: Annotated[
        Literal[
            "VLAN",
            "BridgeInterface",
            "Subinterface",
            "Interface",
            "FilterV4",
            "FilterV6",
        ],
        Field(
            description="Indicates what is driving the particular subinterface to be selected as a mirror source.",
            title="Configured Source",
        ),
    ]
    interface: Annotated[
        str, Field(description="Node specific interface name.", title="Interface")
    ]
    node: Annotated[str, Field(description="Reference to Node object.", title="Node")]
    operatingSystem: Annotated[
        str,
        Field(description="Operating System of the Node.", title="Operating System"),
    ]
    subinterfaceIndex: Annotated[
        Optional[int],
        Field(
            description="Index allocated to the subinterface which is being mirrored. If an interface is used as a source, this will not be set.",
            title="Subinterface Index",
        ),
    ] = None
    vlanID: Annotated[
        Optional[str],
        Field(description="vlan assigned to this subinterface.", title="VLAN ID"),
    ] = None


class MirrorStatus(BaseModel):
    """
    MirrorStatus defines the observed state of Mirror
    """

    lastChange: Annotated[
        Optional[date],
        Field(
            description="Indicates when this SubInterface last changed state.",
            title="Last Change",
        ),
    ] = None
    mirrorID: Annotated[
        Optional[str],
        Field(
            description="Mirror Identifier used as the name of the mirror.",
            title="MirrorID",
        ),
    ] = None
    numActiveInterfaces: Annotated[
        Optional[int],
        Field(
            description="Total number of active Interfaces used as sources of the mirror.",
            title="Number of Active Interfaces",
        ),
    ] = None
    numActiveSubinterfaces: Annotated[
        Optional[int],
        Field(
            description="Total number of active subinterfaces used as sources of the mirror.",
            title="Number of Active Subinterfaces",
        ),
    ] = None
    numActiveV4FilterSubinterfaces: Annotated[
        Optional[int],
        Field(
            description="Total number of active subinterfaces used as sources of the mirror derived from IPV4Filter associations.",
            title="Number of Active V4 Filter Subinterfaces",
        ),
    ] = None
    numActiveV6FilterSubinterfaces: Annotated[
        Optional[int],
        Field(
            description="Total number of active subinterfaces used as sources of the mirror derived from IPV6Filter associations.",
            title="Number of Active V6 Filter Subinterfaces",
        ),
    ] = None
    numActiveVLANSubinterfaces: Annotated[
        Optional[int],
        Field(
            description="Total number of active subinterfaces used as sources of the mirror derived from VLAN resource references.",
            title="Number of Active VLAN Subinterfaces",
        ),
    ] = None
    numberActiveBridgeInterfaces: Annotated[
        Optional[int],
        Field(
            description="Total number of active subinterfaces used as sources of the mirror derived from BridgeInterface resource references.",
            title="Number of Active Bridge Interfaces",
        ),
    ] = None
    operationalState: Annotated[
        Optional[str],
        Field(
            description="Indicates the current operational state of the Mirror instance.",
            title="Operational State",
        ),
    ] = None
    subinterfaces: Annotated[
        Optional[List[MirrorStatusSubinterface]],
        Field(description="List of members in this Interface.", title="Subinterfaces"),
    ] = None


class MirrorDeletedResourceEntry(BaseModel):
    commitTime: Optional[str] = None
    hash: Optional[str] = None
    name: Optional[str] = None
    namespace: Optional[str] = None
    transactionId: Optional[int] = None


class MirrorDeletedResources(RootModel[List[MirrorDeletedResourceEntry]]):
    root: List[MirrorDeletedResourceEntry]


class MirrorMetadata(BaseModel):
    annotations: Optional[Dict[str, str]] = None
    labels: Optional[Dict[str, str]] = None
    name: Annotated[
        str,
        Field(
            max_length=253,
            pattern="^[a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*$",
        ),
    ]
    namespace: str


class PingSpec(BaseModel):
    """
    PingSpec defines the desired state of Ping
    """

    address: Annotated[Optional[str], Field(title="address")] = None
    networkInstance: Annotated[Optional[str], Field(title="NetworkInstance")] = None
    node: Annotated[Optional[str], Field(title="node")] = None
    pingType: Annotated[Literal["isl", "node", "system"], Field(title="pingtype")]
    pods: Annotated[Optional[List[str]], Field(title="Pods")] = None
    roles: Annotated[Optional[List[str]], Field(title="roles")] = None


class PingStatus(BaseModel):
    """
    PingStatus defines the observed state of Ping
    """

    id: Annotated[Optional[int], Field(description="Id", title="ID")] = None
    result: Annotated[
        Literal[
            "OK",
            "Failed",
            "Terminated",
            "WaitingForInput",
            "Running",
            "WaitingToStart",
            "SubflowWaitingForInput",
        ],
        Field(description="Aggregate result of the Flow", title="Result"),
    ]


PingDeletedResourceEntry = MirrorDeletedResourceEntry


class PingDeletedResources(RootModel[List[PingDeletedResourceEntry]]):
    root: List[PingDeletedResourceEntry]


PingMetadata = MirrorMetadata


class ThresholdSpecAlarm(BaseModel):
    """
    Alarm details for this threshold.
    """

    description: Annotated[
        Optional[str],
        Field(description="The description of the alarm.", title="Description"),
    ] = None
    probableCause: Annotated[
        Optional[str],
        Field(description="The probable cause of the alarm.", title="Probable Cause"),
    ] = None
    remedialAction: Annotated[
        Optional[str],
        Field(
            description="The remedial action for the alarm.", title="Remedial Action"
        ),
    ] = None


class ThresholdSpecResource(BaseModel):
    """
    Which resource to associate with this threshold. This overrides the destination resource in alarms raised as a result of threshold breaches.
    By default a resource will attempt to be derived based on the monitored path.
    """

    group: Annotated[
        str, Field(description="The group of the resource to monitor.", title="Group")
    ]
    kind: Annotated[
        str, Field(description="The kind of resource to monitor.", title="Kind")
    ]
    name: Annotated[
        str, Field(description="The name of the resource to monitor.", title="Name")
    ]


class ThresholdSpecThresholds(BaseModel):
    """
    Severities and their associated values.
    """

    criticalThreshold: Annotated[
        Optional[int],
        Field(
            description="The minimum average utilization over the last 1 minute to trigger a critical alarm.\nThis value must be greater than the majorThreshold.",
            title="Critical Threshold",
        ),
    ] = None
    delta: Annotated[
        Optional[int],
        Field(
            description="The delta value for clearing a threshold.\nFor example, with a critical threshold of 90, direction of Rising and a delta of 5, the critical alarm will clear when the utilization drops below 85.",
            title="Delta",
        ),
    ] = 5
    direction: Annotated[
        Literal["Rising", "Falling"],
        Field(
            description='Direction of the threshold: "Rising" or "Falling".',
            title="Threshold Direction",
        ),
    ]
    majorThreshold: Annotated[
        Optional[int],
        Field(
            description="The minimum average utilization over the last 1 minute to trigger a major alarm.\nThis value must be greater than the minorThreshold.",
            title="Major Threshold",
        ),
    ] = None
    minorThreshold: Annotated[
        Optional[int],
        Field(
            description="The minimum average utilization over the last 1 minute to trigger a minor alarm.",
            title="Minor Threshold",
        ),
    ] = None
    warningThreshold: Annotated[
        Optional[int],
        Field(
            description="The minimum average utilization over the last 1 minute to trigger a warning alarm.",
            title="Warning Threshold",
        ),
    ] = None


class ThresholdSpec(BaseModel):
    """
    A Threshold allows you to monitor a field in EDB and trigger severity-correct alarms based on the value of that field.
    By using EDB as a source you are able to trigger thresholds on any published field from a TopoNode, or any other EDB source.
    """

    alarm: Annotated[
        Optional[ThresholdSpecAlarm],
        Field(description="Alarm details for this threshold.", title="Thresholds"),
    ] = None
    enabled: Annotated[
        Optional[bool],
        Field(description="Enable or disable this threshold.", title="Enabled"),
    ] = True
    field: Annotated[
        str,
        Field(
            description="Field to monitor for this threshold, for example `utilization`.",
            title="Field",
        ),
    ]
    generateOverlay: Annotated[
        Optional[bool],
        Field(
            description="Enable or disable generation of a topology overlay for this threshold.",
            title="Generate Overlay",
        ),
    ] = False
    name: Annotated[
        str,
        Field(
            description="The name of this threshold. This name will be used to generate the alarm name, so should follow CamelCase conventions, e.g. VolumeUtilization.",
            title="Threshold Name",
        ),
    ]
    path: Annotated[
        str,
        Field(
            description="Path to monitor for this threshold. This should be the full EDB path to the table containing the field you wish to trigger a threshold on.\nFor example, to monitor the utilization field of the component volume table, you would use `.namespace.node.normal.components_eda_nokia_com.v1.controlmodule.volume`, and set field to `utilization`.",
            title="Path",
        ),
    ]
    resource: Annotated[
        Optional[ThresholdSpecResource],
        Field(
            description="Which resource to associate with this threshold. This overrides the destination resource in alarms raised as a result of threshold breaches.\nBy default a resource will attempt to be derived based on the monitored path.",
            title="Associated Resource",
        ),
    ] = None
    thresholds: Annotated[
        ThresholdSpecThresholds,
        Field(
            description="Severities and their associated values.", title="Thresholds"
        ),
    ]


ThresholdDeletedResourceEntry = MirrorDeletedResourceEntry


class ThresholdDeletedResources(RootModel[List[ThresholdDeletedResourceEntry]]):
    root: List[ThresholdDeletedResourceEntry]


ThresholdMetadata = MirrorMetadata


class AppGroup(BaseModel):
    apiVersion: Optional[str] = None
    kind: Optional[str] = None
    name: Optional[str] = None
    preferredVersion: Optional[AppGroupVersion] = None
    versions: Optional[List[AppGroupVersion]] = None


class ResourceHistory(RootModel[List[ResourceHistoryEntry]]):
    root: List[ResourceHistoryEntry]


class Status(BaseModel):
    apiVersion: Optional[str] = None
    details: Optional[StatusDetails] = None
    kind: Optional[str] = None
    string: Optional[str] = None


class Mirror(BaseModel):
    """
    Mirror is the Schema for the mirrors API
    """

    apiVersion: str
    kind: str
    metadata: MirrorMetadata
    spec: Annotated[
        MirrorSpec,
        Field(
            description="Mirror allows for the configuration of mirroring sources, including interfaces, subinterfaces, and filters, as well as the destination for the mirrored traffic, which can be either local or remote.",
            title="Specification",
        ),
    ]
    status: Annotated[
        Optional[MirrorStatus],
        Field(
            description="MirrorStatus defines the observed state of Mirror",
            title="Status",
        ),
    ] = None


class MirrorList(BaseModel):
    """
    MirrorList is a list of mirrors
    """

    apiVersion: str
    items: Optional[List[Mirror]] = None
    kind: str


class Ping(BaseModel):
    """
    Ping is the Schema for the pings API
    """

    apiVersion: str
    kind: str
    metadata: PingMetadata
    spec: Annotated[
        PingSpec,
        Field(
            description="PingSpec defines the desired state of Ping",
            title="Specification",
        ),
    ]
    status: Annotated[
        Optional[PingStatus],
        Field(
            description="PingStatus defines the observed state of Ping", title="Status"
        ),
    ] = None


class PingList(BaseModel):
    """
    PingList is a list of pings
    """

    apiVersion: str
    items: Optional[List[Ping]] = None
    kind: str


class Threshold(BaseModel):
    """
    Threshold is the Schema for the thresholds API
    """

    apiVersion: str
    kind: str
    metadata: ThresholdMetadata
    spec: Annotated[
        ThresholdSpec,
        Field(
            description="A Threshold allows you to monitor a field in EDB and trigger severity-correct alarms based on the value of that field.\nBy using EDB as a source you are able to trigger thresholds on any published field from a TopoNode, or any other EDB source.",
            title="Specification",
        ),
    ]
    status: Annotated[
        Optional[Dict[str, Any]],
        Field(
            description="ThresholdStatus defines the observed state of Threshold",
            title="Status",
        ),
    ] = None


class ThresholdList(BaseModel):
    """
    ThresholdList is a list of thresholds
    """

    apiVersion: str
    items: Optional[List[Threshold]] = None
    kind: str
