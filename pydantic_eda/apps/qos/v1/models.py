# generated by datamodel-codegen:
#   filename:  qos.json

from __future__ import annotations

from typing import Annotated, Any, Dict, List, Literal, Optional

from pydantic import AwareDatetime, BaseModel, Field, RootModel


class AppGroupVersion(BaseModel):
    groupVersion: Optional[str] = None
    version: Optional[str] = None


class ErrorIndex(BaseModel):
    index: Optional[int] = None


class ErrorItem(BaseModel):
    error: Optional[Dict[str, Any]] = None
    type: Optional[str] = None


class ErrorResponse(BaseModel):
    """
    Generic error response for REST APIs
    """

    code: Annotated[
        int, Field(description="the numeric HTTP error code for the response.")
    ]
    details: Annotated[
        Optional[str], Field(description="The optional details of the error response.")
    ] = None
    dictionary: Annotated[
        Optional[Dict[str, Any]],
        Field(
            description='Dictionary/map of associated data/information relevant to the error.\nThe error "message" may contain {{name}} escapes that should be substituted\nwith information from this dictionary.'
        ),
    ] = None
    domain: Annotated[
        Optional[str],
        Field(
            description='The "domain" for the error.  If empty, it is an EDA\ncore error.  Alternatively it can be an EDA application\n"apiVersion" value (e.g. interfaces.eda.nokia.com/v1alpha1)\nindicating that the error is specific to that application.\nThe domain gives the receiver information that they can use\nto help them interpret the "internal" error code value, or\nto find an internationalization translation for the message.'
        ),
    ] = None
    errors: Annotated[
        Optional[List[ErrorItem]],
        Field(
            description="Collection of errors in cases where more than one exists. This needs to be\nflexible so we can support multiple formats"
        ),
    ] = None
    index: Optional[ErrorIndex] = None
    internal: Annotated[
        Optional[int],
        Field(
            description="Internal error code in cases where we don't have an array of errors"
        ),
    ] = None
    message: Annotated[
        str, Field(description="The basic text error message for the error response.")
    ]
    ref: Annotated[
        Optional[str],
        Field(
            description="Reference to the error source. Should typically be the URI of the request"
        ),
    ] = None
    type: Annotated[
        Optional[str],
        Field(
            description="URI pointing at a document that describes the error and mitigation steps\nIf there is no document, point to the RFC for the HTTP error code"
        ),
    ] = None


class K8SPatchOp(BaseModel):
    from_: Annotated[Optional[str], Field(alias="from")] = None
    op: str
    path: str
    value: Optional[Dict[str, Any]] = None
    x_permissive: Annotated[Optional[bool], Field(alias="x-permissive")] = None


class Patch(RootModel[List[K8SPatchOp]]):
    root: List[K8SPatchOp]


class Resource(BaseModel):
    kind: Optional[str] = None
    name: Optional[str] = None
    namespaced: Optional[bool] = None
    readOnly: Optional[bool] = None
    singularName: Optional[str] = None
    uiCategory: Optional[str] = None


class ResourceHistoryEntry(BaseModel):
    author: Optional[str] = None
    changeType: Optional[str] = None
    commitTime: Optional[AwareDatetime] = None
    hash: Optional[str] = None
    message: Optional[str] = None
    transactionId: Optional[int] = None


class ResourceList(BaseModel):
    apiVersion: Optional[str] = None
    groupVersion: Optional[str] = None
    kind: Optional[str] = None
    resources: Optional[List[Resource]] = None


class StatusDetails(BaseModel):
    group: Optional[str] = None
    kind: Optional[str] = None
    name: Optional[str] = None


class TopoAttrMetadata(BaseModel):
    type: Optional[str] = None
    ui_description: Optional[str] = None
    ui_description_key: Optional[str] = None
    ui_name: Optional[str] = None
    ui_name_key: Optional[str] = None


class TopoLinkEndpoint(BaseModel):
    endpoint: Optional[str] = None
    node: Optional[str] = None
    node_key: Optional[str] = None


class TopoNodeGrouping(BaseModel):
    group: Optional[str] = None
    tier: Optional[int] = None


class TopoOverlayEndpointState(BaseModel):
    state: Optional[int] = None


TopoOverlayLinkState = TopoOverlayEndpointState


class TopoOverlayNodeState(BaseModel):
    badges: Optional[List[int]] = None
    state: Optional[int] = None


class TopoSchema(BaseModel):
    group: Optional[str] = None
    kind: Optional[str] = None
    version: Optional[str] = None


class UIResult(RootModel[str]):
    root: str


class EgressPolicySpecDot1pRewritePolicyDot1pMapItemDropProbabilityItem(BaseModel):
    level: Annotated[
        Optional[Literal["High", "Medium", "Low"]],
        Field(
            description="A drop probability level within the forwarding class for which a different remarking is desired",
            title="Level",
        ),
    ] = None
    pcpValue: Annotated[
        Optional[int],
        Field(
            description="The PCP value to be used for packets associated with the forwarding class and the specific drop probability. This overrides the general PCP value.",
            ge=0,
            le=7,
            title="PCP Value",
        ),
    ] = None


class EgressPolicySpecDot1pRewritePolicyDot1pMapItem(BaseModel):
    dropProbability: Annotated[
        Optional[
            List[EgressPolicySpecDot1pRewritePolicyDot1pMapItemDropProbabilityItem]
        ],
        Field(
            description="Drop probability specific overrides within the forwarding class",
            title="Drop Probability",
        ),
    ] = None
    forwardingClasses: Annotated[
        List[str],
        Field(
            description="The forwarding class matched to apply the rewrite policy",
            title="Forwarding Class",
        ),
    ]
    pcpValue: Annotated[
        Optional[int],
        Field(
            description="The PCP value to be used for all packets associated with the forwarding class, except those with a drop-probability-specific or profile-specific override",
            ge=0,
            le=7,
            title="PCP Value",
        ),
    ] = None


class EgressPolicySpecDot1pRewritePolicy(BaseModel):
    """
    Dot1pRewritePolicy enables the configuration of rewrite policies for Dot1p values. It includes mappings of forwarding classes to Dot1p values, with options for drop probability-specific overrides within each forwarding class.
    """

    dot1pMap: Annotated[
        List[EgressPolicySpecDot1pRewritePolicyDot1pMapItem],
        Field(description="Map of forwarding classes to PCP values", title="Map"),
    ]


class EgressPolicySpecDscpRewritePolicyDscpMapItemDropProbabilityItem(BaseModel):
    dscp: Annotated[
        Optional[int],
        Field(
            description="The DSCP value to be used for packets associated with the forwarding class and the specific drop probability. This overrides the general DSCP value.",
            ge=0,
            le=63,
            title="DSCP",
        ),
    ] = None
    level: Annotated[
        Optional[Literal["High", "Medium", "Low"]],
        Field(
            description="A drop probability level within the forwarding class for which a different remarking is desired.",
            title="Level",
        ),
    ] = None


class EgressPolicySpecDscpRewritePolicyDscpMapItem(BaseModel):
    dropProbability: Annotated[
        Optional[List[EgressPolicySpecDscpRewritePolicyDscpMapItemDropProbabilityItem]],
        Field(
            description="A drop probability within the forwarding class for which a different remarking is desired.",
            title="Drop Probability",
        ),
    ] = None
    dscp: Annotated[
        Optional[int],
        Field(
            description="The DSCP value to be used for all packets associated with the forwarding class, except those with a drop-probability-specific or profile-specific override.",
            ge=0,
            le=63,
            title="DSCP",
        ),
    ] = None
    forwardingClasses: Annotated[
        List[str],
        Field(
            description="The forwarding class matched to apply the rewrite policy.",
            title="Forwarding Class",
        ),
    ]


class EgressPolicySpecDscpRewritePolicy(BaseModel):
    """
    DSCPRewritePolicy enables the configuration of rewrite policies for Differentiated Services Code Point (DSCP) values. It includes mappings of forwarding classes to DSCP values, with options for drop probability-specific overrides within each forwarding class.  If a DSCPRewritePolicy is not specified, the DSCP value of the packet is unchanged. If a DSCP policy is specific and ECN is enabled on any of the queues, the DSCP policy will be applied to all ECN capable packets.
    """

    dscpMap: Annotated[
        List[EgressPolicySpecDscpRewritePolicyDscpMapItem],
        Field(description="Map of forwarding classes to DSCP values.", title="Map"),
    ]


class EgressPolicySpecForwardingClassToQueueMappingItem(BaseModel):
    forwardingClasses: Annotated[
        List[str],
        Field(
            description="The forwarding classes to which the mapping applies, these are references to ForwardingClass resources.",
            min_length=1,
            title="Forwarding Classes",
        ),
    ]
    queue: Annotated[
        str,
        Field(
            description="The queue to which the forwarding classes are mapped, this is a reference to a Queue resource.",
            title="Queue",
        ),
    ]
    queueGroup: Annotated[
        Optional[str],
        Field(
            description="The queue-group name for queue to forwarding class mapping.",
            title="Queue Group",
        ),
    ] = None


class EgressPolicySpecPfcDeadlockAvoidance(BaseModel):
    """
    Parameters related to avoid a deadlock related to pfc on outgoing interface.
    """

    deadlockAvoidance: Annotated[
        bool,
        Field(
            description="Parameters related to avoid a deadlock related to pfc on outgoing interface",
            title="Deadlock Avoidance",
        ),
    ]
    deadlockDetectionTimer: Annotated[
        int,
        Field(
            description="Number of milliseconds during which outgoing interface is receiving pfc-pause-frames before triggering recovery-timer.",
            title="Deadlock Detection Timer",
        ),
    ]
    deadlockRecoveryTimer: Annotated[
        int,
        Field(
            description="Number of milliseconds during which the pfc-pause-frames will be ignored.",
            title="Deadlock Recovery Timer",
        ),
    ]


class EgressPolicySpecQueueManagementItemQueue(BaseModel):
    committedBurstSize: Annotated[
        Optional[int],
        Field(description="Committed Burst Size.", title="Committed Burst Size"),
    ] = None
    maximumBurstSize: Annotated[
        int,
        Field(
            description="Maximum amount of shared buffer memory available to the queue in bytes.",
            ge=0,
            le=4294967295,
            title="Maximum Burst Size",
        ),
    ]
    pfcPauseFramePriority: Annotated[
        Optional[int],
        Field(
            description="The pfc-priority received in pfc-pause-frame.",
            title="PFC Priority",
        ),
    ] = None
    queue: Annotated[
        str, Field(description="Reference to a Queue resource.", title="Queue")
    ]
    schedulerPeakRatePercent: Annotated[
        Optional[int],
        Field(
            description="The peak rate percent used by the scheduler for the queue.",
            ge=1,
            le=100,
            title="Scheduler Peak Rate Percent",
        ),
    ] = None
    schedulerPriorityLevel: Annotated[
        Optional[int],
        Field(
            description="The priority level at this Port Scheduler Policy.",
            ge=1,
            le=8,
            title="Scheduler Priority Level",
        ),
    ] = None
    schedulerWeight: Annotated[
        Optional[int],
        Field(
            description="The weight factor used for the WRR scheduler. If any of the queues have a configured weight the set of queues will use a WRR scheduler and thus all queues must have a weight configured.  If no weights are set then the queues are scheduled in strict priority from lowest to higher queue ID.",
            ge=0,
            le=255,
            title="Scheduler Weight",
        ),
    ] = None


class EgressPolicySpecQueueManagementItemWredSlopPolicy(BaseModel):
    drop: Annotated[
        bool,
        Field(
            description="When set to true, and if the ECN field in the packet indicates that the endpoints are not ECN-capable, and the WRED algorithm determines that the packet should be dropped based on the drop probability, the packet will be dropped",
            title="Drop",
        ),
    ]
    dropProbability: Annotated[
        Literal["High", "Medium", "Low", "All"], Field(title="Drop Probability")
    ]
    ecn: Annotated[
        bool,
        Field(
            description="When set to true and the queue length is between the thresholds and the ECN field indicates ECN-capable endpoints, the CE bits are set to 1, and the packet is transmitted based on WRED. If false, such packets are discarded.",
            title="ECN",
        ),
    ]
    maxDropProbabilityPercent: Annotated[
        Optional[int],
        Field(
            description="If the queue depth is between min and max threshold then this the probability with which packets are dropped or marked.",
            title="Max Drop Probability Percent",
        ),
    ] = None
    maxThreshold: Annotated[
        Optional[int],
        Field(
            description="The maximum threshold parameter for a RED-managed queue in bytes. When the average queue length exceeds the max value, all packets are dropped (or marked if ECN is enabled). Mutually exclusive with min-threshold-percent and max-threshold-percent.",
            title="Max Threshold",
        ),
    ] = None
    maxThresholdPercent: Annotated[
        Optional[int],
        Field(
            description="The maximum threshold parameter for a RED-managed queue in percent. When the average queue length exceeds the max value, all packets are dropped (or marked if ECN is enabled). Mutually exclusive with min-threshold and max-threshold.",
            title="Max Threshold Percent",
        ),
    ] = None
    minThreshold: Annotated[
        Optional[int],
        Field(
            description="The mininum threshold parameter for a RED-managed queue in bytes. When the average queue length is less than min, all packets are admitted to the queue. Mututally exclusive with min-threshold-percent and max-threshold-percent.",
            title="Min Threshold",
        ),
    ] = None
    minThresholdPercent: Annotated[
        Optional[int],
        Field(
            description="The mininum threshold parameter for a RED-managed queue in percent. When the average queue length is less than min, all packets are admitted to the queue. Mutually exclusive with min-threshold and max-threshold.",
            title="Min Threshold Percent",
        ),
    ] = None
    trafficType: Annotated[
        Literal["Tcp", "NonTcp", "All"],
        Field(
            description="The traffic type to which the WRED slope applies.",
            title="Traffic Type",
        ),
    ]


class EgressPolicySpecQueueManagementItem(BaseModel):
    queues: Annotated[
        List[EgressPolicySpecQueueManagementItemQueue],
        Field(description="List of queues.", title="Queues"),
    ]
    slopePolicyWeight: Annotated[
        Optional[int],
        Field(
            description="The average queue size is calculated using both the previous average and the current queue size: average = (previous average)(1 - 2^(-n)) + (current size)(2^(-n)), where n is a user-configurable weight factor. A higher n gives more importance to the previous average, smoothing peaks and lows in the queue. Lower n makes the average closer to the current queue size. If this leaf is absent, the default value is used.",
            ge=0,
            le=15,
            title="Slope Policy Weight",
        ),
    ] = 0
    wredSlopPolicies: Annotated[
        Optional[List[EgressPolicySpecQueueManagementItemWredSlopPolicy]],
        Field(
            description="Slope policy to apply to the set of queues.",
            title="Slope Policy",
        ),
    ] = None


class EgressPolicySpec(BaseModel):
    """
    EgressPolicySpec defines the desired state of EgressPolicy
    """

    dot1pRewritePolicy: Annotated[
        Optional[EgressPolicySpecDot1pRewritePolicy],
        Field(
            description="Dot1pRewritePolicy enables the configuration of rewrite policies for Dot1p values. It includes mappings of forwarding classes to Dot1p values, with options for drop probability-specific overrides within each forwarding class.",
            title="Dot1p Rewrite Policy",
        ),
    ] = None
    dscpRewritePolicy: Annotated[
        Optional[EgressPolicySpecDscpRewritePolicy],
        Field(
            description="DSCPRewritePolicy enables the configuration of rewrite policies for Differentiated Services Code Point (DSCP) values. It includes mappings of forwarding classes to DSCP values, with options for drop probability-specific overrides within each forwarding class.  If a DSCPRewritePolicy is not specified, the DSCP value of the packet is unchanged. If a DSCP policy is specific and ECN is enabled on any of the queues, the DSCP policy will be applied to all ECN capable packets.",
            title="DSCP Rewrite Policy",
        ),
    ] = None
    forwardingClassToQueueMapping: Annotated[
        Optional[List[EgressPolicySpecForwardingClassToQueueMappingItem]],
        Field(
            description="Forwarding class to queue mapping policy.",
            title="Forwarding Class to Queue Mapping",
        ),
    ] = None
    pfcDeadlockAvoidance: Annotated[
        Optional[EgressPolicySpecPfcDeadlockAvoidance],
        Field(
            description="Parameters related to avoid a deadlock related to pfc on outgoing interface.",
            title="Deadlock Avoidance",
        ),
    ] = None
    queueManagement: Annotated[
        Optional[List[EgressPolicySpecQueueManagementItem]],
        Field(
            description="Queue management policy for egress queues.",
            title="Queue Management",
        ),
    ] = None


class EgressPolicyDeletedResourceEntry(BaseModel):
    commitTime: Optional[AwareDatetime] = None
    hash: Optional[str] = None
    name: Optional[str] = None
    namespace: Optional[str] = None
    transactionId: Optional[int] = None


class EgressPolicyDeletedResources(RootModel[List[EgressPolicyDeletedResourceEntry]]):
    root: List[EgressPolicyDeletedResourceEntry]


class EgressPolicyMetadata(BaseModel):
    annotations: Optional[Dict[str, str]] = None
    labels: Optional[Dict[str, str]] = None
    name: Annotated[
        str,
        Field(
            max_length=253,
            pattern="^[a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*$",
        ),
    ]
    namespace: str


ForwardingClassDeletedResourceEntry = EgressPolicyDeletedResourceEntry


class ForwardingClassDeletedResources(
    RootModel[List[ForwardingClassDeletedResourceEntry]]
):
    root: List[ForwardingClassDeletedResourceEntry]


ForwardingClassMetadata = EgressPolicyMetadata


class IngressPolicySpecClassifierEntryDot1pPolicyEntryPcpValue(BaseModel):
    rangeEnd: Annotated[
        Optional[int],
        Field(
            description="Optional end of PCP range (inclusive) which would start from the Value to the RangeEnd.",
            ge=0,
            le=7,
            title="PCP Range End",
        ),
    ] = None
    value: Annotated[
        int,
        Field(
            description="Single PCP value or start of range.",
            ge=0,
            le=7,
            title="PCP Value",
        ),
    ]


class IngressPolicySpecClassifierEntryDot1pPolicyEntry(BaseModel):
    """
    A Dot1p policy entry - only a single Dot1p entry is allowed per classifier resource.
    """

    directToPFCQueue: Annotated[
        Optional[bool],
        Field(
            description="In addition to creating a Dot1p PCP value to Forwarding Class mapping, this will map the PCP values directly to the PFC queue specified in the Forwarding Class to Queue mapping.",
            title="Direct to PFC Queue",
        ),
    ] = None
    dropProbabilityLevel: Annotated[
        Optional[Literal["High", "Medium", "Low"]],
        Field(
            description="Assign matching packets to the specified drop probability level.",
            title="Drop Probability Level",
        ),
    ] = "Low"
    forwardingClass: Annotated[
        Optional[str],
        Field(
            description="Reference to a ForwardingClass resource to which the value is mapped.",
            title="Forwarding Class",
        ),
    ] = None
    pcpValues: Annotated[
        List[IngressPolicySpecClassifierEntryDot1pPolicyEntryPcpValue],
        Field(
            description="List of PCP values or ranges used to match packets to classify into Forwarding Classes.",
            min_length=1,
            title="PCP Values",
        ),
    ]


class IngressPolicySpecClassifierEntryDscpPolicyEntryDscpValue(BaseModel):
    rangeEnd: Annotated[
        Optional[int],
        Field(
            description="Optional end of DSCP range (inclusive) which would start from the Value to the RangeEnd.",
            ge=0,
            le=63,
            title="DSCP Range End",
        ),
    ] = None
    value: Annotated[
        int,
        Field(
            description="Single DSCP value or start of range.",
            ge=0,
            le=63,
            title="DSCP Value",
        ),
    ]


class IngressPolicySpecClassifierEntryDscpPolicyEntry(BaseModel):
    """
    A DSCP policy entry - only a single DSCP entry is allowed per classifier resource.
    """

    dropProbabilityLevel: Annotated[
        Optional[Literal["High", "Medium", "Low"]],
        Field(
            description="Assign matching packets to the specified drop probability level.",
            title="Drop Probability Level",
        ),
    ] = "Low"
    dscpValues: Annotated[
        List[IngressPolicySpecClassifierEntryDscpPolicyEntryDscpValue],
        Field(
            description="List of DSCP values or ranges used to match packets to classify into Forwarding Classes.",
            min_length=1,
            title="DSCP Values",
        ),
    ]
    forwardingClass: Annotated[
        Optional[str],
        Field(
            description="Reference to a ForwardingClass resource to which the value is mapped.",
            title="Forwarding Class",
        ),
    ] = None


class IngressPolicySpecClassifierEntryIpEntryAction(BaseModel):
    """
    An action to take on the matched packets.
    """

    dropProbabilityLevel: Annotated[
        Optional[Literal["High", "Medium", "Low"]],
        Field(
            description="Assign matching packets to the specified drop probability level.",
            title="Drop Probability Level",
        ),
    ] = "Low"
    dscpRewriteValue: Annotated[
        Optional[int],
        Field(
            description="Rewrite actions associated with packets that match the classifier entry.",
            ge=0,
            le=63,
            title="DSCP Rewrite Value",
        ),
    ] = None
    forwardingClass: Annotated[
        Optional[str],
        Field(
            description="Reference to a ForwardingClass resource to which the value is mapped.",
            title="Forwarding Class",
        ),
    ] = None


class IngressPolicySpecClassifierEntryIpEntry(BaseModel):
    """
    An IPv4 or IPv6 multifield classifier entry.
    """

    action: Annotated[
        IngressPolicySpecClassifierEntryIpEntryAction,
        Field(description="An action to take on the matched packets.", title="Action"),
    ]
    destinationPortName: Annotated[
        Optional[
            Literal[
                "ACAP",
                "AFP-TCP",
                "ARNS",
                "ASF-RMCP",
                "ASHARE",
                "ATALK-RM",
                "AURP",
                "AUTH",
                "BFD",
                "BFD-ECHO",
                "BFTP",
                "BGMP",
                "BGP",
                "BOOTPC",
                "BOOTPS",
                "CCSO-NS",
                "CHARGEN",
                "CISCO-TDP",
                "CITADEL",
                "CLEARCASE",
                "COMMERCE",
                "COURIER",
                "DAYTIME",
                "DHCP-FAILOVER",
                "DHCPV6-CLIENT",
                "DHCPV6-SERVER",
                "DICOM",
                "DISCARD",
                "DNSIX",
                "DOMAIN",
                "DSP",
                "ECHO",
                "EPP",
                "ESRO",
                "EXEC",
                "FINGER",
                "FTP",
                "FTP-DATA",
                "FTPS",
                "FTPS-DATA",
                "GODI",
                "GOPHER",
                "GTP-C",
                "GTP-PRIME",
                "GTP-U",
                "HA-CLUSTER",
                "HOSTNAME",
                "HP-ALARM-MGR",
                "HTTP",
                "HTTP-ALT",
                "HTTP-MGMT",
                "HTTP-RPC",
                "HTTPS",
                "IEEE-MMS-SSL",
                "IMAP",
                "IMAP3",
                "IMAPS",
                "IPP",
                "IPSEC",
                "IPX",
                "IRC",
                "IRIS-BEEP",
                "ISAKMP",
                "ISAKMP-NAT",
                "ISCSI",
                "ISO-TSAP",
                "KERBEROS",
                "KERBEROS-ADM",
                "KLOGIN",
                "KPASSWD",
                "KSHELL",
                "L2TP",
                "LDAP",
                "LDAPS",
                "LDP",
                "LMP",
                "LOGIN",
                "LPD",
                "LSP-PING",
                "MAC-SERVER-ADM",
                "MATIP-A",
                "MATIP-B",
                "MICRO-BFD",
                "MICROSOFT-DS",
                "MOBILE-IP",
                "MONITOR",
                "MPP",
                "MS-EXCHANGE",
                "MSDP",
                "MSP",
                "MSSQL-M",
                "MSSQL-S",
                "MULTIHOP-BFD",
                "NAS",
                "NCP",
                "NETBIOS-DATA",
                "NETBIOS-NS",
                "NETBIOS-SS",
                "NETNEWS",
                "NETRJS-1",
                "NETRJS-2",
                "NETRJS-3",
                "NETRJS-4",
                "NETWALL",
                "NEW-RWHO",
                "NFS",
                "NNTP",
                "NNTPS",
                "NTP",
                "ODMR",
                "OLSR",
                "OPENVPN",
                "PIM-AUTO-RP",
                "PKIX-TIMESTAMP",
                "POP2",
                "POP3",
                "POP3S",
                "PPTP",
                "PRINT-SRV",
                "PTP-EVENT",
                "PTP-GENERAL",
                "QMTP",
                "QOTD",
                "RADIUS",
                "RADIUS-ACCT",
                "REMOTE-MAIL",
                "REMOTEFS",
                "REMOTECMD",
                "RIP",
                "RJE",
                "RLP",
                "RLZDB",
                "RMC",
                "RMONITOR",
                "RPC2PORTMAP",
                "RSYNC",
                "RTELNET",
                "RTSP",
                "SGMP",
                "SILC",
                "SMUX",
                "SNA-GW",
                "SNMP",
                "SNMP-TRAP",
                "SNPP",
                "SMTP",
                "SQL-SVCS",
                "SQL",
                "SSH",
                "SUBMISSION",
                "SUNRPC",
                "SVCLOC",
                "SYSLOG",
                "SYSTAT",
                "TACACS",
                "TALK",
                "TCPMUX",
                "TCPNETHASPSRV",
                "TFTP",
                "TIME",
                "TIMED",
                "UPS",
                "XDMCP",
                "XNS-CH",
                "XNS-MAIL",
                "XNS-TIME",
                "Z3950",
            ]
        ],
        Field(
            description="Destination port to match by name.",
            title="Destination Port Name",
        ),
    ] = None
    destinationPortNumber: Annotated[
        Optional[int],
        Field(
            description="Destination port to match by numerical value.",
            ge=0,
            le=65535,
            title="Destination Port Number",
        ),
    ] = None
    destinationPortOperator: Annotated[
        Optional[Literal["Equals", "GreaterOrEquals", "LessOrEquals"]],
        Field(
            description="Operator to use when matching destinationPort, either Equals, GreaterOrEquals, or LessOrEquals.",
            title="Destination Port Operator",
        ),
    ] = None
    destinationPortRange: Annotated[
        Optional[str],
        Field(
            description="Range of destination ports to match, in the format n-m, e.g. 100-200,  The start and end of the range must be port numbers.",
            title="Destination Port Range",
        ),
    ] = None
    destinationPrefix: Annotated[
        Optional[str],
        Field(description="Destination prefix to match.", title="Destination Prefix"),
    ] = None
    firstFragment: Annotated[
        Optional[bool],
        Field(description="Match the first fragment only.", title="First Fragment"),
    ] = None
    fragment: Annotated[
        Optional[bool], Field(description="Match any fragment.", title="Fragment")
    ] = None
    icmpCode: Annotated[
        Optional[List[int]],
        Field(
            description="Match a specific ICMP code, as a number between 0-255, e.g. 0.",
            max_length=255,
            min_length=0,
            title="ICMP Code",
        ),
    ] = None
    icmpTypeName: Annotated[
        Optional[
            Literal[
                "DestUnreachable",
                "Echo",
                "EchoReply",
                "EchoRequest",
                "McastRtrAdv",
                "McastRtrSolicit",
                "McastRtrTerm",
                "MldDone",
                "MldQuery",
                "MldReport",
                "MldV2",
                "NeighborAdvertise",
                "NeighborSolicit",
                "NodeInfoQuery",
                "NodeInfoResponse",
                "PacketTooBig",
                "ParamProblem",
                "Redirect",
                "RouterAdvertise",
                "RouterRenumber",
                "RouterSolicit",
                "SourceQuench",
                "TimeExceeded",
                "Timestamp",
                "TimestampReply",
            ]
        ],
        Field(
            description="Match a specific ICMP type by name, e.g. dest-unreachable.",
            title="ICMP Type Name",
        ),
    ] = None
    icmpTypeNumber: Annotated[
        Optional[int],
        Field(
            description="Match a specific ICMP type by number.",
            ge=0,
            le=255,
            title="ICMP Type Number",
        ),
    ] = None
    protocolName: Annotated[
        Optional[
            Literal[
                "AH",
                "EGP",
                "EIGRP",
                "ESP",
                "GGP",
                "GRE",
                "ICMP",
                "ICMP6",
                "IDRP",
                "IGMP",
                "IGP",
                "IPV4",
                "IPV6",
                "IPV6-DEST-OPTS",
                "IPV6-HOP",
                "L2TP",
                "MPLS-IN-IP",
                "NO-NEXT-HDR",
                "OSPF",
                "PIM",
                "ROHC",
                "RSVP",
                "SCTP",
                "ST",
                "TCP",
                "UDP",
                "VRRP",
            ]
        ],
        Field(
            description="Match a specific IP protocol name (specified in the type field of the IP header).",
            title="Protocol Name",
        ),
    ] = None
    protocolNumber: Annotated[
        Optional[int],
        Field(
            description="Match a specific IP protocol number (specified in the type field of the IP header).",
            ge=0,
            le=255,
            title="Protocol Number",
        ),
    ] = None
    sourcePortName: Annotated[
        Optional[
            Literal[
                "ACAP",
                "AFP-TCP",
                "ARNS",
                "ASF-RMCP",
                "ASHARE",
                "ATALK-RM",
                "AURP",
                "AUTH",
                "BFD",
                "BFD-ECHO",
                "BFTP",
                "BGMP",
                "BGP",
                "BOOTPC",
                "BOOTPS",
                "CCSO-NS",
                "CHARGEN",
                "CISCO-TDP",
                "CITADEL",
                "CLEARCASE",
                "COMMERCE",
                "COURIER",
                "DAYTIME",
                "DHCP-FAILOVER",
                "DHCPV6-CLIENT",
                "DHCPV6-SERVER",
                "DICOM",
                "DISCARD",
                "DNSIX",
                "DOMAIN",
                "DSP",
                "ECHO",
                "EPP",
                "ESRO",
                "EXEC",
                "FINGER",
                "FTP",
                "FTP-DATA",
                "FTPS",
                "FTPS-DATA",
                "GODI",
                "GOPHER",
                "GTP-C",
                "GTP-PRIME",
                "GTP-U",
                "HA-CLUSTER",
                "HOSTNAME",
                "HP-ALARM-MGR",
                "HTTP",
                "HTTP-ALT",
                "HTTP-MGMT",
                "HTTP-RPC",
                "HTTPS",
                "IEEE-MMS-SSL",
                "IMAP",
                "IMAP3",
                "IMAPS",
                "IPP",
                "IPSEC",
                "IPX",
                "IRC",
                "IRIS-BEEP",
                "ISAKMP",
                "ISAKMP-NAT",
                "ISCSI",
                "ISO-TSAP",
                "KERBEROS",
                "KERBEROS-ADM",
                "KLOGIN",
                "KPASSWD",
                "KSHELL",
                "L2TP",
                "LDAP",
                "LDAPS",
                "LDP",
                "LMP",
                "LOGIN",
                "LPD",
                "LSP-PING",
                "MAC-SERVER-ADM",
                "MATIP-A",
                "MATIP-B",
                "MICRO-BFD",
                "MICROSOFT-DS",
                "MOBILE-IP",
                "MONITOR",
                "MPP",
                "MS-EXCHANGE",
                "MSDP",
                "MSP",
                "MSSQL-M",
                "MSSQL-S",
                "MULTIHOP-BFD",
                "NAS",
                "NCP",
                "NETBIOS-DATA",
                "NETBIOS-NS",
                "NETBIOS-SS",
                "NETNEWS",
                "NETRJS-1",
                "NETRJS-2",
                "NETRJS-3",
                "NETRJS-4",
                "NETWALL",
                "NEW-RWHO",
                "NFS",
                "NNTP",
                "NNTPS",
                "NTP",
                "ODMR",
                "OLSR",
                "OPENVPN",
                "PIM-AUTO-RP",
                "PKIX-TIMESTAMP",
                "POP2",
                "POP3",
                "POP3S",
                "PPTP",
                "PRINT-SRV",
                "PTP-EVENT",
                "PTP-GENERAL",
                "QMTP",
                "QOTD",
                "RADIUS",
                "RADIUS-ACCT",
                "REMOTE-MAIL",
                "REMOTEFS",
                "REMOTECMD",
                "RIP",
                "RJE",
                "RLP",
                "RLZDB",
                "RMC",
                "RMONITOR",
                "RPC2PORTMAP",
                "RSYNC",
                "RTELNET",
                "RTSP",
                "SGMP",
                "SILC",
                "SMUX",
                "SNA-GW",
                "SNMP",
                "SNMP-TRAP",
                "SNPP",
                "SMTP",
                "SQL-SVCS",
                "SQL",
                "SSH",
                "SUBMISSION",
                "SUNRPC",
                "SVCLOC",
                "SYSLOG",
                "SYSTAT",
                "TACACS",
                "TALK",
                "TCPMUX",
                "TCPNETHASPSRV",
                "TFTP",
                "TIME",
                "TIMED",
                "UPS",
                "XDMCP",
                "XNS-CH",
                "XNS-MAIL",
                "XNS-TIME",
                "Z3950",
            ]
        ],
        Field(description="Source port to match by name.", title="Source Port Name"),
    ] = None
    sourcePortNumber: Annotated[
        Optional[int],
        Field(
            description="Source port to match by numerical value.",
            ge=0,
            le=65535,
            title="Source Port Number",
        ),
    ] = None
    sourcePortOperator: Annotated[
        Optional[Literal["Equals", "GreaterOrEquals", "LessOrEquals"]],
        Field(
            description="Operator to use when matching sourcePort, either Equals, GreaterOrEquals, or LessOrEquals.",
            title="Source Port Operator",
        ),
    ] = None
    sourcePortRange: Annotated[
        Optional[str],
        Field(
            description="Range of source ports to match, in the format n-m, e.g. 100-200.  The start and end of the range must be port numbers.",
            title="Source Port Range",
        ),
    ] = None
    sourcePrefix: Annotated[
        Optional[str],
        Field(description="Source prefix to match.", title="Source Prefix"),
    ] = None
    tcpFlags: Annotated[
        Optional[str],
        Field(
            description="Match TCP flags, usable with !, &, | and the flags RST, SYN, and ACK.",
            title="TCP Flags",
        ),
    ] = None


class IngressPolicySpecClassifierEntry(BaseModel):
    dot1pPolicyEntry: Annotated[
        Optional[IngressPolicySpecClassifierEntryDot1pPolicyEntry],
        Field(
            description="A Dot1p policy entry - only a single Dot1p entry is allowed per classifier resource.",
            title="Dot1p Policy Entry",
        ),
    ] = None
    dscpPolicyEntry: Annotated[
        Optional[IngressPolicySpecClassifierEntryDscpPolicyEntry],
        Field(
            description="A DSCP policy entry - only a single DSCP entry is allowed per classifier resource.",
            title="DSCP Policy Entry",
        ),
    ] = None
    ipEntry: Annotated[
        Optional[IngressPolicySpecClassifierEntryIpEntry],
        Field(
            description="An IPv4 or IPv6 multifield classifier entry.", title="IP Entry"
        ),
    ] = None
    type: Annotated[
        Literal["IPV4", "IPV6", "DOT1P", "DSCP", "AUTO"],
        Field(
            description="Type of the entry which can be IPV4, IPV6, Dot1pPolicy, DSCPPolicy, or Auto.",
            title="Type",
        ),
    ]


class IngressPolicySpecClassifier(BaseModel):
    """
    Classifier manages the configuration of traffic classification policies in a network. It includes various entry types like IPv4, IPv6, Dot1p, and DSCP policies. Each entry specifies how traffic should be classified and what actions should be taken on the matched packets.
    """

    entries: Annotated[
        List[IngressPolicySpecClassifierEntry],
        Field(
            description="Specifies the list of filter entries, in order.\nA classifier containing multiple entry types may result in multiple classifiers being created on the target node.\nIPV4 and IPV6 entries will create multifield classifier policies.",
            title="Entries",
        ),
    ]


class IngressPolicySpecForwardingClassToQueueMappingItem(BaseModel):
    forwardingClasses: Annotated[
        List[str],
        Field(
            description="The forwarding classes to which the mapping applies, these are references to ForwardingClass resources.",
            min_length=1,
            title="Forwarding Classes",
        ),
    ]
    queue: Annotated[
        str,
        Field(
            description="The queue to which the forwarding classes are mapped, this is a reference to a Queue resource.",
            title="Queue",
        ),
    ]


class IngressPolicySpecPolicerExceedAction(BaseModel):
    """
    Applies a drop-probability to packets that the policer has determined are exceeding (yellow).
    """

    dropProbabilityLevel: Annotated[
        Optional[Literal["High", "Medium", "Low"]],
        Field(title="Drop Probability Level"),
    ] = "Medium"


class IngressPolicySpecPolicerForwardingClass(BaseModel):
    forwardingClasses: Annotated[
        Optional[List[str]],
        Field(
            description="The forwarding class of the packets on which to apply the Policer.  To match all traffic set this to 'ALL'.",
            title="Forwarding Class",
        ),
    ] = None
    forwardingTypes: Annotated[
        List[
            Literal[
                "Broadcast",
                "Unicast",
                "Multicast",
                "UnknownMulticast",
                "UnknownUnicast",
                "All",
            ]
        ],
        Field(title="Forwarding Type"),
    ]


class IngressPolicySpecPolicerViolateAction(BaseModel):
    """
    Applies a drop-probability to packets that the policer has determined are exceeding (red).
    """

    dropProbabilityLevel: Annotated[
        Optional[Literal["High", "Medium", "Low", "All"]],
        Field(title="Drop Probability Level"),
    ] = "High"


class IngressPolicySpecPolicer(BaseModel):
    committedBurstSize: Annotated[
        Optional[int],
        Field(
            description="Maximum CIR bucket depth in bytes.",
            ge=0,
            le=4294967295,
            title="Committed Burst Size",
        ),
    ] = None
    committedRate: Annotated[
        Optional[int],
        Field(
            description="The committed information rate (CIR) of the policer, defined in kilobits (1024 bits) per second.",
            title="Committed Rate",
        ),
    ] = None
    committedRatePercent: Annotated[
        Optional[int],
        Field(
            description="The committed information rate (CIR) of the policer, defined as a percentage of the Interface speed on which it is applied.",
            ge=0,
            le=100,
            title="Committed Rate Percentage",
        ),
    ] = None
    exceedAction: Annotated[
        Optional[IngressPolicySpecPolicerExceedAction],
        Field(
            description="Applies a drop-probability to packets that the policer has determined are exceeding (yellow).",
            title="Exceed Action",
        ),
    ] = None
    forwardingClasses: Annotated[
        Optional[List[IngressPolicySpecPolicerForwardingClass]],
        Field(
            description="The list of forwarding classes with traffic to be sent to the policer.  Unless specified all traffic is matched for this policer.",
            title="Forwarding Class",
        ),
    ] = None
    maximumBurstSize: Annotated[
        Optional[int],
        Field(
            description="Maximum PIR bucket depth in bytes.",
            ge=0,
            le=4294967295,
            title="Maximum Burst Size",
        ),
    ] = None
    minInterfaceSpeed: Annotated[
        Optional[int],
        Field(
            description="Minimum interface speed (kbps) to calculate PeakRate and CommittedRate for devices where configuration is not supported in percentage.",
            title="Minimum Interface Speed",
        ),
    ] = None
    peakRate: Annotated[
        Optional[int],
        Field(
            description="The peak information rate (PIR) of the policer, defined in kilobits (1024 bits) per second.",
            title="Peak Rate",
        ),
    ] = None
    peakRatePercent: Annotated[
        Optional[int],
        Field(
            description="The peak information rate (PIR) of the policer, defined as a percentage of the Interface speed on which it is applied.",
            ge=0,
            le=100,
            title="Peak Rate Percentage",
        ),
    ] = None
    violateAction: Annotated[
        Optional[IngressPolicySpecPolicerViolateAction],
        Field(
            description="Applies a drop-probability to packets that the policer has determined are exceeding (red).",
            title="Violate Action",
        ),
    ] = None


class IngressPolicySpecQueueManagementItemQueue(BaseModel):
    committedBurstSize: Annotated[
        Optional[int],
        Field(description="Committed Burst Size.", title="Committed Burst Size"),
    ] = None
    maximumBurstSize: Annotated[
        Optional[int],
        Field(
            description="Maximum amount of shared buffer memory available to the queue in bytes.",
            ge=0,
            le=4294967295,
            title="Maximum Burst Size",
        ),
    ] = None
    pfcOffThreshold: Annotated[
        Optional[int],
        Field(
            description="PFC off threshold.", ge=0, le=100, title="PFC Off Threshold"
        ),
    ] = None
    pfcOnThreshold: Annotated[
        Optional[int],
        Field(description="PFC on threshold.", ge=0, le=100, title="PFC On Threshold"),
    ] = None
    pfcPauseFramePriority: Annotated[
        Optional[int],
        Field(
            description="PFC priorities indicated in generated pfc-pause-frame if congestion occurs in a given pfc-queue.",
            title="PFC Priority",
        ),
    ] = None
    pfcReservedShareBufferPercent: Annotated[
        Optional[int],
        Field(
            description="Maximum level the pfc-queue can take from pfc-reserved buffer configured per given forwarding-complex.",
            ge=0,
            le=100,
            title="PFC Reserved Buffer",
        ),
    ] = None
    queue: Annotated[
        str, Field(description="Reference to a Queue resource.", title="Queue")
    ]


class IngressPolicySpecQueueManagementItem(BaseModel):
    pfcReservedBufferPercent: Annotated[
        Optional[int],
        Field(
            description="Percentage of the linecard buffer reserved for accomodating incoming traffic while upstream node reacts to generated PFC-pause frames. Note: this percentage must be common across all EgressPolicies and QueuesSets used on the same linecard.",
            ge=0,
            le=100,
            title="PFC Reserved Linecard Buffer Percent",
        ),
    ] = None
    queues: Annotated[
        List[IngressPolicySpecQueueManagementItemQueue],
        Field(description="List of queues.", title="Queues"),
    ]


class IngressPolicySpec(BaseModel):
    """
    IngressPolicySpec defines the desired state of IngressPolicy
    """

    classifier: Annotated[
        Optional[IngressPolicySpecClassifier],
        Field(
            description="Classifier manages the configuration of traffic classification policies in a network. It includes various entry types like IPv4, IPv6, Dot1p, and DSCP policies. Each entry specifies how traffic should be classified and what actions should be taken on the matched packets.",
            title="Classifiers",
        ),
    ] = None
    forwardingClassToQueueMapping: Annotated[
        Optional[List[IngressPolicySpecForwardingClassToQueueMappingItem]],
        Field(
            description="Forwarding class to queue mapping policy.",
            title="Forwarding Class to Queue Mapping",
        ),
    ] = None
    policers: Annotated[
        Optional[List[IngressPolicySpecPolicer]],
        Field(
            description="Ordered list of policers where the first policer is evaluated first before proceeding to the next.",
            title="Policers",
        ),
    ] = None
    queueManagement: Annotated[
        Optional[List[IngressPolicySpecQueueManagementItem]],
        Field(
            description="Queue management policy for egress queues.",
            title="Queue Management",
        ),
    ] = None


IngressPolicyDeletedResourceEntry = EgressPolicyDeletedResourceEntry


class IngressPolicyDeletedResources(RootModel[List[IngressPolicyDeletedResourceEntry]]):
    root: List[IngressPolicyDeletedResourceEntry]


IngressPolicyMetadata = EgressPolicyMetadata


class PolicyAttachmentSpecAttachment(BaseModel):
    interface: Annotated[
        Optional[str],
        Field(
            description="Specifies the Interface on which to deploy the policies.",
            title="Interface",
        ),
    ] = None
    interfaceType: Annotated[
        Optional[Literal["ACCESS", "NETWORK"]],
        Field(
            description="Used for platforms that differentiate between access/service interfaces and network interface.  These platforms may require different classifiers depending on whether they are applied on access/service interfaces or network interfaces.  Specifies whether the classifier should be configured as a service Egress classifier or network Egress classifier",
            title="Interface Type",
        ),
    ] = None
    subInterfaceIndex: Annotated[
        Optional[int],
        Field(
            description="Specifies the SubInterfaceIndex on which to deploy the policies.",
            title="SubInterface Index",
        ),
    ] = None


class PolicyAttachmentSpec(BaseModel):
    """
    PolicyAttachmentSpec defines the desired state of PolicyAttachment
    """

    attachments: Annotated[
        List[PolicyAttachmentSpecAttachment],
        Field(
            description="Specifies a list of Interfaces and subinterfaces on which to deploy the policies.",
            title="Interfaces",
        ),
    ]
    egressPolicy: Annotated[
        Optional[str],
        Field(
            description="Specifies an EgressPolicy to deploy on the specified Node.",
            title="Egress Policy",
        ),
    ] = None
    ingressPolicy: Annotated[
        Optional[str],
        Field(
            description="Specifies the IngressPolicy to deploy on the specified Node.",
            title="Ingress Policy",
        ),
    ] = None


PolicyAttachmentDeletedResourceEntry = EgressPolicyDeletedResourceEntry


class PolicyAttachmentDeletedResources(
    RootModel[List[PolicyAttachmentDeletedResourceEntry]]
):
    root: List[PolicyAttachmentDeletedResourceEntry]


PolicyAttachmentMetadata = EgressPolicyMetadata


class PolicyDeploymentSpec(BaseModel):
    """
    PolicyDeploymentSpec defines the desired state of PolicyDeployment
    """

    egressPolicy: Annotated[
        Optional[str],
        Field(
            description="Specifies an EgressPolicy to deploy on the specified Node.",
            title="Egress Policy",
        ),
    ] = None
    ingressPolicy: Annotated[
        Optional[str],
        Field(
            description="Specifies the IngressPolicy to deploy on the specified Node.",
            title="Ingress Policy",
        ),
    ] = None
    interfaceSelector: Annotated[
        Optional[List[str]],
        Field(
            description="Specifies a label selector to filter the interfaces on which to deploy the policies.",
            title="Interface Selector",
        ),
    ] = None
    interfaceType: Annotated[
        Optional[Literal["ACCESS", "NETWORK"]],
        Field(
            description="Used for platforms that differentiate between access/service interfaces and network interface.  These platforms may require different classifiers depending on whether they are applied on access/service interfaces or network interfaces.  Specifies whether the classifier should be configured as a service Egress classifier or network Egress classifier",
            title="Interface Type",
        ),
    ] = None
    interfaces: Annotated[
        Optional[List[str]],
        Field(
            description="Specifies a list of Interfaces on which to deploy the policies.",
            title="Interfaces",
        ),
    ] = None
    node: Annotated[
        Optional[str],
        Field(description="Specifies a Node to deploy the policies on.", title="Node"),
    ] = None
    nodeSelector: Annotated[
        Optional[List[str]],
        Field(
            description="Specifies a label selector to filter the nodes on which to deploy the policies.",
            title="Node Selector",
        ),
    ] = None


PolicyDeploymentDeletedResourceEntry = EgressPolicyDeletedResourceEntry


class PolicyDeploymentDeletedResources(
    RootModel[List[PolicyDeploymentDeletedResourceEntry]]
):
    root: List[PolicyDeploymentDeletedResourceEntry]


PolicyDeploymentMetadata = EgressPolicyMetadata


class QueueSpec(BaseModel):
    """
    The Queue resource is used to define the properties of a queue, which can then be referenced by other resources.
    """

    queueID: Annotated[
        Optional[int],
        Field(
            description="The ID of the queue on which to apply the properties.  This is mandatory for usage of queus on SROS and is ignored on other operating systems.",
            title="Queue ID",
        ),
    ] = None
    queueType: Annotated[
        Literal["Normal", "Pfc"],
        Field(
            description="QueueType specifies whether this is a normal queue or a PFC queue",
            title="Queue Type",
        ),
    ]
    trafficType: Annotated[
        Literal["Unicast", "Multicast"],
        Field(
            description="The traffic type of the queue, either unicast or multicast.",
            title="Traffic Type",
        ),
    ]


QueueDeletedResourceEntry = EgressPolicyDeletedResourceEntry


class QueueDeletedResources(RootModel[List[QueueDeletedResourceEntry]]):
    root: List[QueueDeletedResourceEntry]


QueueMetadata = EgressPolicyMetadata


class AppGroup(BaseModel):
    apiVersion: Optional[str] = None
    kind: Optional[str] = None
    name: Optional[str] = None
    preferredVersion: Optional[AppGroupVersion] = None
    versions: Optional[List[AppGroupVersion]] = None


class ResourceHistory(RootModel[List[ResourceHistoryEntry]]):
    root: List[ResourceHistoryEntry]


class Status(BaseModel):
    apiVersion: Optional[str] = None
    details: Optional[StatusDetails] = None
    kind: Optional[str] = None
    string: Optional[str] = None


class TopoElemMetadata(BaseModel):
    attributes: Optional[Dict[str, TopoAttrMetadata]] = None
    schema_: Annotated[Optional[TopoSchema], Field(alias="schema")] = None
    subtitle: Optional[str] = None
    subtitle_key: Optional[str] = None


class TopoOverlayEndpoint(BaseModel):
    attributes: Optional[Dict[str, Dict[str, Any]]] = None
    cr_name: Optional[str] = None
    labels: Optional[Dict[str, str]] = None
    name: Optional[str] = None
    namespace: Optional[str] = None
    overlays: Optional[Dict[str, TopoOverlayEndpointState]] = None
    schema_: Annotated[Optional[TopoSchema], Field(alias="schema")] = None
    state: Optional[int] = None
    ui_name: Optional[str] = None


class TopoOverlayLink(BaseModel):
    attributes: Optional[Dict[str, Dict[str, Any]]] = None
    cr_name: Optional[str] = None
    endpoint_a: Optional[TopoLinkEndpoint] = None
    endpoint_a_details: Optional[TopoOverlayEndpoint] = None
    endpoint_b: Optional[TopoLinkEndpoint] = None
    endpoint_b_details: Optional[TopoOverlayEndpoint] = None
    key: Optional[str] = None
    labels: Optional[Dict[str, str]] = None
    name: Optional[str] = None
    namespace: Optional[str] = None
    overlays: Optional[Dict[str, TopoOverlayLinkState]] = None
    schema_: Annotated[Optional[TopoSchema], Field(alias="schema")] = None
    state: Optional[int] = None
    ui_name: Optional[str] = None


class TopoOverlayNode(BaseModel):
    attributes: Optional[Dict[str, Dict[str, Any]]] = None
    badges: Optional[List[int]] = None
    cr_name: Optional[str] = None
    grouping: Optional[TopoNodeGrouping] = None
    key: Optional[str] = None
    labels: Optional[Dict[str, str]] = None
    name: Optional[str] = None
    namespace: Optional[str] = None
    overlays: Optional[Dict[str, TopoOverlayNodeState]] = None
    schema_: Annotated[Optional[TopoSchema], Field(alias="schema")] = None
    state: Optional[int] = None
    ui_name: Optional[str] = None


class Topology(BaseModel):
    endpoints: Optional[TopoElemMetadata] = None
    group: Optional[str] = None
    grouping: Optional[TopoSchema] = None
    links: Optional[TopoElemMetadata] = None
    name: Optional[str] = None
    nodes: Optional[TopoElemMetadata] = None
    ui_description: Optional[str] = None
    ui_description_key: Optional[str] = None
    ui_name: Optional[str] = None
    ui_name_key: Optional[str] = None
    version: Optional[str] = None


class EgressPolicy(BaseModel):
    """
    EgressPolicy is the Schema for the egresspolicys API
    """

    apiVersion: Annotated[str, Field(pattern="^qos\\.eda\\.nokia\\.com/v1$")]
    kind: Annotated[str, Field(pattern="^EgressPolicy$")]
    metadata: EgressPolicyMetadata
    spec: Annotated[
        EgressPolicySpec,
        Field(
            description="EgressPolicySpec defines the desired state of EgressPolicy",
            title="Specification",
        ),
    ]
    status: Annotated[
        Optional[Dict[str, Any]],
        Field(
            description="EgressPolicyStatus defines the observed state of EgressPolicy",
            title="Status",
        ),
    ] = None


class EgressPolicyList(BaseModel):
    """
    EgressPolicyList is a list of egresspolicys
    """

    apiVersion: str
    items: Optional[List[EgressPolicy]] = None
    kind: str


class ForwardingClass(BaseModel):
    """
    ForwardingClass is the Schema for the forwardingclasss API
    """

    apiVersion: Annotated[str, Field(pattern="^qos\\.eda\\.nokia\\.com/v1$")]
    kind: Annotated[str, Field(pattern="^ForwardingClass$")]
    metadata: ForwardingClassMetadata
    spec: Annotated[
        Optional[Dict[str, Any]],
        Field(
            description="The ForwaringClass is used as a placeholder for to allow multiple other resources to reference the same forwarding class.",
            title="Specification",
        ),
    ] = None
    status: Annotated[
        Optional[Dict[str, Any]],
        Field(
            description="ForwardingClassStatus defines the observed state of ForwardingClass",
            title="Status",
        ),
    ] = None


class ForwardingClassList(BaseModel):
    """
    ForwardingClassList is a list of forwardingclasss
    """

    apiVersion: str
    items: Optional[List[ForwardingClass]] = None
    kind: str


class IngressPolicy(BaseModel):
    """
    IngressPolicy is the Schema for the ingresspolicys API
    """

    apiVersion: Annotated[str, Field(pattern="^qos\\.eda\\.nokia\\.com/v1$")]
    kind: Annotated[str, Field(pattern="^IngressPolicy$")]
    metadata: IngressPolicyMetadata
    spec: Annotated[
        IngressPolicySpec,
        Field(
            description="IngressPolicySpec defines the desired state of IngressPolicy",
            title="Specification",
        ),
    ]
    status: Annotated[
        Optional[Dict[str, Any]],
        Field(
            description="IngressPolicyStatus defines the observed state of IngressPolicy",
            title="Status",
        ),
    ] = None


class IngressPolicyList(BaseModel):
    """
    IngressPolicyList is a list of ingresspolicys
    """

    apiVersion: str
    items: Optional[List[IngressPolicy]] = None
    kind: str


class PolicyAttachment(BaseModel):
    """
    PolicyAttachment is the Schema for the policyattachments API
    """

    apiVersion: Annotated[str, Field(pattern="^qos\\.eda\\.nokia\\.com/v1$")]
    kind: Annotated[str, Field(pattern="^PolicyAttachment$")]
    metadata: PolicyAttachmentMetadata
    spec: Annotated[
        PolicyAttachmentSpec,
        Field(
            description="PolicyAttachmentSpec defines the desired state of PolicyAttachment",
            title="Specification",
        ),
    ]
    status: Annotated[
        Optional[Dict[str, Any]],
        Field(
            description="PolicyAttachmentStatus defines the observed state of PolicyAttachment",
            title="Status",
        ),
    ] = None


class PolicyAttachmentList(BaseModel):
    """
    PolicyAttachmentList is a list of policyattachments
    """

    apiVersion: str
    items: Optional[List[PolicyAttachment]] = None
    kind: str


class PolicyDeployment(BaseModel):
    """
    PolicyDeployment is the Schema for the policydeployments API
    """

    apiVersion: Annotated[str, Field(pattern="^qos\\.eda\\.nokia\\.com/v1$")]
    kind: Annotated[str, Field(pattern="^PolicyDeployment$")]
    metadata: PolicyDeploymentMetadata
    spec: Annotated[
        PolicyDeploymentSpec,
        Field(
            description="PolicyDeploymentSpec defines the desired state of PolicyDeployment",
            title="Specification",
        ),
    ]
    status: Annotated[
        Optional[Dict[str, Any]],
        Field(
            description="PolicyDeploymentStatus defines the observed state of PolicyDeployment",
            title="Status",
        ),
    ] = None


class PolicyDeploymentList(BaseModel):
    """
    PolicyDeploymentList is a list of policydeployments
    """

    apiVersion: str
    items: Optional[List[PolicyDeployment]] = None
    kind: str


class Queue(BaseModel):
    """
    Queue is the Schema for the queues API
    """

    apiVersion: Annotated[str, Field(pattern="^qos\\.eda\\.nokia\\.com/v1$")]
    kind: Annotated[str, Field(pattern="^Queue$")]
    metadata: QueueMetadata
    spec: Annotated[
        QueueSpec,
        Field(
            description="The Queue resource is used to define the properties of a queue, which can then be referenced by other resources.",
            title="Specification",
        ),
    ]
    status: Annotated[
        Optional[Dict[str, Any]],
        Field(
            description="QueueStatus defines the observed state of Queue",
            title="Status",
        ),
    ] = None


class QueueList(BaseModel):
    """
    QueueList is a list of queues
    """

    apiVersion: str
    items: Optional[List[Queue]] = None
    kind: str


class OverlayState(BaseModel):
    links: Optional[Dict[str, TopoOverlayLink]] = None
    nodes: Optional[Dict[str, TopoOverlayNode]] = None


class ResourceTopology(BaseModel):
    topology: Optional[OverlayState] = None
    topologyMetadata: Optional[Topology] = None
